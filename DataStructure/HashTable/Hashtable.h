/*
 * @Author: fengsc
 * @Date: 2021-12-17 21:48:49
 * @LastEditTime: 2021-12-18 01:31:32
 */
const static int MAX_REGULAR_CAPACITIES = 674;
//满足模4余3的素数
const static int REGULAR_CAPACITIES[] = {7, 11, 19, 23, 43, 47, 67, 79, 83, 103,
                                         127, 131, 139, 151, 163, 167, 199, 211, 223, 251,
                                         263, 271, 283, 307, 331, 359, 367, 379, 383, 439,
                                         443, 463, 467, 479, 487, 491, 499, 503, 523, 547,
                                         563, 571, 587, 607, 619, 631, 643, 647, 683, 691,
                                         719, 727, 739, 743, 751, 787, 811, 823, 839, 859,
                                         863, 883, 887, 907, 911, 919, 947, 967, 971, 983,
                                         991, 1039, 1051, 1063, 1087, 1103, 1123, 1163, 1171, 1187,
                                         1223, 1231, 1259, 1279, 1283, 1291, 1303, 1307, 1327, 1367,
                                         1399, 1423, 1439, 1447, 1459, 1471, 1483, 1499, 1511, 1523,
                                         1531, 1543, 1559, 1567, 1571, 1579, 1583, 1627, 1663, 1699,
                                         1723, 1747, 1759, 1783, 1811, 1823, 1831, 1847, 1867, 1879,
                                         1907, 1951, 1979, 1987, 1999, 2003, 2011, 2039, 2063, 2083,
                                         2099, 2131, 2143, 2179, 2203, 2207, 2239, 2243, 2251, 2287,
                                         2311, 2347, 2351, 2371, 2383, 2399, 2411, 2423, 2447, 2459,
                                         2467, 2503, 2531, 2539, 2543, 2551, 2579, 2647, 2659, 2663,
                                         2671, 2683, 2699, 2707, 2719, 2731, 2767, 2791, 2803, 2819,
                                         2843, 2851, 2879, 2887, 2903, 2927, 2939, 2963, 2971, 3011,
                                         3019, 3023, 3067, 3079, 3083, 3163, 3187, 3191, 3203, 3259,
                                         3271, 3307, 3319, 3323, 3331, 3343, 3347, 3391, 3407, 3463,
                                         3491, 3499, 3511, 3547, 3559, 3571, 3583, 3607, 3623, 3631,
                                         3643, 3659, 3691, 3719, 3727, 3739, 3779, 3803, 3823, 3847,
                                         3863, 3907, 3911, 3919, 3923, 3931, 3943, 3947, 3967, 4003,
                                         4007, 4027, 4051, 4079, 4099, 4111, 4139, 4159, 4211, 4219,
                                         4231, 4243, 4283, 4327, 4339, 4363, 4391, 4423, 4447, 4451,
                                         4463, 4483, 4507, 4519, 4523, 4567, 4583, 4591, 4603, 4639,
                                         4643, 4651, 4663, 4679, 4691, 4703, 4723, 4751, 4759, 4783,
                                         4831, 4871, 4903, 4919, 4943, 4951, 4987, 4999, 5003, 5011,
                                         5023, 5039, 5051, 5059, 5087, 5107, 5119, 5147, 5167, 5171,
                                         5179, 5227, 5303, 5323, 5347, 5351, 5387, 5399, 5407, 5419,
                                         5431, 5443, 5471, 5479, 5483, 5503, 5507, 5527, 5531, 5563,
                                         5591, 5623, 5647, 5659, 5683, 5711, 5743, 5779, 5827, 5851,
                                         5903, 5927, 6007, 6067, 6091, 6143, 6199, 6247, 6271, 6311,
                                         6451, 6491, 6607, 6691, 6703, 6763, 6803, 6871, 6883, 6983,
                                         7039, 7103, 7151, 7247, 7283, 7411, 7459, 7591, 7687, 7723,
                                         7759, 7879, 7883, 7919, 7951, 7963, 8011, 8123, 8191, 8263,
                                         8431, 8539, 8563, 8599, 8663, 8699, 8779, 8863, 8887, 8971,
                                         9091, 9127, 9199, 9283, 9311, 9343, 9467, 9511, 9547, 9587,
                                         9631, 9679, 9811, 9859, 9883, 9931, 9967, 10039, 10223, 10303,
                                         10343, 10391, 10459, 10531, 10567, 10663, 10711, 10831, 10891, 10939,
                                         11027, 11059, 11071, 11119, 11243, 11299, 11383, 11491, 11551, 11579,
                                         11731, 11779, 11887, 11987, 12043, 12163, 12263, 12323, 12379, 12479,
                                         12703, 12763, 12823, 12919, 13003, 13099, 13159, 13219, 13291, 13339,
                                         13399, 13487, 13711, 13763, 13831, 13879, 13999, 14083, 14143, 14251,
                                         14323, 14479, 14551, 14563, 14731, 14939, 15139, 15199, 15271, 15331,
                                         15439, 15511, 15583, 15739, 15991, 16063, 16231, 16363, 16747, 16831,
                                         16903, 17107, 17191, 17419, 17599, 17683, 17791, 17839, 17911, 17959,
                                         18043, 18523, 18583, 18839, 19471, 19543, 19603, 19699, 19843, 19891,
                                         19963, 20051, 20359, 20443, 20479, 20551, 20719, 20899, 20983, 21319,
                                         21391, 21559, 21739, 22039, 22171, 22483, 22543, 22639, 22751, 22963,
                                         23087, 23203, 23371, 23431, 23539, 23743, 23911, 24571, 24799, 24919,
                                         24979, 25171, 25183, 25303, 25411, 25471, 25579, 25999, 26251, 26431,
                                         26683, 26731, 26863, 27283, 27583, 27691, 27919, 28099, 28183, 28279,
                                         28411, 28879, 29023, 29131, 29243, 29423, 29671, 30139, 30271, 30391,
                                         30559, 30931, 31123, 31567, 31723, 32143, 32299, 32563, 32719, 32911,
                                         33151, 33427, 33751, 33863, 34159, 34303, 34471, 34591, 34759, 34843,
                                         34963, 35107, 35731, 35839, 36187, 36343, 36599, 37363, 38239, 38923,
                                         39043, 39163, 39343, 39511, 39631, 40039, 40231, 40531, 40699, 40939,
                                         41143, 41611, 41959, 42283, 42463, 42643, 43051, 43399, 43579, 43783,
                                         43891, 44203, 44383, 45599, 45823, 46051, 46591, 46831, 47059, 47431,
                                         47659, 48991, 49123, 50023, 50263, 50647, 52291, 52543, 52711, 53299,
                                         53551, 53719, 53899, 54403, 54647, 54919, 55051, 55219, 55663, 56479,
                                         56911, 57271, 58111, 58603, 59011, 59359, 59791, 60091, 62131, 62311,
                                         63031, 64303, 64579, 64879, 65839, 66571, 67759, 68491, 69151, 70123,
                                         71263, 72871, 73039, 73363, 74383, 74719, 75391, 75619, 75991, 76543,
                                         77239, 77419, 78139, 78511, 79231, 81199, 82531, 82891, 84391, 84811,
                                         85819, 88663, 89083, 89599, 90019, 90679, 92671, 94651, 95443, 95791,
                                         97003, 97843, 98299, 99991};
#include <iostream>
template <typename V>
class Hashtable //基于除留余数法和双向平方探测
{

private:
    V *vals;
    bool *status;
    int M;
    enum
    {
        FREE,
        ACTIVE
    };
    int hashCode(int val) { return val % M; }
    int HashCode(char val) { return (int)val % M; }
    int HashCode(long val) { return (int)(val ^ (val >> 32)) % M; }
    int hashCode(std::string val)
    {
        int hash = 0;
        for (int i = 0; i < val.length(); i++)
            hash = (hash << 5 - hash + (int)val[i]) % M;
        return hash;
    }
    int searchCapacity(int target) //二分查找，返回大于等于target的最小素数
    {
        int left = 0, right = MAX_REGULAR_CAPACITIES - 1, middle;
        while (left < right)
        {
            middle = left + ((right - left) >> 1); //注意位运算优先级很低
            if (REGULAR_CAPACITIES[middle] < target)
            {
                left = middle + 1;
            }
            else if (REGULAR_CAPACITIES[middle] > target)
            {
                right = middle - 1;
            }
            else
            {
                return REGULAR_CAPACITIES[middle]; //等于的概率极低
            }
        }
        return REGULAR_CAPACITIES[left]; //事实上此时left==right
    }

public:
    Hashtable(int size = 0)
    {
        M = (2 * size <= 5 ? 5 : searchCapacity(2 * size)); //初始容量满足双向探测的装填因子要求
        vals = new V[M];
        status = new bool[M]();
    }
    ~Hashtable()
    {
        delete[] vals;
        delete[] status;
    }
    bool findPos(const V &val, int &pos)
    {
        int key = hashCode(val);
        pos = key;
        if (status[key] == ACTIVE && vals[key] == val)
            return true;
        if (status[key] == FREE)
            return false;
        int base = key;
        for (int k = 1; k <= M / 2; k++)
        {
            pos = key = (base + k * k) % M;
            if (status[key] == FREE)
                return false;
            if (status[key] == ACTIVE && vals[key] == val)
                return true;
            key = (base - k * k) % M;
            while (key < 0) //!
                key += M;
            pos = key;
            if (status[key] == FREE)
                return false;
            if (status[key] == ACTIVE && vals[key] == val)
                return true;
        }
        pos = -1; //没查找到且没空位
        return false;
    }
    bool insert(const V &value)
    {
        int pos;
        if (findPos(value, pos) || pos == -1) //已存在或已满
            return false;
        vals[pos] = value;
        status[pos] = ACTIVE;
        return true;
    }
    bool remove(const V &value)
    {
        int pos;
        if (!findPos(value, pos))
            return false;
        status[pos] = FREE;
        return true;
    }
    void print() //输出hashcode和val
    {
        for (int i = 0; i < M; i++)
        {
            if (status[i] == ACTIVE)
                std::cout << '[' << hashCode(i) << "]:" << vals[i] << std::endl;
        }
    }
};