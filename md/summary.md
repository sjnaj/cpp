面向过程以过程划分问题，高耦合，高性能
面向对象以功能划分问题，低耦合，低性能

c++多态有以下几种：

重载。函数重载和运算符重载，编译期。

虚函数。子类的多态性，运行期。

在继承关系中，对于父类的方法我们也同样使用。但是正常来说，我们希望方法的行为取决于调用方法的对象，而不是指针或引用指向的对象有关。

模板，类模板，函数模板。编译期



int[0]:因为柔性数组本身是无法确定有几个字节的，所以计算整体结构体大小时，会省略柔性数组的计算。

mmap在堆与栈之间，与栈增长方向相同

mmap用来在进程虚拟内存地址空间中分配地址空间，创建和物理内存的映射关系。

空闲链表

bss段：（Block Started by Symbol）存放程序中未初始化的**全局变量**的一块内存区域，在程序载入时由内核置为0。

data段：**static变量和所有初始化的全局变量**都在data段中。


text段：代码段，text段在内存中被映射为只读

static:限制作用域，延长生命周期，对象共享。 全局的编译初始化，局部的运行初始化（是线程安全的）

引用和常量指针的汇编代码是一模一样的，所以可以得出在底层，引用就是一个常量指针。
引用是变量的别名，它不能脱离被引用对象独立存在

const:只读
constexpr:常量

左值是可以取地址、位于赋值符号左边的值
非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。
将亡值是与右值引用相关的表达式，比如，将要被移动的对象、T&&函数返回值、std::move返回值和转换为T&&的类型的转换函数的返回值等
第一个问题就是临时对象非必要的昂贵的拷贝操作，第二个问题是在模板函数中如何按照参数的实际类型进行转发。

return static_cast<T&&>(t);

完美转发：template <typename T>
void f(T&& val){ 
	foo(std::forward<T>(val)); 
}

当接收一个左值作为参数时，std::forward<>()返回左值引用，相应的，当接收一个右值作为参数时，std::forward<>()返回右值引用。



如果父类的虚函数没有被子类改写， 那么子类的虚函数表中的元素就是父类的对应的虚函数指针；相反，如果子类改写了父类的虚函数，那么对应的虚函数表中的元素就是自己的虚函数指针，决议这个指向的过程发生在运行时，就是所谓的动态绑定.

编译器中主要用虚表指针（vptr）和虚函数表（vtbl）来实现的

空类的大小为1字节
一个类中，虚函数本身、成员函数（包括静态与非静态）和静态数据成员都是不占用类对象的存储空间。
对于包含虚函数的类，不管有多少个虚函数，**只有一个虚指针,vptr的大小**。



基类声明一个虚析构函数，为了确保释放派生对象时，按照正确的顺序调用析构函数。

抽象类无法实例化对象

不能实例化：类中包含纯虚函数。构造函数私有
拷⻉构造函数的函数参数为对象本身的引用

类中const成员常量必须在构造函数初始化列表中初始化。
类中static成员变量，必须在类外初始化。

malloc失败，会返回空指针。

new失败，默认是抛出异常，要捕获异常bad_alloc

alloca函数分配的内存不需要手动释放，和普通的栈上对象的处理一样：超出作用域自动回收内存。

向上就是派生类指针变成基类指针，向下就是基类指针变成派生类指针。

static_cast：实现隐式转换

dynamic_cast主要用于执行“安全的向下转型”
RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。

RAII的核心思想是将资源或者状态与对象的生命周期绑定，即拿即用，用完即放 。

const_cast转换符是用来移除const或volatile/ˈvɑːlət(ə)l/属性
不能用于去除变量的常量性，而是去除指向对象的引用或指针的常量性，因此去除对象必须是指针或者引用。

RAII是c++中的一个惯用法，即“Resource Acquisition Is Initialization”，翻译为“资源获取就初始化”

valgrind ，这个可以打印出发生内存泄露的部分代码

decltype 可以让你获得编译期的类型。 auto不能。所以当你需要某个表达式的返回值类型而又不想实际执行它时用decltype。

shared_ptr修改指针指向的时候会不安全。 同一个shared_ptr被多个线程“读”是安全的。同一个shared_ptr被多个线程“写”是不安全的(多个线程操作同一个shared_ptr对象)。如下面的代码：

由于shared_ptr是通过引用计数来管理原生指针的，那么最大的问题就是循环引用（比如 a 对象持有 b 对象，b 对象持有 a 对象），这样必然会导致内存泄露(无法删除)。而weak_ptr不会增加引用计数，因此将循环引用的一方修改为弱引用，可以避免内存泄露
同时由于weak_ptr没有重载运算符*，->，因此他不操作资源，只是观测

[外部变量访问方式说明符] (参数) (opt:mutable noexcept/throw()) -> 返回值类型{body

lambda 表达式的 operator() 默认是 const
mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）

nullptr并非整型类别，甚至也不是指针类型，但是能转换成任意指针类型。nullptr的实际类型是std:nullptr_t。
避免NULL和0产生的二义性

const和引用都必须初始化而不能被赋值，都需要成员列表初始化。

成员初始化的一些特点：

成员的初始化顺序与成员的声明顺序相同
成员的初始化顺序与初始化列表中的位置无关
初始化列表先于构造函数的函数体执行

初始化类成员时使用列表初始化少一次构造函数的调用

std::bind：柯里化

=delete
禁止编译器生成这些函数

using：取代typedef
让父类同名函数在子类中以重载方式使用

sizeof（空类或者只有函数）=1
sizeof(多了有虚函数)=vptr大小

volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值

C/C++多线程编程中不要使用volatile。C++11标准中明确指出解决多线程的数据竞争问题应该使用原子操作或者互斥锁。

因为C和C++中的volatile并不是用来解决多线程竞争问题的，而是用来修饰一些因为程序不可控因素导致变化的变量，比如访问底层硬件设备的变量，以提醒编译器不要对该变量的访问擅自进行优化。

RVO (return value optimization) 和NRVO (named return value optimization) 是C++在处理 “返回一个class object的函数” 时常用的优化技术，主要作用就是消除临时对象的构造和析构成本。

编译器启用NRVO的前提条件是返回值是具名的。

source code→preprocessor→compiler→assembler→object code→Linker→executables

野指针(wild pointer)指的是未经初始化的指针

悬挂指针(dangling pointer)指的是已经销毁的对象或已经回收的地址

优先调用普通函数
可以使用空模板参数来强制调用模板函数

函数模板不能是虚函数(virtual),不能确定vtlb的大小

普通类中的成员函数在编译的时候就创建
类模板中的成员函数在调用的时候才会创建

由template<…>处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。

后置加加必须产生临时对象，临时对象会导致效率降低

STL包含6大部件：容器、迭代器、算法、仿函数、适配器和内存配置器。

emplace_back(10, “test”)可以只调用一次constructor
而push_back(MyClass(10, “test”))中MyClass(10, “test”)调用了一次构造函数，同时值传递又调用拷贝构造函数。

如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。

deque是在功能上合并了vector和list。

multi 重复数据
关联容器一般指map,multimap,set,multiset这四种底层实现都是红黑树。对于关联容器来说，存储的只是节点。插入删除只是节点指针的换来换去，不需要做内存拷贝和内存移动。

map的下标运算符[]的作用是：将key作为下标去执行查找，并返回对应的值；如果不存在这个key，就将一个具有该关键码和值类型的默认值的项插入这个map。
map的find函数：用key执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器。

顺序容器（序列式容器，比如vector、deque）

erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；

It = c.erase(it);
关联容器(关联式容器，比如map、set、multimap、multiset等)

erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；

c.erase(it++)

| array                              | 随机访问迭代器   |
| vector                             | 随机访问迭代器   |
| deque                              | 随机访问迭代器   |
| list	                             |双向迭代器     |
| set / multiset                     | 双向迭代器       |
| map / multimap                     | 双向迭代器       |
| forward_list                       | 前向迭代器       |
| unordered_map / unordered_multimap | 前向迭代器       |
| unordered_set / unordered_multiset | 前向迭代器       |
| stack                              | 不支持迭代器     |
| queue                              | 不支持迭代器     |

stable_sort (first, last)和sort() 函数功能相似，不同之处在于该函数不会改变它们的相对位置。

stable_sort() 函数是基于归并排序实现的。

sort() 函数是基于快速排序实现的。

CFS（完全公平调度）：红黑树


所以当服务器端收到客户端的FIN报文段后，必须马上回一个ACK确认报文表示可以关，但此时可能服务器端有一些数据需要处理，所以说等处理完数据我再发一个FIN关闭报文给客户端告诉客户端我这边也要关闭了。

客户端，他发送ACK给服务器端后，客户端并不知道服务端有没有收到这个报文，客户端会这么想：

服务器没收到ACK，我就等着超时重传
服务器收到自己的ACK了，也不会发消息
ping命令向主机B通信的时候

主机A会构建一个ICMP回送请求消息数据报，

//找到上次git commit的id
git log
//执行撤销操作，同时将代码恢复到该commit_id之前的代码提交状态
git reset --hard  commit_id
//执行撤销但是保留更改
git reset  commit_id

内存泄漏分为以下两类：

堆内存泄漏：我们经常说的内存泄漏就是堆内存泄漏，在堆上申请了资源，在结束使用的时候，没有释放归还给OS，从而导致该块内存永远不会被再次使用
资源泄漏：通常指的是系统资源，比如socket，文件描述符等，因为这些在系统中都是有限制的，如果创建了而不归还，久而久之，就会耗尽资源，导致其他程序不可用

栈的动态分配则通过alloca()函数

栈有操作系统分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高
堆内存的申请和释放专门有运行时库提供的函数，里面涉及复杂的逻辑，申请和释放效率低于栈

导致内存泄漏：
	new[] 和 delete/free
	析构函数不为虚
	循环引用：使用weak_ptr:通过lock()返回shared_ptr访问

用过STL的知道，STL内部有一个自己的allocator，我们可以当做一个memory poll，当调用vector.clear()时候，内存并不会归还OS，而是放回allocator，其内部根据一定的策略，在特定的时候将内存归还OS

name mangling名称编码


可用反汇编命令查看名字编码

objdump -t class(可执行文件名)

用c++filt查看原函数

c++filt _ZN6Derive4funcEv

输出：Derive::func()

滞留的请求报文建立连接

FIN_wait1 wait2
last_ack timewait 2MSL
 Client 发送的确认报文可能丢失

 确认对方收到ACK报文，在 2MSL 内没有收到 FIN 报文，说明 Server 端收到了确认报文,受到则重发ACK

 在发送端通过拥塞窗口，在接收端通过滑动窗口。

ET只通知一次读写事件

零拷贝技术
splice( )函数

tee( )函数

可以快速高效地将数据通过DMA从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间

零拷贝主要技术有 mmap+write、sendfile和splice等几种方式。

connect成功返回是在第二步，accept成功返回是在第三步

处于“LISTENING”状态的TCP socket，有两个独立的队列：

SYN队列(SYN Queue)
Accept队列(Accept Queue)

select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写
从消息处理层面来看，epoll是异步的

"sizeof引用"得到的是所指向的变量(对象)的大小，而"sizeof指针"得到的是指针本身的大小；

vtable在text段里，vptr和对象在一起

编译器简历虚表的过程有三步：

拷贝基类的虚函数表，如果是多继承，就拷贝每个基类的虚函数表
查看派生类中是否有重写基类的虚函数，如果有，就替换成已经重写后的虚函数地址
查看派生类中是否有新添加的虚函数，如果有，就加入到自身的虚函数表中

虚函数表需要在对象实例化之后才能够进行调用

纯虚基类函数=0，这个类的继承类里面必须要实现这个函数。

只能在栈上生成对象的类。

只有使用new运算符才会在堆上创建对象。重载为私有即可。

只能在堆上生成对象的类：构造和析构设为protected，使用静态函数调用new创建

class  A  
{  
protected :  
    A(){}  
    ~A(){}  
public :  
    static  A* create()  
    {  
        return  new  A();  
    }  
    void  destory()  
    {  
        delete  this ;  
    }  
};  

析构函数不能抛出异常原因有两个：

资源泄漏的问题。
异常嵌套程序崩溃。

动态库只有一个副本，根据路径LD_lIBRARY_PATH

根叶黑，不红红，黑路同

生成默认构造函数：成员提供了，基类提供了，有虚函数，虚继承

菱形继承：
虚继承，避免菱形继承带来的二义性和空间浪费，使变量执行同一个位置，子类指向同一个（父类的父类）
-fdump-class-hierarchy 查看类的内存分布


malloc <128k时用brk从堆区内存池中分配,free时归还给内存池
否则用mmap从映射区分配，free时归还操作系统

16字节的描述信息用于free使用

reactor是同步的，检测和执行事件，proactor将请求投递给内核



懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）
c++11之后：magic static 
之前：双重检查,atomic
std::call_once，
线程单例 static thread_local/std::unordered_map<std::thread::id, C*>


饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）