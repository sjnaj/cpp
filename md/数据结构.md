- [数据结构与算法](#数据结构与算法)
  - [绪论](#绪论)
    - [基本术语](#基本术语)
    - [C语言知识点补充](#c语言知识点补充)
      - [运算符结合方向和结合性和自增自减(auto-increment,auto-decrement)](#运算符结合方向和结合性和自增自减auto-incrementauto-decrement)
      - [数字与字符串转换](#数字与字符串转换)
      - [二维数组传参](#二维数组传参)
      - [动态内存分配](#动态内存分配)
      - [A&&B和A||B的短路规则(short-circuited)](#ab和ab的短路规则short-circuited)
      - [查看函数中数组的值](#查看函数中数组的值)
      - [删除元素和求特定元素](#删除元素和求特定元素)
      - [进制转换](#进制转换)
      - [log和exp](#log和exp)
      - [选择排序法小简化](#选择排序法小简化)
      - [浅拷贝和深拷贝](#浅拷贝和深拷贝)
      - [获取随机数](#获取随机数)
      - [快排函数（quick sort）](#快排函数quick-sort)
    - [算法和算法设计](#算法和算法设计)
      - [算法的特性](#算法的特性)
      - [测量程序运行时间](#测量程序运行时间)
      - [算法的复杂度(complexity)，度量和问题规模](#算法的复杂度complexity度量和问题规模)
      - [渐进的时间复杂度](#渐进的时间复杂度)
      - [markdown 语法](#markdown-语法)
      - [时间复杂度例题](#时间复杂度例题)
        - [循环嵌套](#循环嵌套)
        - [递归，分治](#递归分治)
        - [Binary Search(二分查找)](#binary-search二分查找)
        - [最大公约数和最小公倍数以及 二分法求根](#最大公约数和最小公倍数以及-二分法求根)
        - [汉诺塔](#汉诺塔)
        - [随机置换数组](#随机置换数组)
  - [线性表(List)](#线性表list)
    - [定义和特点](#定义和特点)
    - [顺序表](#顺序表)
      - [存储](#存储)
      - [顺序表查找时的平均比较次数](#顺序表查找时的平均比较次数)
      - [顺序表插入时的平均移动次数](#顺序表插入时的平均移动次数)
      - [顺序表删除时的平均移动次数](#顺序表删除时的平均移动次数)
    - [链表（Linked List）](#链表linked-list)
      - [单链表（Singly Linked List）](#单链表singly-linked-list)
      - [二级指针操作链表](#二级指针操作链表)
      - [判断环和相交](#判断环和相交)
      - [顺序表和线性链表的比较](#顺序表和线性链表的比较)
        - [存储方面的比较](#存储方面的比较)
        - [存取方面的比较](#存取方面的比较)
  - [栈(Stack)和队列(Queue)](#栈stack和队列queue)
    - [栈](#栈)
      - [基本](#基本)
      - [栈的混洗(stack shuffl)](#栈的混洗stack-shuffl)
      - [应用](#应用)
        - [判断回文](#判断回文)
        - [排序](#排序)
        - [进制转换()](#进制转换-1)
        - [括号匹配(parenthesis matching)](#括号匹配parenthesis-matching)
        - [表达式的计算](#表达式的计算)
      - [将中缀表达式转换为后缀表达式](#将中缀表达式转换为后缀表达式)
        - [计算后缀表达式](#计算后缀表达式)
    - [队列](#队列)
      - [基本()](#基本-1)
        - [循环队列](#循环队列)
      - [应用()](#应用-1)
  - [矩阵存储，字符串匹配和广义表](#矩阵存储字符串匹配和广义表)
    - [多维数组的存储表示](#多维数组的存储表示)
    - [对称矩阵的压缩存储、](#对称矩阵的压缩存储)
    - [稀疏矩阵的存储](#稀疏矩阵的存储)
      - [三元组表](#三元组表)
      - [链表表示](#链表表示)
    - [KMP](#kmp)
  - [广义表](#广义表)
    - [广义表的链接表示](#广义表的链接表示)
      - [头尾表示](#头尾表示)
      - [拓展线性链表表示](#拓展线性链表表示)
      - [层次链表表示法](#层次链表表示法)
  - [树与二叉树](#树与二叉树)
    - [树的基本概念](#树的基本概念)
      - [树的定义](#树的定义)
      - [树的基本术语](#树的基本术语)
    - [二叉树及其存储表示](#二叉树及其存储表示)
      - [定义](#定义)
      - [特点](#特点)
      - [性质](#性质)
      - [二叉树的存储](#二叉树的存储)
    - [二叉树的遍历](#二叉树的遍历)
      - [定义()](#定义-1)
      - [分类](#分类)
    - [二叉树的重构和计数](#二叉树的重构和计数)
    - [树与森林](#树与森林)
  - [树的应用](#树的应用)
    - [哈夫曼树](#哈夫曼树)
  
# 数据结构与算法

## 绪论

### 基本术语

**数据**分为**数值性数据**和**非数值数据**，其基本单位是**数据元素**，是计算机处理或访问的基本单位；

一个数据元素可以由若干数据项组成，**数据项**又称**属性，字段，域，**分为**初等项**（不可分割）和**组合项**；

**结构**:**数据元素之间的关系**；

**数据结构是由与特定问题相关的某一数据元素的集合(*对象*)(Data)和该集合中数据元素之间的关系(Relationship)组成的**；分为**静态数据结构**和**动态数据结构**，舍弃了实际的物理背景，是通用型的定义；

数据结构={D,R}

**数据对象**:**狭义：具有一定关系的*相同性质*的数据元素的集合**；**广义：由数据抽象和处理数据构成的封装体**

**数据类型**:**一个值的集合和定义在这个值集合上的一组操作的总称**，分为**内置数据类型（亦称基本数据类型或原子类型，可直接使用）**和**构造数据类型（由不同成分的内置数据类型子结构按照一定的规则组成，是用编程语言描述的数据结构的存储映像）**，是**数据结构的实例化**；数据类型**再实例化**得到具体变量，如**类与对象**；

抽象数据类型ADT（Abstract Data Type):

**抽象的本质就是抽取反映问题本质的东西，忽略非本质的细节**；

特性：**使用与实现相分离**，**数据*封装*与*信息*隐蔽**；

在C++，java中用类描述。C中一般不使用ADT，数据和结构是分开的。

数据结构：

一，**分解和抽象**：1，**数据分解划分出数据的层次，再抽象得到数据的*逻辑结构***；2，**处理分解划分成各种功能，再通过抽象得到算法的定义**。这是一个从具体（具体问题）到抽象（数据结构与算法）的过程；进一步**通过对实现细节的进一步考虑得到存储结构和实现运算，从而完成程序设计的任务**，实现从数据结构到具体实现。

二，逻辑结构和存储结构

**数据的逻辑结构根据问题所要实现的功能建立（不考虑具体实现），存储结构根据问题所要的需求（响应速度，处理时间，等）来实现数据的逻辑结构。（数据结构一般指的就是逻辑结构，逻辑结构相同，即使存储结构不同也是相同的逻辑结构）；**

逻辑结构的分类：

**线性结构 ，树形结构 ，图结构， 集合结构。**

**线性结构**：元素之间的关系是**一对一**的，如线性表，向量，栈，队列，优先队列，字典等；

**非线性结构**：每个数据结构可能**与零个或多个其他数据元素发生联系**，分为树结构（一对多）和图结构（多对多）。
如多维数组和广义表等；

**集合结构的实现往往采用其他逻辑结构的存储表示。**

数据结构的存储结构：

存取结构根据存取方法的不同分为三类：

1，**直接存取结构**（向量，多维数组，散列表）；

2，**顺序存取结构**（各种链表，图的邻接表）；

3，**索引存取结构**（线性索引，多叉查找树）；

常用的四种存储结构

1，**顺序存储**：元素之间的逻辑关系由**存储单元的邻接位置关系体现**，由此得到顺序存储结构，借助**一维数组**描述；

2，**链接存储**：元素之间的逻辑关系由**附加的链接指针指示**，由此得到链表存储结构，借助**指针类型**描述；

3，**索引存储**：在存储元素信息的同时还建立**索引表**，其中每一项称为**索引项（包括关键码和地址）**，按针对一个元素还是一组元素分为**稠密索引和稀疏索引**；按是一层还是多层分为线**性索引和多级索引**；

4，**散列存储**：根据元素的关键码**通过一个函数计算得到**元素的存储地址。

前两种在**内存**中，也是基本的**两种物理存储结构**。后两个在**外存**中。/

选择存储结构的要素有<1>*访问频率*，<2>*修改频率*，<3>*安全保密*；

定义在数据结构上的操作：

**1，创建；2，销毁；3，查找；4，插入；5，删除；6，排序**。

好的数据结构：**可以通过某种“线性化”规则被转化为线性结构，通常对应好的算法**；

计算机本质上**只能按照逻辑顺序处理指令和内存单元**，例如图，树的遍历查找需要线性化。

### C语言知识点补充

#### 运算符结合方向和结合性和自增自减(auto-increment,auto-decrement)

大多数运算符结合方向是“自左至右”，即：先左后右，也叫“左结合性”，例如 a－b + c，表达式中有－和+两种运算符，且优先级相同，按先左后右结合方向，先围绕减号结合，执行a－b的运算，再围绕加号结合，完成运算(a－b) + c。除了左结合性外，C 语言有三类运算符的结合方向是从右至左，也叫“右结合性”，即：**单目运算符、条件运算符、以及赋值运算符**。着重强调一点，无论是左结合性，还是右结合性，是针对两个相邻的优先级相同的运行符而言(不是表达中的运算对象)，**运算符是决定左右的基准点，先以前面的运算符(即位置上处于左边的运算符)构造运算，就是左结合，反之，就是右结合。**

条件运算符嵌套时必要时用优先级最高的括号分隔

**函数参数自右向左进栈，要考虑右边参数对左边的影响**。

![a](https://www.pianshen.com/images/476/c2da92eaab6cd2b87d017e12c7d7ca3c.png)

i++ 与 ++i 的主要区别有两个：
1、 i++ 返回原来的值，++i 返回加1后的值。
2、 i++ 不能作为左值，而++i 可以。

i=1;  j=i+++i++;先执行两个i++,返回值分别为1和2；i自增两次，所以j=i=3；

只能用于左值，例如(num+1)--是错误的

#### 数字与字符串转换

```cpp
char*==string.c_str();
 sprintf(s, "%d", x);将%d形式的x以字符串形式放在s里，并自动添加结尾

int->string:

std::to_string(int)

std::to_string(long)

std::to_string(long long)

std::to_string(float)

std::to_string(double)

std::to_string(long double)

还支持各类unsigned，基本上主流数值类型都能无脑转换

string->int:

//#include<cstdlib>

std::stoi

std::stol

std::stoll

//看名字就知道对应为int,long,long long


int stoi (const string&  str, size_t* idx = 0, int base = 10)
 
 int x=stoi(s);

 stoi(string.c_str(),idx,base);

//比atoi安全
//idx是一个指针，该指针指向一个size_t类型的对象
//传入指针地址后，该对象的值会被修改为string中数值后的第一个字符所在位置
//例如stoi("123abcd",&p),返回的p指向a所在


进制是输入数字的进制；
```

#### 二维数组传参

**不常用**。

```cpp

不用区分行列遍历
 void Print(int *p,int n)//或int p[];
{
     for(int i=0;i<n;i++)//存储在一块连续的区域
     printf("%d ",p[i]);
printf("\n");
}

int main()
{
    int s[2][3]={1,2,3,4,5,6};
Print((int*)s,6);//(int*)s==s[0];
return 0;
}
void Print(int **p)
{
    for (int i = 0; i < 2; i++)
    {
        for (int j = 0; j < 3; j++)
            printf("%d ", *(( int* )p+ 2*i + j));//编译器寻址方式，根据二级指针不能自动寻址
    }
    printf("\n");
}

int main()
{
    int s[2][3] = {1, 2, 3, 4, 5, 6};
    Print((int **)s);
    return 0;
}
二维数组名的类型是type (*)[n];是一个数组指针，可强制转换成type**和type*，地址是一样的
 
```

常用

**int s[][n];n不能为空。一维数组也建议用int s[];较直观，便于与其他的指针区分。**

#### 动态内存分配

```cpp
 int **s = (int **)malloc(2 * sizeof(int *));
    for (int i = 0; i < 2; i++)
        s[i] = (int *)malloc(3 * sizeof(int));
        for(int j = 0; j <2;j++)
        {
            for(int k = 0;k<3;k++)
            s[j][k]=1;
        }
for(int j = 0; j <2;j++)//逐层由内向外释放
        free(s[j]);
        free(s);

 int *s[2];
    for (int i = 0; i < 2; i++)
        s[i] = (int *)malloc(3 * sizeof(int));
        for(int j = 0; j <2;j++)
        {
            for(int k = 0;k<3;k++)
            s[j][k]=1;
        }
        for(int j = 0; j <2;j++)//不用也不能释放s，它不是动态分配的
        free(s[j]);
```

```cpp
  void* realloc(void* ptr, unsigned newsize);  
  //对malloc申请的内存进行大小的调整.
        void* calloc(size_t numElements, size_t sizeOfElement); 
        //初始化分配的内存,设置为0
        void *memset(void *s, int ch, size_t n);
        //将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。
```

calloc相当于malloc加memset;

**函数需要返回字符串时不能返回局部变量，只能返回形参中的字符串或用动态分配的空间，一般用*calloc*(不用担心结尾是否为0)**

#### A&&B和A||B的短路规则(short-circuited)

如果A为假，则A&&B短路，如果A为真，则A||B短路，不再判断B。

应用：对于A||B如果A真时B可能溢出则A必须在前；

避免短路时可用按位操作，注意只能是bool之间比较

#### 查看函数中数组的值

1，\*(type(\*)\[len\])arrname;强制转换为数组指针（它的最本质类型），再取值。

2,*(arrname)@len;用这个简单。

#### 删除元素和求特定元素

```cpp
void delchar( char *str, char c )//删除单个位置的元素时用顺移较为简单
{
   int i=0,j=0;//
    while(str[i])//用j的话需要在结尾加\0
    {
        if(str[j]!=c)
        str[i++]=str[j];
        j++;
    }
}
while (i<L.num)//线性表删除特定元素
    {
        if (L.data[i] != x)
        {
            L.data[j++] = L.data[i];
        }
        i++;
    }
    L.num =j;
}
 for (i = 1; i < L.num; i++)//无序线性表删除重复元素，有序的与有序区的结尾元素进行比较即可
    {
        for (j = 0; j <= k; j++)//k:border of non-repreting region
        {
            if (L.data[i] == L.data[j])
                break;
        }
        if (j > k)
            L.data[++k] = L.data[i];
    }
    L.num = k + 1; 

while(i<A.num&&j<B.num)//求有序表共有元素
{
    if(A.data[i]<B.data[j])
    i++;//跳过小的元素
    else if(A.data[i]>B.data[j])
    j++;
    else same=A.data[i];
}
```

#### 进制转换

```cpp
void ten2two(int n)
{
if(n>0)
{
ten2two(n/2);
printf("%d",n%2);   //递归为逆序输出，故先写调用函数，后写printf
}
else
return;
```

```cpp
int convert(int n)
{
    if(n==0||n==1)
        return n;
    else
        return n%10+2*convert(n/10);
}
```

将2到36进制数转换为10进制

```cpp

int Atoi(string s,int radix)    //s是给定的radix进制字符串
{
    int ans=0;
    for(int i=0;i<s.size();i++)
    {
        char t=s[i];
        if(t>='0'&&t<='9') ans=ans*radix+t-'0';
        else ans=ans*radix+t-'a'+10;
    }
    return ans;
}
//利用库函数
 string s = "bacppp";
    char *stop;
    cout << strtol(s.c_str(), &stop, 16) <<endl<<stop<< endl;//stop是非法部分,注意引用符号
//返回值类型是long
2988
ppp

//利用栈
void SysConvert( string s, int init, int k)
{
    char *t;
    long num = strtol(s.c_str(), &t, init);
    SeqStack(S);
    InitStack(S,int(log(num)/log(k))+1);
     while(num)
     {
         Push(S,num%k);
         num/=k;
     }
     PrintStack(S);
}
```

#### log和exp

```cpp
#include<stdio.h>
#include<math.h>
int main(){ 
    printf("%f\n",log(10)); //以e为底的对数函数 
    printf("%f\n",log10(100)); //以10为底的对数函数 
    printf("%f\n",log(8)/log(2)); //计算log_2^8,运用换底公式 
    printf("%f\n",exp(1)); //计算自然常数e
    return 0;
}
```

#### 选择排序法小简化

```cpp

 for(int j=0,index;j<i-1;j++)
    {
        index=j;
        for(int k=j+1;k<i-1;k++)
        {
            if(strlen(s[k])<strlen(s[index]))
                index=k;
        }
        printf("%s ",s[index]);//如果只是要输出将最小的依次输出然后把最小值替换即可，不用交换
        strcpy(s[index],s[j]);
    }
```

#### 浅拷贝和深拷贝

结构体是一种类，拷贝概念上可近似看待

浅拷贝：**拷贝过程中是按字节复制的**，对于指针型成员变量只复制指针本身，而**不复制指针所指向的目标**。
**值传递能保证值不变，但不能保证值上的值不变**。函数传参时**默认拷贝函数就是浅拷贝。**
手动实现可以**直接等**或者用memcpy

**memcpy(&CpA,&A,sizeof(struct SeqList));**

另一个mem函数：void \*memset(void *str, char c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。
memset(str,'$',7);

深拷贝：自定义拷贝函数，以实现完全复制

```cpp
void DeepCopy(SeqList &CpTemp, SeqList A)
{
    CpTemp.num = A.num;
    CpTemp.data = new DataType[Length];
    for (int i = 0; i < A.num; i++)
    {
        CpTemp.data[i] = A.data[i];
    }
}
```

```cpp
struct stu
{
    int i;
    char c;
    char* p;
    stu& operator=( const stu& stuTmp)//显式定义拷贝构造函数
    {
        i = stuTmp.i;//i==this->i;两侧能区分时可以省略
        c = stuTmp.c;
        p = new char(strlen(stuTmp.p) + 1);
        strcpy(p, stuTmp.p);
        return *this;返回拷贝的结构体
    };
};

 s2 = s1;当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符
 相当于s2.operator(s1);
```

operator=() 的返回值类型为引用，这样不但能够**避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的**

#### 获取随机数

从X到Y，有Y－X＋1个数，所以要产生从X到Y的数，只需要这样写：
*k=rand()%(Y-X+1)+X;*

每次获取前运行*srand(time(NULL))*；改变随机数计算函数初值，在time.h下。

一字节（byte）等于八位（bit）；

整数取值范围：$\overbrace{100000....000}^{31}=-2^{31}$ 补码是源码**除符号位**外取反加一，逆推原码也是这样或者减一取反。$\overbrace{01111111111111111}^{32} =2^31-1$，具体值用**pow表达式或者用确切值**。

#### 快排函数（quick sort）

```cpp
C:stdlib.h

void qsort(
   void *base,
   size_t number,
   size_t width,//Element size in bytes.
   int (__cdecl *compare )(const void *, const void *)//qsort calls the compare routine one or more times during the sort, and passes pointers to two array elements on each call. If compare indicates two elements are the same, their order in the resulting sorted array is unspecified.
);
```

**切记比较函数的参数类型是*const void \****

| Compare function return value | Description               |
| ----------------------------- | ------------------------- |
| < 0                           | elem1 less than elem2     |
| 0                             | elem1 equivalent to elem2 |
| > 0                           | elem1 greater than elem2  |

**小于时返回0也行,即要升序时用return elem1>elem2;**
The array is sorted in increasing order, as defined by the comparison function. To sort an array in decreasing order, reverse the sense of "greater than" and "less than" in the comparison function.

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>//极限：里面有INT_MIN,INT_MAX;
/*#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1),是一个符号而不是实际存在的数
INT_MAX + 1 = INT_MIN
INT_MIN - 1 = INT_MAX
abs(INT_MIN) = INT_MIN<0
*/
//快排整形
int compare_ints(const void* a, const void* b)
{
    int arg1 = *(const int*)a;
    int arg2 = *(const int*)b;
 
    if (arg1 < arg2) return -1;
    if (arg1 > arg2) return 1;
    return 0;
 
    // return (arg1 > arg2) - (arg1 < arg2); // possible shortcut,注意这种写法
    // return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)必须在整形范围内
}
 
int main(void)
{
    int ints[] = { -2, 99, 0 ,-743, 2, INT_MIN, 4 };
    int size = sizeof ints / sizeof *ints;//*ints=ints[0];注意学习
    qsort(ints, size, sizeof(int), compare_ints);
    for (int i = 0; i < size; i++) {
        printf("%d ", ints[i]);
    }
 
    printf("\n");
}

//快排字符串
// crt_qsort.c
// arguments: every good boy deserves favor

/* This program reads the command-line
* parameters and uses qsort to sort them. It
* then displays the sorted arguments.
*/

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int compare( const void *arg1, const void *arg2 );\\把程序本身的名字赋值给argv[0]，接着，把后面的第一个字符串赋给argv[1]
int main( int argc, char **argv )
{
   int i;
   /* Eliminate argv[0] from sort: */
   argv++;//注意学习
   argc--;

   /* Sort remaining args using Quicksort algorithm: */
   qsort( (void *)argv, (size_t)argc, sizeof( char * ), compare );//被排元素是字符串指针
//前两个类型转换可以省略
   /* Output sorted list: */
   for( i = 0; i < argc; ++i )
      printf( " %s", argv[i] );
   printf( "\n" );
}

int compare( const void *arg1, const void *arg2 )
{
   /* Compare all of both strings: */
   return _stricmp( * ( char** ) arg1, * ( char** ) arg2 );//*（**）将一般指针转化为字符串指针
   //stricmp相当于_stricmp的alias，是不区分大小写的strcmp，windows独有，linux下用strcasecmp替代
}
```

cpp:algorithm

```cpp
void sort( RandomIt first, RandomIt last );

sort(a,a+10);//

void sort( RandomIt first, RandomIt last, Compare comp );

sort(a,a+10,compare);
sort(a,a+10,less<int>());
sort(a,a+10,greater<int>());
bool compare(int a,int b)

{
 return a>b;//降序
}
std::array<int, 10> ints = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3};
sort(ints.begin(), ints.end(), compare_ints);
 for (int i = 0; i < ints.size(); i++)
    {
        printf("%d ", ints[i]);
    }



comp:For all a, comp(a,a)==false
If comp(a,b)==true then comp(b,a)==false
if comp(a,b)==true and comp(b,c)==true then comp(a,c)==true

```

c的comp参数为（常无类型）指针，返回值为int（不支持bool），c++的comp参数为元素本身，返回值为bool。
c return a>b是升序，c++的是降序；

**快排的时间复杂度为O(nlogn);

### 算法和算法设计

**算法：一个有穷的指令集。**

#### 算法的特性

1，有输入：可以通过输入语句**由外部显式提供**，也可以**由赋值或定值语句隐式提供**，即 **“0个输入“** 情况；
2，有输出；
3，确定性：每一步都确切，无歧义的定义，**对于一组确定的输入对应一条确定的路径运算**，如果会因系统状态而导致结果不一致，则只要对于每个系统状态有确定的处理手段就不影响确定性，没赋初值导致的结果不同没有对应不同状态的处理，违反确定性。
4，有穷性：**初值导致算法不收敛的与算法本身无关，不违反有穷性**；
5，可行性：每一条运算都足够基本（**可以用基本操作或调用已实现的基本算法**），都能精确执行，但**并不一定都与机器指令有直接关系**，并**能在常数时间内完成**。

基本设计步骤：**理解需求->设计思路->算法框架->程序实现**；

算法与程序的关系：
(1)算法在描述上一般使用半形式化的语言，而程序是用形式化的计算机语言描述的。
(2) 程序是计算机指令的有序集合。
(3)程序并不都满足算法所要求的特征，例如操作系统，是一个在无限循环中执行的程序，因而不是一个算法。
(4)一个算法可以用不同的编程语言编写出不同的程序。
(5)算法是解决问题的步骤；程序是算法的代码实现。
(6)算法要依靠程序来完成功能；程序需要算法作为灵魂。
(7)程序=算法+数据结构。

算法设计基本方法：

1，穷举法（枚举法）：<1>按规则列举，<2>盲目列举，并检查之前的列举是否重复；

2，迭代法（反复法）:iteration：不断用原值得到的新值代替原值，直到得到满意的解 ，新值与原值之间的关系用迭代公式表示，主要用于很难用或无法用解析法求解的计算问题，例如区间折半法求方程的根，也用来遍历表树图等数据结构。

3，递推法：递归的递推求解使用递归法，自顶向下，非递归的递推求解使用迭代法，自底向上；

4，递归法：包括自身的数据对象和调用本身的过程是递归的；递归从问题规模为n的场合开始，通过递归降低问题规模，直到递归出口，再倒推回来得到最初的值；递推是从已知条件出发；一般一个递推算法总可以转化为递归算法；例如二分法求根和求Fibonacci数两种方式的转换。但递归法不仅仅用于递推的实现（还有数据结构如链表，树图等的建立等等）。

递归是算法设计的基本技术，是降低分析设计难度提高程序设计效率的重要手段和工具；迭代具有更高的时空效率。

穷举过程中被穷举对象可能需要其他方法求解，各种方法是配合使用的。

算法度量

算法的评价标准：
1，正确性；
2，健壮性：在不正确输入条件下能自我保护，包括自动检错，报错，与用户对话来纠错；
3，可读性；变量名，函数名要有实际意义，必须加入注释；
4，高效性：主要指算法的时间代价和空间代价；
5，简单性：主要用环路复杂度度量，等于程序中判断语句和子程序调用总数加一，软件工程要求不能超过10；

算法分析的主要方法：**事后*估算*法**（插入*测量时间语句*来估算）和**事前*统计*法**（通过对*问题规模，执行频度，时间，空间复杂度*的进行估算。**主要目的是分析算法的效率以求改进**。**主要方面是时间性能和空间性能**。

#### 测量程序运行时间

clock_t start_time, end_time;给两个变量赋给当时时间，它们的差就是它们之间程序的运行时间

clock_t是长整形。

用clock()(精确到豪秒）或者time(NULL/0)（精确到秒）

用time直接作差即可，用clock的需要使用表达式(double)(end_time-start_time)/CLOCK_PER_SEC(每秒钟clock的增量，linux下为1000000，window下为1000)；

特别的sleep(x)（unisted.h)下会**使linux下的clock暂停**(它返回的是CPU耗费在本程序上的时间。也就是说，途中sleep的话，由于CPU资源被释放，那段时间将不被计算在内。)等待输入时clock也会暂停，**带有sleep的程序运行时间精度要求不高时只能用time；windows不会**；

window下sleep(n)单位是ms，linux下单位是s；linux下还有usleep(n),单位是um。里面乘以1000就等同于window下的sleep。

精确计算运行时间

```cpp
#include <sys/time.h> 
struct timeval  start_time,end_time;
int main()
{
 gettimeofday(&start_time,NULL);
 /*
 代码块
      */ 
gettimeofday(&end_time,NULL); 
printf("%lf",(end_time.tv_sec-start_time.tv_sec)+(double)(end_time.tv_usec-start_time.tv_usec)/CLOCKS_PER_SEC);

    return 0;

}
/*
gettimeofday()会把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中。
一般情况下 ，我们并不需要时区信息，所以第二个参数通常为空。
timeStart.tv_sec 这个就是秒为单位的时间戳。(double)
timeStart.tv_usec 这是当前秒中的毫秒数。(int,需要除以CLOCK_PER_SEC并转为double)；
*/
```

C++利用**chrono库**也可以测量时间,可以使用更适合测量程运行时间的steady_clock()来测量。

```cpp
#include <iostream>
#include <chrono>
struct Timer
{
    std::chrono::time_point<std::chrono::high_resolution_clock> start, end;
    //hign_resolution_clock是steady_clock的进阶版(系统所能提供的最精确),同时steady_clock(表在裁判手里，不能修改)相比于system_clock(表在系统手里，会被各种行为修改)更适合计时
    std::chrono::duration<float> duration;
    Timer()
    {
        start = std::chrono::high_resolution_clock::now();//nm clock
    }
    ~Timer()
    {
        end = std::chrono::high_resolution_clock::now();
        duration = end - start;
        std::cout << "Timer took" << duration.count() * 1000<< "ms" << std::endl;
        //float型的duration是mircoseconds类型,乘1000是毫秒
    }
};
//在函数前面定义一个Timer对象即可计时
//手动计时
#include<thread>
#include <chrono>
#include<iostream>
using namespace std::chrono;
using namespace std::literals::chrono_literals;//为sleep部分提供命名空间
auto begin =high_resolution_clock::now();
 this_thread::sleep_for(1s);
auto end = high_resolution_clock::now();
auto duration = end - begin;//auto推断得到的是 nanoseconds
 double ms=(double)duration.count()/CLOCKS_PER_SEC;
    //auto deration =duration_cast<milliseconds>(end-begin);//强制转换为ms，精度不如上面的方式
    cout << duration.count() <<"ms"<< endl;
    cout<<ms<<"ms"<<endl;
 ```


算法的计算量的大小称为算法的*复杂性*。

#### 算法的复杂度(complexity)，度量和问题规模

问题规模从问题的描述中找到：例如在n个学生中查找和求解n阶线性方程组的问题规模都是n；

时间复杂度T(n)：当问题的规模从1增加到n时，解决问题的算法所耗费的时间也由1增加到T(n);

空间复杂度S(n):空间由1到S(n)；

两种度量都是问题规模n的函数，单位都是1，即单位时间(ont time unit)和单位空间都是1(ont space unit)；

时间复杂度度量的计算

算法的执行频度=每条语句的执行次数（频度）x该语句执行时间（每一条基本语句执行时间视为单位时间1，语句执行时间等于语句中基本运算语句数）=算法中所有**运算语句**执行频度的总和；

for循环控制语句的执行次数为n+1,；单位执行时间（一次执行所需语句数）为2（不包括内部），执行频度（总次数）为2(n+1)(共执行n+1次表达式2，1次表达式1，n次表达式3），循环体执行次数是n；

运算赋值语句是**一个**基本运算语句（**加减乘除，转移，存取以及他们的复合**），如a=b+c，return b+c，执行频度都是1；定义语句不是运算语句；

递归算法的执行频度可通过写出T(n)的递推形式来计算；例如T(n)=2,n<=0（if判断和return）;T(n)=2+T(n-1);n>0;（比上次多两次执行（if和return加和，**调用函数以及return的执行次数和加和合并了，还是1**）；

空间复杂度度量指算法所需附加存储空间，包括固定部分和可变部分（与问题规模有关）；

阶乘的非递归实现中，只用了一个整数存放连乘结果，附加空间数为1，空间复杂度也为1；

递归的空间复杂度=每次递归所要的辅助空间x递归深度；

阶乘的递归i实现中每一层递归都需要三个栈空间来存放形式参数，返回值以及返回地址（一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点）

递归深度是n，所以所需的栈空间是3n，空间复杂度为3n；

动态分配所涉及的空间复杂度 等于malloc的空间减去free的空间；

#### 渐进的时间复杂度

执行频度不能确切地反映运行时间，所以用其来比较两个程序结果不一定有价值，所以只需给出算法执行频度的数量级即可达到分析的目的。

大*O*表示：当且仅当存在正整数c和n_0,使得T(n)<=cxf(n)对所有的n>=n_0成立，则称该算法的时间增长率在*O*(f(n))中，记为T(n)=*O*(f(n)).

算法时间复杂度T(n)增长的上限为f(n);*Never to underestimate the runing time of the program.*

O  函数的渐近上界 upper bound
Ω 函数的渐近下界 lower dound
Θ  函数的准确界

Θ(f(n))=T(n):存在正常数c1,c2和n0，使对所有的n⩾n0，有0⩽c1f(n)⩽T(n)⩽c2f(n) f(n)=2n^2+n,T(n)=n^2;(同阶)同速

O(f(n))=T(n): 存在正常数c和n0，使对所有n⩾n0，有0⩽T(n)⩽cf(n) f(n)=n^2;T(n)=2n^2+n; f(n)_rate>=T(n)_rate

Ω(f(n))=T(n): 存在正常数c和n0，使对所有n ⩾ n0，有0⩽cf(n)⩽T(n) f(n)=n^2,T(n)=2n^2+n;f(n)_rate<=T(n)_rate

o(f(n))=T(n): 对任意正常数c，存在常数n0>0，使对所有的n⩾n0，有0⩽T(n)⩽cf(n) T(n)=O(f(n))&&T(n)!=Ω(f(n));f(n)=2n^2+n;T(n)=2n;

f(n)_rate>T(n)_rate

lim(T(n)/f(n))=*lim(T'(n)/f'(n))*(n->inf):1,==c:Θ(f(n))=T(n);2,->inf:o(T(n))=f(n);3,==0;o(f(n))=T(n);

Thus T(n)=n^2=O(n^2)=O(n^3),the first option is the best answer.

一般情况下O就是指Θ，前者范围更广所以一般用前者表示。

If T(N)is a polynomial(/ˌpɑːliˈnoʊmiəl/ 多项式) of degree k(equal to k-order),then T(N)= Θ(N^k);

**Lower-order terms** can generally be ignored,and the **constants** can be throw away.

If T1(n) = O(F(N)) and T2(N) = O(g(N)),then
(a),T1(N)+T2(N) = max{O(f(N)),O(g(N))}
(b),T1(N)\*T2(N) = O(f(N)\*g(N)).

When n is sufficiently large, the growth of various functions has the following relationship:

c <      log2n < (log2n)^k<n < nlog n < n^2 <    n^3 < 2^n < 3^n <   n!  <n^n

Constant logarithmic      Linear     Quadratic   Cubic  Exponential  factorial
/ˌekspəˈnenʃl/
The logarithms grow very slowly.

$$
\log_{k_1} n<n^{k_2}<{k_3}^n(k_1,k_2>0,k_3>1)
$$

the rate of **logarithm slower than power slower than exponient,there is no power function between n and nlogn.**

such as :

$$
N^{1+\frac{\varepsilon}{\sqrt{\log n}}}<N\log N
$$

**O(log2n)可以简记为O(logn);由换底公式知不同底数的对数阶只差了常数倍，n(log2n)也满足**.

**for loop statement**:The total running time of a statement（语句） inside a group of nested loops(嵌套循环) is the running time of statement multiplied by the product（乘积） of the size of all the for loops;

**if/else statement**:time of *test* plus the *lager* of the running time of S1 and S2.

函数或语句嵌套的相乘，并列的取最大。

计算递归的时间复杂度时，简单的可以直接当作for循环来看，复杂的通过递推式计算，结束递归那一步的执行频度如果是c可以简化为1，递推式中的常数必须严格按其执行频度来，例如裴波那契数列递归式是T(n)=T(n-1)+T(n-2)+2(if和return那一句)，n=1,2时看作1还是2无所谓。

#### markdown 语法

[markdown数学公式](https://www.cnblogs.com/wuxero/p/14171220.html)

[在线生成](https://latex.codecogs.com/eqneditor/editor.php)

```cpp
图片:超链接的格式前加!
一个行内，两个行外；_下标，^上标 逻辑上的括号:{}
分数：\frac{}{}
方程组：\begin{cases} \\ \\ \\ \end{cases}
求和:\sum_{i=0}^k;
连乘:\prod_{i=0}^n
换行\\,空格\;
箭头\rightarrow
自适应括号\left( \right)
\sqrt{}
大于等于：\geq;

小于等于：\leq; 
不等于：\neq;
$\lfloor x \rfloor$向下取整；
$\lceil x \rceil$向上取整

行内:一个\$,或**ctrlM**行外两个\$,

有两种省略号，\ldots 表示语文本底线对其的省略号，\cdots表示与文本中线对其的省略号。

```

$$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$$

注意竖线与内容间的空格和标题与内容的分割线,不需要用\$包围
| 名称               | 缩写       |
| ------------------ | ---------- |
| JavaScript         | js         |
| Python             | py         |
| C++                | cpp        |
| “：”：决定对齐方式 |            |
| 题号               | 标题       |
| :---               | ---:       |
| 1                  | 两数之和   |
| 15                 | 三数之和   |
| 262                | 行程和用户 |

#### 时间复杂度例题

##### 循环嵌套

```cpp
{
int  i,j,k,x=0,y=0;
for(int i=1;i<=n;i++)
for(int j=1;j<=i;j++)
for(int k=1;k<=j;k++)
x=x+y;
}
```

$$
T(n) = \sum_{i=1}^n \sum_{j=1}^i  \sum_{k=1}^j = \sum_{i=1}^n \sum_{j=1}^i j = \sum_{i=1}^n \frac{i(i+1)}{2} =\\ \frac{1}{2}\times\frac{n(n+1)(2n+1)}{6}+\frac{1}{2}\times\frac{n(n+1)}{2} = \frac{n(n+1)(n+2)}{6}\\
\sum_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}\\ \sum_{i=1}^n i^3=\left(\sum_{i=1}^n i\right)^2;\\
\sum_{i=0}^n f(n-i)=\sum_{i=0}^n f(i)
$$

```cpp
{
    int func(int n)
    {
    int i=1,s=1;
    while(s<n)
    s+=++i;
    return i
    }
}
第一轮 ：s=1+2;第二轮：s=1+2+3；第n轮：s=1+2+3+...+i;
```

跳出循环时，函数执行次数i满足$\frac{n(n- 1)}{2}\geq n$;即 $i^2-i-2n\geq0$,解得$i\geq\frac{1\pm\sqrt{1+8n}}{2}$.故时间复杂度为$O(\sqrt{n}$);

Find the maximum of subsequence(substring) sum in A[n]:{A0,A1,...An};

$$
\sum_{k=i}^jA_k
$$

```cpp
Algorithm 1 
int MaxSubsequenceSum(const int A[],int N)
{
    int ThisSum,Maxsum,i,j,k;
    Maxsum=0;
    for(i=0;i<N;i++)
    for(j=i;j<N;j++)
    {
        ThisSum=0;
        for(k=i;k<=j;k++)
        ThisSum+=A[k];
        if(ThisSum>Maxsum)
        Maxsum=ThisSum;
    }
    return Maxsum;
}
```

$$
\sum_{i=0}^N \sum_{j=i}^N \sum_{k=i}^j = \frac{N^3+3N^2+2N}{6}
$$

evaluated inside out（由内到外计算）

求内层变量和时外层的变量当常量对待。

**时间复杂度为O(n^3);不需要精确计算时可以通过三层循环的次数都小于等于n得到结果；**

```cpp
Algorithm2:
int MaxSubsequenceSum(const int A[],int N)
{
    int ThisSum,Maxsum,i,j,k;
    Maxsum=0;
    for(i=0;i<N;i++)
    {
        ThisSum=0;
    for(j=i;j<N;j++)
    {
       ThisSum+=A[j]；
        if(ThisSum>Maxsum)
        Maxsum=ThisSum;
    }
    }
    return Maxsum;
}
clearly is O(n^2)；
```

##### 递归，分治

```cpp
Algorithm3:

#include <iostream>
int Max3(int a, int b, int c);
int MaxSubSum(const int A[], int Left, int Right);
int main()
{
    int a[5] = {1, 3, -5, 0, -8};
    printf("%d", MaxSubSum(a, 0, 4));
    return 0;
}
int Max3(int a, int b, int c)
{
    if (a > b)
        return a;
    else if (c > b)
        return c;
    else
        return b;
}

int MaxSubSum(const int A[], int Left, int Ri ght)
{
    int MaxLeftSum, MaxRightSum;
    int MaxLeftBorderSum, MaxRightBorderSum;
    int LeftBorderSum, RightBorderSum;
    int Center, i;
    if (Left == Right)//递归返回终点
        if (A[Left] > 0)
            return A[Left];
        else
            return 0;
    Center = (Left + Right) / 2;
    MaxLeftSum = MaxSubSum(A, Left, Center);//递归计算两边的最大子列和，分治思想体现。
    MaxRightSum = MaxSubSum(A, Center + 1, Right);
    MaxLeftBorderSum = 0;
    LeftBorderSum = 0;
    for (i = Center; i >= Left; i--)
    {
        LeftBorderSum += A[i];
        if (LeftBorderSum > MaxLeftBorderSum)
            MaxLeftBorderSum = LeftBorderSum;
    }
    MaxRightBorderSum = 0;
    RightBorderSum = 0;
    for (i = Center + 1; i <= Right; i++)
    {
        RightBorderSum += A[i];
        if (RightBorderSum > MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum;
    }
    return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
               // 最大值在这三个值里产生
}
```

The algorithm uses a "divide-and-conqure"(分治) strategy.The idea is spit the problem into two roughly equal subproblems,which are the solved recursively.

An Algorithm is**O(log(N))**if it takes constant(O(1))time to **cut the problem size by a *fraction***(which is usually 1/2).On the other hand,if constant time is required to merely **reduce the problem by a *constant amount***(such as make the problem smaller by 1),then the algorithm is**O(N)**.

$$
\begin{cases} T(n)=T(n/2)+O(1)\rightarrow T(n)=kO(1)=O(1)\log n=O(\log n)\\ T(n)=2T(n/2)+O(1)\rightarrow T(n)=2^k+kO(1)=n+O(1)\log n=O(n)\\ T(n)=2T(n/2)+O(n)\rightarrow T(n)=2^k+n+\frac{n}{2}\times2+\cdots=2^k+n\times k\\=n+n\log n=O(n\log n)\\ \end{cases}
$$

Simple intuition obviates the need for a brute-force approach.

*接收n个数据至少需要O(N)的复杂度，故O(logN)是针对对应函数而不是程序整体说的。*

**分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。**

　　分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解这种算法设计策略叫做分治法。

　　如果原问题可分割成k个子问题，1<k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

```cpp
Algorithm4
int MaxSubsequenceSum(const int A[],int N)
{
    int ThisSum,Maxsum,j;
    ThisSum=MaxSum=0;Maxsum=0;
    for(j=0;j<N;j++){
        ThisSum+=A[j];
        if(ThisSum>MaxSum)//ThisSum大于零时更新（段内回撤不大不影响本金，长期持有）
        MaxSum= ThisSum;
        else if(ThisSum<0)//小于零后对后面部分的增长没有作用(回撤过大，割肉跑路），断开重新计算下一段的最大和
        ThisSum=0;
    }
    return Maxsum;
}

```

##### Binary Search(二分查找)

```cpp
//A[N] has presorted（一次排序，永远方便，需要多次查找的都可以这样搞）
int BinarySearch(Const ElementType A[],ElementType X,int N)
{
    int Low,Mid,High;
    Low=0;High=N-1;
    while(Low<=High)
    {
        Mid=(Low+High)/ 2;
        if(X>A[Mid])
        Low=Mid+1;
        else
        if(X<A[Mid])
        High=Mid-1;
        else
        return Mid;//Found
    }
    return NotFound//is defined as -1;
}
每次循环使问题的规模减小一倍，故时间复杂度是O(logn);
```

##### 最大公约数和最小公倍数以及 二分法求根

```cpp
int GCD(int a , int b )//辗转相除法(Greatest Common Divisor)
{
    int temp;
    if(!(a%b))
    { return b;break;}
    else
        return GCD(b,a%b);//除数除余数
}
//都不用判断a，b大小，如果a<b,第一次递归或迭代会交换他们。
迭代写法（推荐）：
int GCD(int M, int N) //(Euclid's algorithm)
{
    int Rem;
    while(N>0)
    {
        Rem=M%N;
        M=N;
        N=Rem;
    }
    return M;
}

```

**if M>N,then M mod N < M/2;(If N<=M/2,then remainder is smaller than N;if N>M/2,then remainder is M-Nalso smaller than M/2);**

考虑(a,b)$\rightarrow$(b,a mod b)这个迭代，有两种情况：
1，如果a>b,那么迭代两次后得到(a mod b,b mod (a mod b)),
有a mod b < $\frac{a}{2}$, b mod (a mod b) < $\frac{b}{2}$,
即迭代两次后问题的规模减小一倍；
2，如果a>b,迭代一次后归入情况a，至多出现一次，可以忽略。
故其时间复杂度为 $2\log n=O(\log n)$;

```cpp

}
int gcd(int m,int n)更相减损术
{
    if(m>n)
    return gcd(m-n,n);
    else if(n>m)
    return gcd(m,n-m);//大数减小数
    else 
    return m;
}
```

设gcd(a,b)=c,lcm(a,b)=d，即ab的最大公因数为c，最小公倍数为d，则一定有a=k1\*c ， b=k2\*c （1）      a=d/t1       b=d/t2   （2）,其中k1,k2必然互质（反证法：假设k1，k2不互质，则必定有一个大于1的最大公因数，设其为x，则有a=k1/x \* xc, b=k2/x \* xc,此时k1/x和k2/x已经互质，但是明显a和b有一个公因数xc,又因为x>1，则xc>c，和前提ab的最大公因数c矛盾，则k1,k2必然互质，同理可证t1,t2互质）

对于（1）式，可有b/a=k2/k1.对于（2）式，可有b/a=t1/t2,即k2/k1=t1/t2,定有常数y,使得k2=y\*t1,k1=y\*t2,即k2/k1=y\*t1/y\*t2=t1/t2,

而k2和k1是互质的，y只能为1，所以k2=t1,k1=t2,而k1=a/c,t2=d/b,所以a/c=d/b,即ab=cd，证毕

```cpp
double f(double x)
{
    return a3*(x)*(x)*(x)+a2*(x)*(x)+a1*(x)+a0;
}
double isroot(double a,double  b)
{
    if(fabs(f((a+b)/2))<1e-6)//也可用区间长度作为控制精度结束条件
        return (a+b)/2;
    if(f((a+b)/2)*f(a)<0)
        return isroot(a,(a+b)/2);
    else
        return isroot((a+b)/2,b);

```

```cpp
//Exponentiation:
long int Pow(long int x,int N)
{
    if(N==0)
    return 1;
    if(N==1)//unneceaaary
    return 1;
    if(IsEven(N))
    retuen Pow(x*x,N/2);
    else
    retuen Pow(x*x,N/2)*x;
}
O(log N)


```

##### 汉诺塔

```cpp
void hanoi(int n, char A, char B, char C)//盘子数量，初始轴，中间轴，目标轴；
{
    if (n == 1)//!最频繁的操作，是两个递归调用的终止条件
    {
        move(1,A, C);
        return;//或else
    }
    hanoi(n - 1, A, C, B);//将A上面n-1个移动到B
    move(n,A, C);//将A上最后一个最大的移动到C，也是移动每个子递归上最大的；
    hanoi(n - 1, B, A, C);//将中间轴B上的移动到C
}
void move(int n,char A, char C)
{
    cout << m++<<':'<<n<<"from" << A << " to" << C << endl;
}
```

![a](https://pic2.zhimg.com/80/v2-0f0904276be548357ae841fe137230d1_1440w.jpg)
先从左边三号节点进入，到最左边的一号节点开始逐层退出递归，全部退出后执行节点4，然后从右边三号节点进入到其左下角的一号节点开始逐层退出递归。

$$
T(n)=2T(n-1)+k\rightarrow T(n)=2^n
$$

##### 随机置换数组

```cpp
Algorithm1:
int A[MAXN] = {0},i,j,temp;
    for (i = 0; i < MAXN; )
    {
        srand(time(NULL));
        temp = rand() % 10 + 1;
        for (j = 0; j < i; j++)
        {
            if (temp == A[j])
                break;
        }
        if(j==i)
        A[i++]=temp;
    }

```

The expected number of random numbers that need to be tried is N/(N-i), This is obtained as follows: i of the N numbers would be duplicates.Thus the probability of success is N-i/N(if成功的概率); Thus the expected number of independent trials  is N/N-i（if 成功一次所需的次数）;在x次独立重复事件中，该事件发生xp次；所以该事件发生一次的概率是1/p（两边同除以xp)
The time bound is thus:

$$
\sum_{i=0}^{i-1} \frac{Ni}{N-i} < \sum_{i=0}^{N-1} \frac{N^2}{N-i}=N^2\sum_{i=0}^{N-1} \frac{1}{N-i}=\sum_{j=1}^N \frac{1}{j}=N^2\log N
$$

The time bound is thus

```cpp
Algorithm2:

int A[MAXN] = {0},Used[MAXN]={0},i,j,temp;
    for (i = 0; i < MAXN; )
    {
        srand(time(NULL));
       temp=rand()%MAXN+1;
       if(!Used[temp-1])
       {
           A[i++]=temp;Used[temp-1]=1;
       }
  
    }
```

Obviously time complexity is O(nlogn);

```cpp
Algorithm3:
for (i = 0; i < MAXN; i++)
    {
        A[i] = i + 1;
    }
    for (i = 0; i < MAXN; i++)
    {
        srand(time(NULL));
        swap(A[i], A[rand() % (i+1)]);
    }

```

The worst-case running time of algorithms I and II **cannot be bounded**because there is always a **finite probability** that the program **will not terminate by some given time TO**. The algorithm does, however, terminate with probability 1. **The worst-case running time of the third algorithm is linear** - its running time does not depend on the sequence of random numbers.

## 线性表(List)

### 定义和特点

L       =     (a1, a2, a3,...,an).
表名           首元(head)      尾元(tail)  ai：结点（数据元素） 没有元素时是空表。

要点：

1，表中元素具有逻辑上的顺序性；

2，表中元素个数有限；

3，表中元素都是数据元素（**不可分**）；

4，元素的数据类型都相同（**等价类型变量（union）也可以**）；

5，表中元素具有抽象性。

### 顺序表

**线性表的顺序存储**.

[源代码位置](/home/fengsc/Desktop/cpp/DataStructure/SeqList)

#### 存储

**动态存储结构就是在程序运行期间动态的分配内存。一维数组既可以动态存储也可以静态存储**.

```cpp

#define maxSize 30//静态存储
typedef int DataType;
typedef struct
{
    DataType data[maxSize];
    int n;
}  Seqlist;
```

```cpp
#define maxSize 30//动态存储
typedef int DataType;
typedef struct
{
    DataType *data;
    int n;
}  Seqlist;
void initList(Seqlist &L)
{
L.Data=(DataType*)malloc(sizeof(DataType));
if(!L.Data)malloc(sizeof(DataType));
exit(1);
L.Maxsize=InitSize;
L.n=0;
}
```

#### 顺序表查找时的平均比较次数

$$
ACN=\sum_{i=1}^n p_i\times c_i=\sum_{i=1}^n \left( \frac{1}{n} \right) \times i=\frac{1}{n}\sum_{i=1}^n i=\frac{1}{n}\times\frac{(1+n)n}{2}=\frac{1+n}{2}
$$

$p_i:\frac{1}{n}$：查找对象为某个元素的平均概率;$c_i: i$：顺序查找某个元素所要比较的次数

最小是1，最多是n；

#### 顺序表插入时的平均移动次数

$$
AMN=\frac{1}{n+1}\sum_{i=1}^{n+1} \left( n-i+1 \right) =\frac{1}{n+1}\times \frac{n(n+1)}{2}= \frac{n}{2}
$$

移动第ℹ-1到第n-1位置间共n-i+1个元素，最少移动0次，在第n+1个位置插入；最多移动n次，在第一个位置插入。

不要求顺序时可以直接插在后面。

#### 顺序表删除时的平均移动次数

$$
AMN=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{1}{n}\times \frac{n(n-1)}{2}= \frac{n-1}{2}
$$

把第i到第n-1共n-i个元素顺序前移，最少移动0个，最多移动n-1个。

不要求顺序时可以直接将最后一个元素覆盖要删除的元素。

**各种操作的时间复杂度都是O（N），大小都是二分之最小加最大**.

顺序表的缺陷：在插入和删除时需要频繁的执行成块的数据移动，所以主要用于不经常插入或删除的应用程序，它具有**直接存取**的特性。

---

### 链表（Linked List）

[相关程序源文件位置](/home/fengsc/Desktop/cpp/DataStructure/LinkedList)

#### 单链表（Singly Linked List）

**也叫线性链表或单链表，是线性表的链接存储表示**.

结构：为元素附加指针形成一个个结点（*node*），通过指针将各个数据元素按其逻辑顺序勾连起来，结点包括数据域（*data*）和指针域（链域）（*link*）；第一个结点称为首元结点(表头指针指向），没有前置结点(predeceor).可以通过头指针(*Header/Dummyhead*)（有利于插入删除首元节点）找到，最后一个结点称为尾元结点（表尾指针指向），没有后继结点(*successor*);

**一般用带头结点的，递归函数一般用不带头结点的，不带头结点更为简洁和通用**.

添加头结点：*header = new ListNode(head);注意利用结构体里的构造函数。

**链表非引用传入的指针只能改变它们之后的结点，如果不用返回值，而其本身结点需要改变，可以解引用赋值浅拷贝，也可以用成员运算符深拷贝，一般用前者即可。**

```cpp

void RemoveByValWithoutReferAndHeader(LinkList Head, DataType x) //形参和实参唯一的区别是地址不同，它们连接着同一条链表，都可以改变首元结点
{
    LinkList *pcur = &Head, p, phead = Head;//保留原首元节点指针
    while (p = *pcur)
    {
        if (p->data == x)
        {
            *pcur = p->next;
            free(p);
        }
        else
            pcur = &p->next;
    }
    *phead = *Head;//更新首元结点
    /*phead->next=head->next;
    phead->data=head->data;*/
}
```

```cpp
typedef struct Node{
    DataType data;
    struct Node *Next;
     Node(int val) :data(val),next(nullptr) {}
     Node(Node *ptr):next(ptr){}
    Node():data(0),next(nullptr) {}

    Node(int val,node* ptr):data(val),next(nullptr){}
}LinkNode,*LinkList;
p=(LinkList)malloc(sizeof(LinkNode))=new LinkNode=new LinkNode()=new LinkNode(0)=new LinkNode(0,nullptr)=new Node(**);//可以用别名也可以用结构体名,类也一样

```

#### 二级指针操作链表

```cpp
 LinkList *cur = &Head, p;//注意取地址符和引用的区别
    while (p = *cur)
    {
        if (p->data == x)
        {
            *cur = p->next;/*通过当前结点的指针（pred->next）的地址直接改变当前结点指针，直接赋值会使结点脱离（操作对象只是个中间变量P），所有需要维护或通过前置结点进行的操作例如插入，删除等都可以这样，也可以同时使操作不再依赖头结点（当然一般情况还是优先加头结点），频繁的插入删除优先采用此方法，注意指针起始地址，从首元结点开始：&head,从头结点开始:&header->next(!=&head)*/
            free(p);
        }
        else
            cur = &p->next;/*cur=&(*cur)->next;'->','.'优先级最高，'&'，'*'其次，取得链表结点指针的地址而不是中间指针变量的地址*/
    }
  {
 LinkList *pcur = &Head;
    cout << "Please enter " << num << "datas" << endl;
    while (num--)
    {
        LinkList cur = new LinkNode;
        if (!cur)
        {
            cout << "Memory allocation failed" << endl;
            exit(1);
        }
        cin >> cur->data;
        *pcur = cur;
        pcur = &cur->next;
    }
    *pcur = nullptr;
  }
  /*注意辨析*pcur=(*pcur)->next(删除结点),pcur=&(*pcur)->next(移动结点，底层，借助指针地址)与cur=cur->next（移动结点，表面，借助中间变量）*/
```

#### [判断环和相交](https://blog.csdn.net/fengxinlinux/article/details/78885764)

$$ 2(a+b)=a+b+kr,a+b=kr;a=kr-b=(k-1)r+r-b \\a：环入口到表头的距离，b:环入口到两指针第一次相遇结点的距离 $$

当慢指针从表头移动a次后快指针也将到达环的起点。

```cpp
LinkNode *detectCycle(LinkNode *head) {
         LinkNode *slow = head, *fast = head;
        while (1)
        {
            if (fast && fast->next && (fast = fast->next->next))
            {
                slow = slow->next;
                if (fast == slow)
                    break;
            }
            else
                return nullptr;
        }
        slow=head;
        while(1)
        {
            if(fast == slow)
            return fast;
            slow= slow->next;
            fast= fast->next;
        }
        
    }
```

```cpp
      ListNode *p = headA, *q = headB;
        int gap = 0, flag = 0;
        while (p || q)
        {
            if (!(p && q))
            {
                flag = p ? 1 : 0;//标记较长串
                gap++;//长度差值
            }
            if (p)
                p = p->next;
            if (q)
                q = q->next;
        }
        flag ? (p = headA, q = headB) : (p = headB, q = headA);
        while (gap--)
            p = p->next;
        while (p != q)
        {
            p = p->next;
            q = q->next;
        }
        return p;

```

```cpp
    fast=slow=head;
    while (fast&& fast->next){//find mid node
        slow = slow->next;
        fast = fast->next->next;
    }
```

#### 顺序表和线性链表的比较

##### 存储方面的比较

（1）存储利用率：

$$存储密度=\frac{数据结构占用的存储字节数}{为结构分配的最大字节数}$$
顺序表的存储密度为1，利用率很高；单链表小于1，数据元素需要附加指针指示元素之间的逻辑关系，利用率较差；

（2）空间限制：

顺序表只有在动态分配内存时可以扩充，但存储开销和时间开销大，效率低；单链表随用随申，一般没有存储溢出的问题，空间限制小；

（3）存储的占用方式：

顺序表的存储空间不随表的操作改变，事先估计不足或过大都会造成问题；链表占用空间随用随变，很灵活。

##### 存取方面的比较

（1）存储结构特点：

顺序表用物理关系上的邻接关系来表示结点间的逻辑关系，结构简单；链表元素的物理存储位置和逻辑链接关系不一定一致；链表**结点间的存储一般是不连续的**，但**链表结点内部的存储空间是连续的**。

（2）访问方式：

顺序表可以从前往后或从后往前或按下标存取，链表只能沿着指针逐个节点存取，顺序表查找比链表快；

（3）插入删除速度：

顺序表平均要移动一半元素，链表只需要修改链接指针，无需移动元素；

**如果表头指针被保护，单链表的安全保密性比顺序表好**.

**顺序表适合频繁查找，不适合频繁插入删除，链表反之。**

**其他链表的逻辑结构也是线性表**.

## 栈(Stack)和队列(Queue)

**栈，队列和双端队列的逻辑结构与线性表相同，但有更多限制(restrictions)，称为运算受限的线性表或限制了存取点的线性表**.

### 栈

[相关文件位置](../DataStructure/Stack/Stack.cpp)

```cpp
class SeqStack
{
    public:
    DataType *elem;
    int maxSize, top;
    SeqStack(int size) : maxSize(size), top(-1), elem(new DataType[size]) {}
    SeqStack(const vector<DataType> &value) //利用vector初始化
    {
        maxSize = value.size();
        top = maxSize - 1;
        elem = new DataType[maxSize];
        for (int i = 0; i < maxSize; i++)
            elem[i] = value[i];
    }
    ~SeqStack() { delete[] elem; }//释放内存
} ;
```

#### 基本

**可定义为只允许在表的末端进行插入和删除操作的线性表(LIFO,Last In First Out)，允许操作的一端叫栈顶(top),另一端叫栈底(bottom),没有元素时叫空栈，主要操作是Pop(出栈)和Push(进栈)**.

栈空时退栈要进行**栈空处理**，栈满时入栈要进行**栈满处理**，它们**不是出错处理**，而是使用这个栈的算法结束时需要执行的处理(It's an implementation error but not an ADT error)

栈的基本性质：(1):集合性；(2):线性；(3):运算受限；(4):数学性质；

栈在生命周期内的状态:栈满，栈空，栈半满；可能的操作：进栈（入栈），出栈（退栈），置空；

合理的S/X序列满足:(1):最终S==X;(2):任意状态S>=X;

顺序栈的优点是**存取速度快，插入，删除方便**；缺点是**容量不好把握，空间利用率底,多栈共享空间时效率低**。

链栈的优点是**插删方便，不存在栈满的问题，同时使用多栈时效率高，便于共享空间**。缺点是**需要额外空间存放指针域**。

单调栈不一定是栈内的元素本身单调，也可能是储存的数组下标对应的元素单调，这样存储的信息更多。注意数组最后**哨兵**的添加。

#### 栈的混洗(stack shuffl)

**通过控制入栈和退栈时机得到不同的退栈序列**.

不可能的退栈序列：例如进栈时按$\cdots p_i\cdots p_j\cdots p_k\cdots$次序，则$\cdots p_k\cdots p_i\cdots p_j\cdots$就是不可能的出栈序列，因为当$p_k$出栈时，$p_i$和$p_j$在其之前入栈，故还按原顺序在栈内，$p_i$先进于$p_j$，不可能先出于它。即在某个出栈元素之前进栈且之后出栈的几个元素，出栈后**在该元素之后的顺序遵循先进后出**。

判断是否为可能的退栈序列更直观的分析方式是根据最后一个出栈的元素将原序列分段，比它(序号)小的元素（如果存在）比他先入栈也先出栈，比它大的元素（如果存在）随后出栈，且这两部分本身也满足这个规律，具体就是将原序列递归拆解为许多n<=3的序列，拆解时大区域和小区域混合或拆解成的序列存在不可能退栈序列则该序列为不可能退栈序列。**n=0,1,2,3,时只有n=3时的312是不可能序列**，例如dbca，没有小区域，只有大区域，但大区域是312型，故为不可能序列，dabc,大小区域混合。

卡特兰数(catalan)推导:对于任意的出栈序列，设最后一个元素序号是k,则比最后一个元素小的有k-1个，比它大的有n-k个，根据前面说明这两部分也是可能出栈序列并相互独立，满足乘法原则，设可能出栈序列数为f(k),则f(k)=f(k-1)*f(n-k)，k属于1到n,不同k的情况满足加法原则，故总的可能序列数是f(n) = f(0)f(n-1) + f(1)f(n-2) + …… + f(n-1)f(0)。$C_{n+1}=\sum_{i=0}^n C_i\times C_{n-i} = \frac{1}{n+1}C_{2n}^n = \frac{1}{n+1}\times \frac{(2n)!}{n!\times n!}=\frac{2n(2n-1)\cdots(n+2)}{n!}$[详细证明](https://en.wikipedia.org/wiki/Catalan_number)

#### 应用

##### 判断回文

(1)全部压栈再边退边和原序列比较;(2):压栈一半再边退栈边和剩余的一半比较；中点容易确认或已确认的用2；

##### 排序

将待排元素放在辅助栈，将目标栈栈顶元素与辅助栈新出栈元素比较，满足大小关系或空栈则入目标栈，否则目标栈退栈到到辅助栈直到满足关系或空栈，辅助栈空时退出。

##### 进制转换()

十进制与k进制数的关系：$N=\sum_{i=0}^{[\log_k^N]}(b_i\times k^i),b_i=0,1,\cdots,k-1$

例如，$49_{10}=1\times 2^5+1\times 2^4+\cdots +1\times 2^0=110001_2$

这样，十进制数N可以用长度为$[\log_k^N]+1$位的k进制数表示为$b_{[\log_k^N]}\cdots b_2b_1b_0$

不断通过取余取商可以将$b_0到b_{[\log_k^N]}$顺序求出来,先全部入栈最后出栈就可以顺序输出。

##### 括号匹配(parenthesis matching)

遇到左括号进栈，遇到右括号出栈（多种括号需比较后出栈），如果中途出栈时栈空（一种括号）或没有与右括号匹配的左括号（多种）或者最终栈不空则匹配失败。

使用计数器只能处理一种括号的情况，([)]的情况将误判。

##### 表达式的计算

[源文件](/home/fengsc/Desktop/cpp/DataStructure/Stack/EvaluateExpression.cpp)

注:用vector\<string\>代替string可实现更大范围的输入；

算数表达式分为：前缀，中缀和后缀表达式；一般输入的表达式是中缀表达式，后缀表达式也叫RPN即逆波兰表达式，不用考虑优先级，程序计算时使用，它们的区别在于运算符的位置，**运算数的相对位置是一样的**。

#### 将中缀表达式转换为后缀表达式

运算符之间的优先级可以用算符优先矩阵或数字表示；

| 操作符op  | $   | (   | !   | ^   | *,/,% | +,- | )             |
| --------- | --- | --- | --- | --- | ----- | --- | ------------- |
| isp(栈内) | 0   | 1   | 9   | 7   | 5     | 3   | 10            |
| icp(栈外) | 0   | 10  | 8   | 6   | 4     | 2   | 1(无实际意义) |

- 左括号在栈外的优先级最高，使它前面的表达式先搁置，进栈后优先级极低，使得后面的表达式进入，遇到进入的右括号优先级极低，使后面的表达式先搁置，直至括号相遇一起出栈，满足括号内优先级最高。

- 表达式进入栈内后优先级增加，满足同级从左到右的优先级。
  
- 开头结尾的标志相遇后栈空结束，标志一般用\0，处理前在栈内加入\0,与字符串结尾的\0配对。前者与第一个读取元素比较，后者用于结束，(便于方便应使用char \*字符串输入，string无结尾0，可将string.c_str()拷贝到char \*P上，注意预先给P分配s.length()+1个空间,然后修改原串，免于返回(注意要引用string))
  
具体算法：

(1),初始化栈，将结束符\0进栈，开始读入表达式串；

(2),重复执行以下步骤直到遇到ch=='\0',与最后的栈顶配对并退栈然后停止循环。

- 如果ch是操作数直接赋给结果串；

- 如果ch是操作符，比较ch与栈顶元素的优先级；
  
  - if icp(ch)>isp(op)，进栈，读下一个字符；

  - if icp(ch)<isp(op),退栈赋给结果串；
  
  - if icp(ch)==isp(op),退栈，没到结尾就读入下一个字符；

##### 计算后缀表达式

顺序扫描表达式，操作数进栈，遇到二元操作符，连续退出两个操作数Y和X，形成运算指令X\<op\>y，一元操作符退出一个，形成指令X\<op\>,并将结果重新入栈，表达式扫描完后，栈顶存放的就是计算结果。

### 队列

[源文件](/home/fengsc/Desktop/cpp/DataStructure/Quene/Queue.h)

```cpp
/*也可以将EnQuene作为类的友元，这时它的声明可以放在后面*/
/*class CircQueue;                        //前向声明，作为EnQuene的形参
bool EnQueue(CircQueue &Q, DataType x); //结构体调用，需在其之前声明；*/
class CircQueue
{
public:
  DataType *elem;
  int maxSize;
  int front, back；
    friend bool EnQueue(CircQueue &Q, DataType x);//类和非成员函数友元不需要提前声明
  CircQueue(int size) : maxSize(size + 1), front(0), back(0), elem(new DataType[size + 1]) {}
  /*注意预留一个位置*/
  CircQueue(vector<DataType> &value)
  {
    maxSize = value.size() + 1; //不能调用另一个构造函数，因为这一个还没构造完
    elem = new DataType[maxSize];
    front = back = 0;
    for (int i = 0; i < value.size(); i++)
      EnQueue(*this, value[i]); //全局函数（已声明或友元）可直接调用，与成员函数同名时前加::
  }
  ~CircQueue()
  {
    delete[] elem;
  }
};
```

#### 基本()

只允许在队头(front)插入，队尾(back)删除，先进先出(FIFO);

##### 循环队列

初始时，rear=back=0,当back==maxSize时队满，但rear可能不是0，形成假溢出，为了充分使用数组的空间，把数组的前端和后端连接起来，形成一个环形的表，即把存储元素的表逻辑上看做一个环，成为循环队列。

队列的头尾指针时同向运动，栈是反向运动；

队头/队尾指针进一:ptr=(ptr+1)%maxSize;

为了使队满条件区别于队空条件，用(back+1)%maxSize==front来判断是否队空，队满时空了一个位置，不空就无法区别，所以设置初始容量时要预留一个位置。

其它实现方式：

(1):元素进队时tag设为1，用back==front&&tag==1判断队满，元素出队时tag设为0，用back==front&&tag==0判断队空；

(2):记录队列长度；

双端队列(double-ended queue),允许在两端插入和删除，输出受限时有三种可能的输出:(1):在同一端输入输出，相当于栈；(2):在一端输入，另一端输出，相当于队列；(3):混合进出；优先队列：取出的不是最先加入的而是优先级最高的(输出时需要遍历数据)。

#### 应用()

逐行输出杨辉三角形;

```cpp

void PrintTriangle(int n)
{
    LinkQueue Q;
    EnQueue(Q, 1);
    EnQueue(Q, 1);
    for (int i = 1, t = 0; i <= n; i++)
    {
        EnQueue(Q, 0); //每一行之间添加0，便于计算最右侧的数
        for (int j = 1; j <= i + 2; j++)
        {
            EnQueue(Q, GetFront(Q) + t); //计算下一行并入列
            t = DeQueue(Q);              //保留以计算下一个下一行的元素
            if (j == 1)//保留行前空格
                cout << setw(n - i + 2) << setiosflags(ios::right)<< setfill(' ') <<t<<' ';
            else if (j != i + 2) //输出本行，除了添加的0
                cout << setw(2) <<setiosflags(ios::left)<< t << ' ';
        }
        cout << endl;
    }
}
```

## 矩阵存储，字符串匹配和广义表

### 多维数组的存储表示

对于数组$a[m_1][m_2]\cdots[m_n]$, $LOC(a[i_1][i_2]\cdots[i_n])=LOC(a[0][0]\cdots[0]])+(i_1\times m_2\times m_3\times \cdots \times m_n+i_2\times m_3\times\cdots \times m_n+\cdots+i_{n-1}\times m_n+i_n)\times l=LOC(a[0][0]\cdots[0])+\left(\sum_{j=1}^{n-1} i_j\times \prod_{k=j+1}^n m_k+i_n\right)\times l$,l为单个元素占据的存储大小。

### 对称矩阵的压缩存储、

上下三角矩阵非零元素个数是:$\frac{n(n+1)}{2}$，三对角矩阵非零元素个数是$3n-2$

行优先存储下三角钜阵的访问地址:$\frac{i(i+1)}{2}+j,i,j\geq 0$

行优先存储上三角矩阵的访问地址:$\frac{i(2n-i-1)}{2}+j$

行优先存储三对角矩阵的访问地址：$2\times i+j$

互换i,j就是列优先。

反解可由压缩数组映射到矩阵；

### 稀疏矩阵的存储

稀疏因子$\delta=\frac{t}{m\times n}$;通常当这个值小于0.05时可以认为是稀疏矩阵。对于nxn的当非零元素数小于$\frac{n^2}/{3}$时是稀疏矩阵，某些场合应小于$\frac{n^2}/{5}$

三角矩阵是稠密矩阵，三对角矩阵当n>8时是稀疏矩阵

以下存储方法都失去了直接存取的特性，只能顺序查找；

#### 三元组表

```cpp
class Triple
{
    int row,column;
    Datatype value;
};
class SpareMatrix
{
    int rows,cols,terms;
    Triple elem[MAXN];
}
//还可以改进，例如添加标识每行首个非零元素位置的数组，这样还可以只使用二元组，不用额外储存行号(数组进一位就标志到新行)，具体实现最方便的就是在输入的时候放在每一行的terms（当前总数）位置上(上一行的下一个位置)，也可以根据已建立的三元组表计算

//计算每行非零元素开始位置
int rowSize[a.rows],rowStart[a.rows];
for(int i=0; i<a.terms; i++)//计算每一行非零元素的数量
rowSize[a.elem[row]]++;
rowStart[0]=0;
for(int i=1;i<a.terms;i++)
rowStart[i]=rowStart[i-1]+rowSize[i-1];//递推式；
```

#### 链表表示

(1)简单链表存储；

(2)行链表组；

(3)正交链表(十字链表)；

头结点和非零元素结点的共有部分是tag,down,right;不同的部分是头结点有next,非零元素结点有col,row和val；总的头结点结构像两种结点的叠加，和元素结点一样的特有部分变成了rows，cols，和size；已知行列数时头结点用数组存储比较方便；

### KMP

P 的 next 数组定义为：next[i] 表示 P[0] ~ P[i-1] 这一个子串，使得 前k个字符恰等于后k个字符 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。

性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。既然如此，如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，前next[r]个字符恰好和后next[r]个字符相等——也就是说，我们可以拿长度为 next[r] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去.

另一种思考:如果某一次匹配后失配字符前配合部分的最长前缀p0...pn-2不等于最长后缀p1...pn-1;则如果从主串的下一个字符开始匹配必定失配,因为这次匹配的开头部分相当于刚才假设的不相等串匹配(相等传递)，（而BF算法不考虑这个，每次失配只进行这一步），继续考虑次长前后缀P0...pn-3,p2...pn-1，此时模式串移动的距离相当于第一次失配后按BF算法的第二次匹配,直到第k次考虑找到最大相同前后缀前面这一段才可能匹配成功，这时模式串后移距离相当于BF算法第一次失配后的第k次匹配，所以可以直接进行BF第k次，并直接从失配字符而非从头继续匹配(移过去之后前面这一段是公共部分,具体距离最大相同前后缀的长度+1)，主串不用动，通过j=next[j]就将模式串调到合适的地方，j向前移实现模式串向后走。

主串影响失配的位置和多少，模式串影响回溯的步数；

next失配函数定义:
$$next(j)=\begin{cases}-1;j=0\\ k+1;0\leq k<j-1且使得p_0p_1\cdots p_k=p_{j-k-1}p_{j-k}\cdots p_{j-1}的最大整数\\ 0,其它情况\\ \end{cases}$$

求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。最大步增为1，最小值为0；

![a](https://pic2.zhimg.com/80/18a9ee17b0eebabab0672687b721aee1_1440w.png "配合")

![a](https://pic3.zhimg.com/80/f37911dc3ace184a393f359f04944e06_1440w.png "失配")

```cpp
void getNext(char * p, int * next)
{
    next[0] = -1;
    int i = 0, j = -1;
while (i < strlen(p))
{
    if (j == -1 || p[i] == p[j])
    {
        j++;
        next[++i] = j;//下一位的next值是包括当前位最长前后缀的长度加1；
}
else
    j = next[j];
}
}

int KMP(char * t, char * p) 
{
    int i = 0; 
    int j = 0;

while (i < strlen(t) && j < strlen(p))
{
        if (j == -1 || t[i] == p[j]) //当p[0]（后面最差情况会转到0）与失配的t[i]匹配不上时j会等于-1，即模式串与t[i+1]对齐，next数组的作用就是利用已经配对过的部分控制模式串的偏移量
        { 
            i++;
            j++;
        }
        else 
            j = next[j];
        }

    if (j == strlen(p))
       return i - j;模式串的位置
    else 
       return -1;
}

```

## 广义表

广义表，又称列表，也是一种线性存储结构。同数组类似，广义表中既可以存储不可再分的元素，也可以存储广义表，记作：

LS = (a1,a2,…,an)

其中，LS 代表广义表的名称，an 表示广义表存储的数据。广义表中每个 ai 既可以代表单个元素，也可以代表另一个广义表。

通常，广义表中存储的单个元素称为 "原子"，而存储的广义表称为 "子表"。

例如创建一个广义表 LS = {1,{1,2,3}}，我们可以这样解释此广义表的构成：广义表 LS 存储了一个原子 1 和子表 {1,2,3}。

以下是广义表存储数据的一些常用形式：
A = ()：A 表示一个广义表，只不过表是空的。
B = (e)：广义表 B 中只有一个原子 e。
C = (a,(b,c,d)) ：广义表 C 中有两个元素，原子 a 和子表 (b,c,d)。
D = (A,B,C)：广义表 D 中存有 3 个子表，分别是A、B和C。这种表示方式等同于 D = ((),(e),(b,c,d)) 。
E = (a,E)：广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。

注意，A = () 和 A = (()) 是不一样的。前者是空表，而后者是包含一个子表的广义表，只不过这个子表是空表。

当广义表不是空表时，称**第一个数据（原子或子表）为"表头"，剩下的数据构成的新广义表为"表尾"**。

强调一下，除非广义表为空表，否则广义表一定具有表头和表尾，且**广义表的表尾一定是一个广义表**。

例如在广义表中 LS={1,{1,2,3},5} 中，表头为原子 1，表尾为子表 {1,2,3} 和原子 5 构成的广义表，即 {{1,2,3},5}。

再比如，在广义表 LS = {1} 中，表头为原子 1 ，但由于广义表中无表尾元素，因此该表的表尾是一个空表，用 {} 表示。

由于广义表中可以同时存储原子和子表两种类型的数据，因此在计算广义表的长度时规定，**广义表中存储的每个原子算作一个数据，同样每个子表也只算作是一个数据。**

例如，在广义表 {a,{b,c,d}} 中，它包含一个原子和一个子表，因此该广义表的长度为 2。

再比如，广义表 {{a,b,c}} 中只有一个子表 {a,b,c}，因此它的长度为 1。

前面我们用 LS={a1,a2,...,an} 来表示一个广义表，其中每个 ai 都可用来表示一个原子或子表，其实它还可以表示广义表 LS 的长度为 n。
广义表规定，空表 {} 的长度为 0。

广义表的性质:

(1):有次序性:各表元素在表中线性排列；

(2):有长度：各表元素个数一定，不能是无限的；

(3):有深度:表中括号的重数即为深度，递归表的深度是无穷大；

(4):可递归:具有这种性质的表为递归表；

(5):可共享:广义表可被其它表共享，被共享的表叫共享表或再入表；

由广义表的性质可知，广义表有深度，它是一种**层次结构**；广义表有共享性，它是一种**有向图**；广义表的表元素有次序，它**类似于一种线性结构**，但只有所有表元素都为原子时才退化为线性表，广义表是一种**非线性结构**。

### 广义表的链接表示

#### 头尾表示

![a](http://c.biancheng.net/uploads/allimg/190427/2-1Z42F93555L0.gif)

#### 拓展线性链表表示

![a](http://c.biancheng.net/uploads/allimg/190427/2-1Z42F93F23F.gif)

![a](http://data.biancheng.net/uploads/allimg/181225/2-1Q22520131H15.gif)

**第一种将原子看作只有一个元素的子表，通过子表互相连接；第二种将两者区分开**都是同深度的互相链接；

#### 层次链表表示法

前两种插删都比较困难，为拓展线性链表表示的每个字表添加一个头结点可简化插删，这种表示有三种结点：原子结点，字表结点，头结点;

字表结点hlink从指向字表首元结点变为指向字表头结点；

用3种tag区分；

表示n元多项式的结点定义：

```cpp
class PolyNode
{
    PolyNode* tlink;//同一层下一结点指针
    int exp;//指数
    int tag;//标志,=0为头结点，=1为子表结点，=2为原子结点；
    union
    {
        char name;//表头链表中存放的基于该链表的变量名
        PolyNode *hlink;//指向系数子链表的指针
        double coef;//系数
    }
}
子表结点中exp是本条链表的变量（头结点name变量）的指数；

将每个子表结点下不同层的多项式相乘的结果相加即为本条链表储存的结果。

```

## 树与二叉树

### 树的基本概念

#### 树的定义

一棵树是n(n>=0)个结点的有限集合，n=0时为空树，而非空树可记作$T=\{r,T_1,T_2,\cdots,T_n\}$,其中，r是T的根结点，$T_1,T_2,\cdots,T_m$是除r外其它结点构成的互不相交的m个子集合，子集合也是一棵树，称为根的子树。

每棵子树的根节点有且仅有一个直接前驱(即它的上层结点)，但可以有0个或n个直接后继(即它的下层结点)，m称为r的分支数。

树的定义是一个递归的定义，即树的定义中又用到了树的概念。

除了逻辑表示外，树还有目录结构表示，韦恩图表示，凹入式表示和广义表表示；

#### 树的基本术语

结点，结点的度(子树棵数)，叶结点(度为0的结点)，分支结点(度不为0)，子女结点，双亲结点，兄弟结点，祖先结点(由根结点到该结点路径上的所有结点(一般指真祖先)，子孙(后裔)结点(一般指真子孙)，结点间的路径，结点的深度(结点所属层次,以最上为基准)，结点的高度(叶结点的高度为1，非叶节点的高度等于它子女结点高度中的最大值加一，以最下为基准)，树的深度(距离根结点最远的结点所处层次)，数的高度(等于根结点的高度,值与树的深度相等)，树的宽度(每一层结点个数的最大值)，树的度(树中结点的度的最大值，度为n就是n叉数)，有序树(各棵子树次序是定的)，无序树(子树次序不定)，森林(是m,m>=0棵树的集合，删去一棵树的根结点，树就变成森林(森林可能为空),反之，将几棵树连接到一个根结点，树就变成森林)；

一些结论:

- 树中的分支条数等于结点条数减一；
  
- 树中任意两个结点之间有且仅有一条路径；

- 树中每队结点至少存在一个共同祖先；

- 一对结点的有且仅有的深度最大的祖先结点称为最低共同祖先；

- 所有结点的度数之和为n-1(计算度的时候除了根结点都被计算了一遍);设度为$k_i$的结点有$m_i$个，则$\sum_{i}^{n}m_i-1=\sum_{i}^{n}(m_i\times k_i)$

- 高度为k的满n叉树的最大宽度为$n_{k-1}$结点总数为:$\sum_{i=1}^{k}n^{i-1}=\frac{n^{k}-1}{n-1}$，反解可得结点总数为n的m叉树的最小深度为$\lceil\log_m(n(m-1)+1\rceil$,(列式时n大于上层最大总数，小于等于本层最大总数)

- 从1开始自顶向下给一个N叉树的结点编号，则编号为i的结点的双亲结点编号为$\lfloor i/N\rfloor$;

### 二叉树及其存储表示

#### 定义

$T=\begin{cases}\emptyset,n=0 \\ \{r,T_L,T_R\}\\ \end{cases}$

特殊二叉树

- 完全二叉树:上面从第一层到第k-1层的结点数都是满的，仅最下面的第k层或是满的，或是集中存放在左侧,最多有$2^k-1$个结点，最少有$2^{k-1}$个结点；

- 满二叉树:满的完全二叉树，第k层有$2^{k-1}$个结点；

- 理想平衡树(丰满树):上面是满的，最后一层的结点散见于该层各处；

#### 特点

- 最多有两个子树，分别称为左子树和右子树，子树可以为空但不能说没有；

- 二叉树的定义是递归的；

- 二叉树可能有5种不同的形态，n叉树可能有$\sum_{i=0}^{n}C_n^i+1(空树)$;

- 关于树的术语二叉树都适用，但二叉树不是树(图论)(定义没有唯一的标准)；
  
  - 树在图论中被视为用n-1条边联结n个顶点的特殊的图，图的顶点集合非空，故树的顶点集合非空。图论中另外定义了N叉树，它可以是空树，二叉树属于N叉树；

  - 非空二叉树有根，根结点的子树有左右之分，树可以没有根(自由树),子树也没有顺序区分；
  
#### 性质

- 第i层(i>0)最多有$2^{i-1}$个结点；
  
- 深度为k(k>=0)的二叉树最少有k个结点，最多有$2^k-1$个结点；

- 对于任意一棵非空二叉树，若其叶结点数为n0,度为2的结点数为n2,则$n_0=n_2+1,(n_0+n_1+n_2-1=n_1+2n_2)$，两者一奇一偶，和为奇数。

- 具有n个结点的完全二叉树或理想平衡树的深度为$\lceil\log_2(n+1)\rceil$或$\lfloor log_2n \rfloor+1$,区别来源于列式时是$2^{d-1}-1<n\leq2^d-1$还是$2^{d-1}\leq n<2^d$，后者不适用等于0的情况。

- 将完全二叉树自顶向下，同一层从左往右从1开始编号，则有以下关系:

  - 奇数结点在右兄弟位置(除根结点)，偶数在左兄弟位置
  
  - 结点i的双亲为结点$\lfloor i/2 \rfloor ,i>1$;

  - 结点i的左子女为2i,2i<=n,右子女为2i+1,2i+1<=n;
  
  - 结点i所在的层次为$\lfloor\log_2i\rfloor+1$;

  - 编号最大的非叶结点为$\lfloor \frac{n-1}{2}\rfloor+1$

  - 从0开始编号时双亲结点公式用i-1替换，其余用i+1替换，左右对应关系对调；

- 完全二叉树度为1的结点只有0个或1个，当n为奇数时，因为n0+n2是奇数，所以n1=0,此时称为严格(正则)二叉树(结点最少为2h-1,最多为2^h-1),n为偶数时n1=1;$n_0=\lceil n/2\rceil,n_1=\lfloor n/2 \rfloor$，**完全二叉树的叶结点数量大于等于非叶结点数量**。

- 有n个结点，高度为n的二叉树的棵数为$2^{n-1}$,每个向下的子女都有两个可能的位置。
  
- 满二叉树某一行的结点数$2^{h-1}=\lceil \frac{n}{2} \rceil,n是该行及其以上结点的总数2^{h}-1$

#### 二叉树的存储

顺序存储，将元素顺序排列在数组里，可用'#'表示空结点，只适合存储完全二叉树，存储空结点多的二叉树浪费空间，数组大小是$2^h-1$

链表存储

二叉链表链指针个数是2n,n+1个是空的，n-1个指向子女，等于边数。

```cpp
class TreeNode
{
public:
    DataType data;
    TreeNode *lchild, *rchild;
    TreeNode() : data(0), lchild(nullptr), rchild(nullptr) {}
    TreeNode(DataType val) : data(val), lchild(nullptr), rchild(nullptr) {}
    TreeNode(DataType val,TreeNode *rptr,TreeNode *lptr): data(val), lchild(lptr), rchild(rptr){}
};
typedef TreeNode *BinTree;

//加一个指向双亲的指针即为三叉链表表示
```

### 二叉树的遍历

#### 定义()

所谓二叉树遍历(binarytree traversal)遵从某种次序，便访二叉树中的所有结点，使得每个结点被访问一次且只访问一次。

#### 分类

共有6种规则:VLR,LVR,LRV,VRL,RVL,RLV,规定先左后右后剩下3种规则，VLR(先序遍历)，LVR(中序遍历),LRV(后序遍历)，递归实现语句区别在于访问语句和递归遍历语句的相对顺序；

```cpp

(1+2*3)+2*3*4的先序，中序，后序遍历结果(前，中，后缀表达式)
+ * 4 * 3 2 + * 3 2 1 
4 * 3 * 2 + 3 * 2 + 1 
4 3 2 * * 3 2 * 1 + + 
```

非递归实现语句较复杂但时间和空间复杂度会降低(不降低数量级),大体都是先从根结点开始沿着左分支下行，并在栈中记录当前结点位置，最后把控制权交给栈顶右子女将其作为新的根结点，区别在于**访问结点语句的位置和转交控制权语句的位置**，特别的，后序非递归实现时栈内保存的是**某一结点和它任意祖先之间的路径**。

设有n个结点，遍历算法的时间复杂度为O(n)(每个结点只访问一次)，空间复杂度最好为$O(log_2n)$,最差为O(n),递归工作栈最多存放的结点数等于树的高度(单支树等于n)，对于递归算法，每次递归就向下一层，也等于树的高度。

层次序遍历(广度优先)的时间复杂度为O(n),空间复杂度为树的宽度,队列最多存放$\lceil \frac{n}{2} \rceil$个结点

|          | 先序 | 中序 | 后序 |
| -------- | ---- | ---- | ---- |
| 左单支树 | 正向 | 逆向 | 逆向 |
| 右单支树 | 正向 | 正向 | 逆向 |

输出序列从上向下为正向。

若先序遍历时u在v之前且后序遍历时在u在v之后，则u是v的祖先。

### 二叉树的重构和计数

二叉树的重构:通过二叉树的遍历序列忠实(唯一)地还原出二叉树的拓扑结构.

- (先序||后序)+中序；可以通过数学归纳法证明，重构算法是遍历前序(从前向后)或后序序列(从后往前)，并在中序序列中将遍历到的结点作为根结点将两个序列拆分开(根，左，右)，不断递归进行,中序决定左右子树序列的长度，先序+后序不行是因为归纳证明时若一个子女为空则通过(t,L/R)和(R/L,t)不能确定该子女是左还是右。

- 由完全二叉树的任意一种遍历序列都可以实现二叉树的重构。

- 根据前序和后序可以重构一棵真(严格)二叉树，因为它不会出现根结点一个子女为空的情况，重构算法是用分治策略，具体是找到根结点和左右子女分界位置并递归地对左右子女进行重构。前序序列:(t,L(...),(R...)),后序序列:((...L),(...R),t)根结点就是前序序列的第一个结点和后序序列的最后一个结点，后序序列的分界点就是前序序列根结点的左子女在后序序列中的位置，对称的可以找到前序序列的分界点。

```cpp
TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
    return create(preorder, inorder, 0, preorder.size() - 1, 0, inorder.size() - 1);
}

TreeNode* create(vector<int>& preorder, vector<int>& inorder, int ps, int pe, int is, int ie){
    if(ps > pe){
        return nullptr;//子树为空
    }
    TreeNode* node = new TreeNode(preorder[ps]);//对于后序是pe
    int pos;
    for(int i = is; i <= ie; i++){
        if(inorder[i] == node->val){//在inorder里寻找子根作为分界点
            pos = i;
            break;
            }
    }
    node->left = create(preorder, inorder, ps + 1, ps + pos - is, is, pos - 1);//左子树序列长度为pos-is
    node->right = create(preorder, inorder, pe - ie + pos + 1, pe, pos + 1, ie);//右子树序列长度为ie-pos
     /*利用中后序构造： node->left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1);  
        node->right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1); */
    return node;
}
```

二叉树的计数:假设一个二叉树有n个结点，并对各个结点编号，先序遍历得到的叫先序排列，中序得到的叫中序排列，设先序排列是1到n，则中序排列数决定能确定多少棵二叉树。

递推公式为$\begin{cases}b_0=1,n=0\\b_n=\sum_{i=0}^{n-1}(b_i\times b_{n-i-1}),i\geq1\\\end{cases}$

结果为卡特兰数$\frac{1}{n+1}C_{2n}^n =\frac{1}{n+1}\times \frac{(2n)!}{n!\times n!}= \frac{2n(2n-1)\cdots(n+2)}{n!}$

```cpp

int numTrees(int n) {

vector<int> t(n + 1, 0);
    t[0] = t[1] = 1;
    int i, j;
    for (i = 2; i <= n; ++i)
    {
        for (j = 1; j <= i / 2; ++j)//结构是对称的，计算一半再乘二较为简便(奇数项的中间项只有一项，后面再加)
        t[i] += t[j - 1] * t[i - j];
        t[i] *= 2;
        if (i % 2)//加上奇数项的中间项
        t[i] += t[i / 2] * t[i / 2];//Plus the middle 'root' trees.(结点子女相同)
        }
       return t[n];
}
```

```cpp
public:
    vector<TreeNode *> generateTrees(int n)
    {
        if (n == 0)
            return {} ;//return vector<TreeNode *>(0),a NULL vector;
        return helper(1, n);
    }
private:
    vector<TreeNode *> helper(int start, int end)
    {
        vector<TreeNode *> res;
        if (start > end)
        {
           res.push_back(NULL);
            return res;
        }
        for (int i = start; i <= end; i++)
        {
            vector<TreeNode *> left = helper(start, i - 1);//分治
            vector<TreeNode *> right = helper(i + 1, end);
            for (int j = 0; j < left.size(); j++)//遍历所有组合
                for (int k = 0; k < right.size(); k++)
                {
                    TreeNode *root = new TreeNode(i);
                    root->left = left[j];
                    root->right = right[k];
                    res.push_back(root);
                }
        }
        return res;
    }
```

线索二叉树

对一棵二叉树中所有节点的空指针域按照某种遍历方式加线索的过程叫作线索化，被线索化了的二叉树称为线索二叉树。

```cpp
 struct TBNode
{
    char data;
    int ltag,rtag;
    struct TBNode *lchild;
    struct TBNode *rchild;
};
```

对于中序遍历的二叉树，左子女为空时会丢失前置结点，右子女为空时会丢失后置结点，为这两种情况找到对应的结点就建立了中序线索二叉树。

```cpp
void InThreaded(TBNode *p,TBNode *&pre)
{
    if(p){
        InhTreaded(p->lchild,pre);//递归线索化左子树
        if(p->lchild==nullptr){//当前结点左子女为空则设置前置结点
            p->lchild=pre;
            p->ltag=1;
        }
        if(pre&&p->rchild=nullptr)//将当前结点设置为非空的空右子女前置结点的后置结点
        {
            pre->rchild=p;
            p->rtag=1;
        }
        pre=p;//当前结点是右子树的前置结点
        InTheaded(p->rchild,pre);
    }
}
int main(){
    Create(T);
    TBNode *pre=nullptr;
    if(T)
    {
        InTheaded(T,pre);
        pre->rchild=nullptr;
        pre->rtag=1;//设置最后一个结点的后置结点为空
    }
}
```

先序和后序线索化类似。

### 树与森林

子女—兄弟表示

寻找子女的复杂度是O(d),寻找双亲的复杂度是O(n);

树转化为二叉树，将树的根结点变为二叉树的根结点，再将树的左子女转化为二叉树并链接在二叉树的左子树上，最后将左子女的兄弟结点转换为二叉树并迭代链接在二叉树子女的右支上。转换得到的二叉树根没有右子女。

相当于将树右旋45度，向右平行的兄弟连支变为了向右下的右连支，向下的子女连支变为了向左下的左连支。

类似可得二叉树到树的转化。

去掉根结点的子女不唯一的树就是森林

树的遍历

先根遍历和中根遍历为深度优先遍历，层次序遍历为广度优先遍历。

## 树的应用

### 哈夫曼树

树的路径长度是根结点到每一个结点的路径长度(结点的深度减一)之和

n个二叉树的最小路径长度$PL=\sum_{i=0}^{n-1} \lfloor\log_2{i+1}\rfloor=(n+1)\;\lfloor\log_2n\rfloor-2^{\lfloor\log_2{n+1}\rfloor}+2$,此时二叉树为完全二叉树。

对于一颗已有的二叉树， 如果我们为它添加一系列新结点，使得它原有的所有结点的度都为2，那么我们就得到了一颗扩充二叉树

外结点数 = 内结点数 + 1
总结点数 = 2 × 外结点数 -1

将权值{w1,w2,...,wn}(wi>=0)分别赋给T的n个叶节点，称T为权值为{w1,w2,...,wn}的扩充二叉树，带有权值的叶节点叫做扩充二叉树的外结点，其余结点叫做内结点。

扩充二叉树的带权路径长度定义为$WPL=\sum_{i=1}^nw_il_i$,WPL最小时即为Huffman树。

带权路径长度最小的扩充二叉树不一定是完全二叉树，权值越大的离根结点越近的是。

Huffman算法(构造huffman树)

构造n个带有权值的结点组成的森林，将权值较小的两棵树合并，合并后的新根的权值为其子女结点权值之和，合并到只剩一棵树，所得的树就是huffman树。

限制外结点大小顺序可得唯一确定的树

```cpp
//静态三叉链实现
using DataType = char;
struct HFNode
{
    DataType data;
    int weight;
    int parent, lchild, rchild;
    HFNode(int w = -1, DataType val = 0, int par = -1, int lc = -1, int rc = -1) : weight(w), data(val), parent(par), lchild(lc), rchild(rc)
    {
    }
};
struct HFTree
{
    HFNode *elem;
    int leafNum, totalNum, root;
    ~HFTree() { delete elem; }
};
```

数组中前n个是外结点，后n-1个是内结点，第2n-2个是根结点，构造的时间复杂度为o(n^2);

最优判定树

用Huffman树建立的成绩查询树的WPL不一定是最优判定树，因为有的内结点判定等同于两次判定，权值会比预期的大。

改进算法与Huffman算法的区别是轮流检查**权值和最小的相邻两树**并进行合并,并且排列时相对顺序不能变化(可以在数组中将合并后的根结点与原左子女的位置交换，将右子女移到交换后左子女的前一个位置，中间部分顺序前移，最终根结点在第一个元素处)，用链式表实现较为容易(静态表子女的位置改变后不能追踪)。

Huffman编码

将二叉树的左分支标记为0，右分支标记为1，从根结点到叶节点的路径唯一的表示了该叶节点的二进制编码。

设计变长编码，为出现概率较低的字符指定较长的码字，为出现概率较大的字符指定较短的码字，可以明显提高传输的平均性能。

前缀性质:任一字符编码都不是其它字符编码的前缀。用二叉树表示可以保证这个性质。

平均编码长度最小的前缀编码称为最优编码，可以通过构造huffman树解决，Huffman树的带权路径长度就是相应编码的平均编码长度，得到的编码称为Huffman编码。

