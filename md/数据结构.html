<!DOCTYPE html>
<html>
<head>
<title>数据结构.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</a>
<ul>
<li><a href="#%E7%BB%AA%E8%AE%BA">绪论</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">基本术语</a></li>
<li><a href="#c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85">C语言知识点补充</a>
<ul>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E5%90%88%E6%96%B9%E5%90%91%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7%E5%92%8C%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8Fauto-incrementauto-decrement">运算符结合方向和结合性和自增自减(auto-increment,auto-decrement)</a></li>
<li><a href="#%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">数字与字符串转换</a></li>
<li><a href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82">二维数组传参</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</a></li>
<li><a href="#ab%E5%92%8Cab%E7%9A%84%E7%9F%AD%E8%B7%AF%E8%A7%84%E5%88%99short-circuited">A&amp;&amp;B和A||B的短路规则(short-circuited)</a></li>
<li><a href="#%E6%9F%A5%E7%9C%8B%E5%87%BD%E6%95%B0%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC">查看函数中数组的值</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%92%8C%E6%B1%82%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0">删除元素和求特定元素</a></li>
<li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</a></li>
<li><a href="#log%E5%92%8Cexp">log和exp</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%E5%B0%8F%E7%AE%80%E5%8C%96">选择排序法小简化</a></li>
<li><a href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">浅拷贝和深拷贝</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B0">获取随机数</a></li>
<li><a href="#%E5%BF%AB%E6%8E%92%E5%87%BD%E6%95%B0quick-sort">快排函数（quick sort）</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">算法和算法设计</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7">算法的特性</a></li>
<li><a href="#%E6%B5%8B%E9%87%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4">测量程序运行时间</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6complexity%E5%BA%A6%E9%87%8F%E5%92%8C%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1">算法的复杂度(complexity)，度量和问题规模</a></li>
<li><a href="#%E6%B8%90%E8%BF%9B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">渐进的时间复杂度</a></li>
<li><a href="#markdown-%E8%AF%AD%E6%B3%95">markdown 语法</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B%E9%A2%98">时间复杂度例题</a>
<ul>
<li><a href="#%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97">循环嵌套</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB">递归，分治</a></li>
<li><a href="#binary-search%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">Binary Search(二分查找)</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%BB%A5%E5%8F%8A-%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%A0%B9">最大公约数和最小公倍数以及 二分法求根</a></li>
<li><a href="#%E6%B1%89%E8%AF%BA%E5%A1%94">汉诺塔</a></li>
<li><a href="#%E9%9A%8F%E6%9C%BA%E7%BD%AE%E6%8D%A2%E6%95%B0%E7%BB%84">随机置换数组</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8list">线性表(List)</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9">定义和特点</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8">顺序表</a>
<ul>
<li><a href="#%E5%AD%98%E5%82%A8">存储</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0">顺序表查找时的平均比较次数</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8F%92%E5%85%A5%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0">顺序表插入时的平均移动次数</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0">顺序表删除时的平均移动次数</a></li>
</ul>
</li>
<li><a href="#%E9%93%BE%E8%A1%A8linked-list">链表（Linked List）</a>
<ul>
<li><a href="#%E5%8D%95%E9%93%BE%E8%A1%A8singly-linked-list">单链表（Singly Linked List）</a></li>
<li><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C%E9%93%BE%E8%A1%A8">二级指针操作链表</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4">判断环和相交</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83">顺序表和线性链表的比较</a>
<ul>
<li><a href="#%E5%AD%98%E5%82%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E6%AF%94%E8%BE%83">存储方面的比较</a></li>
<li><a href="#%E5%AD%98%E5%8F%96%E6%96%B9%E9%9D%A2%E7%9A%84%E6%AF%94%E8%BE%83">存取方面的比较</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A0%88stack%E5%92%8C%E9%98%9F%E5%88%97queue">栈(Stack)和队列(Queue)</a>
<ul>
<li><a href="#%E6%A0%88">栈</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC">基本</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E6%B7%B7%E6%B4%97stack-shuffl">栈的混洗(stack shuffl)</a></li>
<li><a href="#%E5%BA%94%E7%94%A8">应用</a>
<ul>
<li><a href="#%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87">判断回文</a></li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a></li>
<li><a href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2-1">进制转换()</a></li>
<li><a href="#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8Dparenthesis-matching">括号匹配(parenthesis matching)</a></li>
<li><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97">表达式的计算</a></li>
</ul>
</li>
<li><a href="#%E5%B0%86%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">将中缀表达式转换为后缀表达式</a>
<ul>
<li><a href="#%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">计算后缀表达式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%98%9F%E5%88%97">队列</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC-1">基本()</a>
<ul>
<li><a href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">循环队列</a></li>
</ul>
</li>
<li><a href="#%E5%BA%94%E7%94%A8-1">应用()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8">矩阵存储，字符串匹配和广义表</a>
<ul>
<li><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA">多维数组的存储表示</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8">对称矩阵的压缩存储、</a></li>
<li><a href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8">稀疏矩阵的存储</a>
<ul>
<li><a href="#%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8">三元组表</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA">链表表示</a></li>
</ul>
</li>
<li><a href="#kmp">KMP</a></li>
</ul>
</li>
<li><a href="#%E5%B9%BF%E4%B9%89%E8%A1%A8">广义表</a>
<ul>
<li><a href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E8%A1%A8%E7%A4%BA">广义表的链接表示</a>
<ul>
<li><a href="#%E5%A4%B4%E5%B0%BE%E8%A1%A8%E7%A4%BA">头尾表示</a></li>
<li><a href="#%E6%8B%93%E5%B1%95%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA">拓展线性链表表示</a></li>
<li><a href="#%E5%B1%82%E6%AC%A1%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95">层次链表表示法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91">树与二叉树</a>
<ul>
<li><a href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">树的基本概念</a>
<ul>
<li><a href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">树的定义</a></li>
<li><a href="#%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">树的基本术语</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA">二叉树及其存储表示</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E7%89%B9%E7%82%B9">特点</a></li>
<li><a href="#%E6%80%A7%E8%B4%A8">性质</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8">二叉树的存储</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89-1">定义()</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E6%9E%84%E5%92%8C%E8%AE%A1%E6%95%B0">二叉树的重构和计数</a></li>
<li><a href="#%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97">树与森林</a></li>
</ul>
</li>
<li><a href="#%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8">树的应用</a>
<ul>
<li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">哈夫曼树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</a></li>
<li><a href="#avl%E6%A0%91">AVL树</a></li>
<li><a href="#%E5%85%AB%E7%9A%87%E5%90%8E">八皇后</a></li>
<li><a href="#%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86">等价关系与并查集</a></li>
<li><a href="#%E6%B1%82%E5%B9%82%E9%9B%86">求幂集</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE">图</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">基本定义</a></li>
<li><a href="#%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA">图的表示</a></li>
<li><a href="#%E8%BF%9E%E9%80%9A%E6%80%A7">连通性</a></li>
<li><a href="#%E9%81%8D%E5%8E%86">遍历</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8">图的应用</a>
<ul>
<li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Ftopological-sorting">拓扑排序(Topological sorting)</a></li>
<li><a href="#%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F">连通分量</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E6%90%9C%E7%B4%A2pfs">优先级搜索(PFS)</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E6%89%BE">查找</a>
<ul>
<li><a href="#hashtable">HashTable</a>
<ul>
<li><a href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列函数</a></li>
</ul>
</li>
<li><a href="#%E6%8E%92%E8%A7%A3%E5%86%B2%E7%AA%81">排解冲突</a>
<ul>
<li><a href="#%E5%A4%9A%E6%A7%BD%E4%BD%8D%E6%B3%95">多槽位法</a></li>
<li><a href="#%E7%8B%AC%E7%AB%8B%E9%93%BE%E6%B3%95%E6%8B%89%E9%93%BE%E6%B3%95">独立链法(拉链法)</a></li>
<li><a href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80">开放定址</a>
<ul>
<li><a href="#%E7%BA%BF%E6%80%A7%E8%AF%95%E6%8E%A2">线性试探</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B3%E6%96%B9%E8%AF%95%E6%8E%A2">平方试探</a></li>
<li><a href="#%E5%8F%8C%E5%90%91%E5%B9%B3%E6%96%B9%E8%AF%95%E6%8E%A2%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E6%B3%95">双向平方试探(二次探测法)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</h1>
<h2 id="%E7%BB%AA%E8%AE%BA">绪论</h2>
<h3 id="%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">基本术语</h3>
<p><strong>数据</strong>分为<strong>数值性数据</strong>和<strong>非数值数据</strong>，其基本单位是<strong>数据元素</strong>，是计算机处理或访问的基本单位；</p>
<p>一个数据元素可以由若干数据项组成，<strong>数据项</strong>又称<strong>属性，字段，域，<strong>分为</strong>初等项</strong>（不可分割）和<strong>组合项</strong>；</p>
<p><strong>结构</strong>:<strong>数据元素之间的关系</strong>；</p>
<p><strong>数据结构是由与特定问题相关的某一数据元素的集合(<em>对象</em>)(Data)和该集合中数据元素之间的关系(Relationship)组成的</strong>；分为<strong>静态数据结构</strong>和<strong>动态数据结构</strong>，舍弃了实际的物理背景，是通用型的定义；</p>
<p>数据结构={D,R}</p>
<p><strong>数据对象</strong>:<strong>狭义：具有一定关系的<em>相同性质</em>的数据元素的集合</strong>；<strong>广义：由数据抽象和处理数据构成的封装体</strong></p>
<p><strong>数据类型</strong>:<strong>一个值的集合和定义在这个值集合上的一组操作的总称</strong>，分为<strong>内置数据类型（亦称基本数据类型或原子类型，可直接使用）<strong>和</strong>构造数据类型（由不同成分的内置数据类型子结构按照一定的规则组成，是用编程语言描述的数据结构的存储映像）</strong>，是<strong>数据结构的实例化</strong>；数据类型<strong>再实例化</strong>得到具体变量，如<strong>类与对象</strong>；</p>
<p>抽象数据类型ADT（Abstract Data Type):</p>
<p><strong>抽象的本质就是抽取反映问题本质的东西，忽略非本质的细节</strong>；</p>
<p>特性：<strong>使用与实现相分离</strong>，<strong>数据<em>封装</em>与<em>信息</em>隐蔽</strong>；</p>
<p>在C++，java中用类描述。C中一般不使用ADT，数据和结构是分开的。</p>
<p>数据结构：</p>
<p>一，<strong>分解和抽象</strong>：1，<strong>数据分解划分出数据的层次，再抽象得到数据的<em>逻辑结构</em></strong>；2，<strong>处理分解划分成各种功能，再通过抽象得到算法的定义</strong>。这是一个从具体（具体问题）到抽象（数据结构与算法）的过程；进一步<strong>通过对实现细节的进一步考虑得到存储结构和实现运算，从而完成程序设计的任务</strong>，实现从数据结构到具体实现。</p>
<p>二，逻辑结构和存储结构</p>
<p><strong>数据的逻辑结构根据问题所要实现的功能建立（不考虑具体实现），存储结构根据问题所要的需求（响应速度，处理时间，等）来实现数据的逻辑结构。（数据结构一般指的就是逻辑结构，逻辑结构相同，即使存储结构不同也是相同的逻辑结构）；</strong></p>
<p>逻辑结构的分类：</p>
<p><strong>线性结构 ，树形结构 ，图结构， 集合结构。</strong></p>
<p><strong>线性结构</strong>：元素之间的关系是<strong>一对一</strong>的，如线性表，向量，栈，队列，优先队列，字典等；</p>
<p><strong>非线性结构</strong>：每个数据结构可能<strong>与零个或多个其他数据元素发生联系</strong>，分为树结构（一对多）和图结构（多对多）。<br>
如多维数组和广义表等；</p>
<p><strong>集合结构的实现往往采用其他逻辑结构的存储表示。</strong></p>
<p>数据结构的存储结构：</p>
<p>存取结构根据存取方法的不同分为三类：</p>
<p>1，<strong>直接存取结构</strong>（向量，多维数组，散列表）；</p>
<p>2，<strong>顺序存取结构</strong>（各种链表，图的邻接表）；</p>
<p>3，<strong>索引存取结构</strong>（线性索引，多叉查找树）；</p>
<p>常用的四种存储结构</p>
<p>1，<strong>顺序存储</strong>：元素之间的逻辑关系由<strong>存储单元的邻接位置关系体现</strong>，由此得到顺序存储结构，借助<strong>一维数组</strong>描述；</p>
<p>2，<strong>链接存储</strong>：元素之间的逻辑关系由<strong>附加的链接指针指示</strong>，由此得到链表存储结构，借助<strong>指针类型</strong>描述；</p>
<p>3，<strong>索引存储</strong>：在存储元素信息的同时还建立<strong>索引表</strong>，其中每一项称为<strong>索引项（包括关键码和地址）</strong>，按针对一个元素还是一组元素分为<strong>稠密索引和稀疏索引</strong>；按是一层还是多层分为线<strong>性索引和多级索引</strong>；</p>
<p>4，<strong>散列存储</strong>：根据元素的关键码<strong>通过一个函数计算得到</strong>元素的存储地址。</p>
<p>前两种在<strong>内存</strong>中，也是基本的<strong>两种物理存储结构</strong>。后两个在<strong>外存</strong>中。/</p>
<p>选择存储结构的要素有&lt;1&gt;<em>访问频率</em>，&lt;2&gt;<em>修改频率</em>，&lt;3&gt;<em>安全保密</em>；</p>
<p>定义在数据结构上的操作：</p>
<p><strong>1，创建；2，销毁；3，查找；4，插入；5，删除；6，排序</strong>。</p>
<p>好的数据结构：<strong>可以通过某种“线性化”规则被转化为线性结构，通常对应好的算法</strong>；</p>
<p>计算机本质上<strong>只能按照逻辑顺序处理指令和内存单元</strong>，例如图，树的遍历查找需要线性化。</p>
<h3 id="c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85">C语言知识点补充</h3>
<h4 id="%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E5%90%88%E6%96%B9%E5%90%91%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7%E5%92%8C%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8Fauto-incrementauto-decrement">运算符结合方向和结合性和自增自减(auto-increment,auto-decrement)</h4>
<p>大多数运算符结合方向是“自左至右”，即：先左后右，也叫“左结合性”，例如 a－b + c，表达式中有－和+两种运算符，且优先级相同，按先左后右结合方向，先围绕减号结合，执行a－b的运算，再围绕加号结合，完成运算(a－b) + c。除了左结合性外，C 语言有三类运算符的结合方向是从右至左，也叫“右结合性”，即：<strong>单目运算符、条件运算符、以及赋值运算符</strong>。着重强调一点，无论是左结合性，还是右结合性，是针对两个相邻的优先级相同的运行符而言(不是表达中的运算对象)，<strong>运算符是决定左右的基准点，先以前面的运算符(即位置上处于左边的运算符)构造运算，就是左结合，反之，就是右结合。</strong></p>
<p>条件运算符嵌套时必要时用优先级最高的括号分隔</p>
<p><strong>函数参数自右向左进栈，要考虑右边参数对左边的影响</strong>。</p>
<p><img src="https://www.pianshen.com/images/476/c2da92eaab6cd2b87d017e12c7d7ca3c.png" alt="a"></p>
<p>i++ 与 ++i 的主要区别有两个：<br>
1、 i++ 返回原来的值，++i 返回加1后的值。<br>
2、 i++ 不能作为左值，而++i 可以。</p>
<p>i=1;  j=i+++i++;先执行两个i++,返回值分别为1和2；i自增两次，所以j=i=3；</p>
<p>只能用于左值，例如(num+1)--是错误的</p>
<h4 id="%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">数字与字符串转换</h4>
<pre class="hljs"><code><div><span class="hljs-keyword">char</span>*==<span class="hljs-built_in">string</span>.c_str();
 <span class="hljs-built_in">sprintf</span>(s, <span class="hljs-string">"%d"</span>, x);将%d形式的x以字符串形式放在s里，并自动添加结尾

<span class="hljs-keyword">int</span>-&gt;<span class="hljs-built_in">string</span>:

<span class="hljs-built_in">std</span>::to_string(<span class="hljs-keyword">int</span>)

<span class="hljs-built_in">std</span>::to_string(<span class="hljs-keyword">long</span>)

<span class="hljs-built_in">std</span>::to_string(<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)

<span class="hljs-built_in">std</span>::to_string(<span class="hljs-keyword">float</span>)

<span class="hljs-built_in">std</span>::to_string(<span class="hljs-keyword">double</span>)

<span class="hljs-built_in">std</span>::to_string(<span class="hljs-keyword">long</span> <span class="hljs-keyword">double</span>)

还支持各类<span class="hljs-keyword">unsigned</span>，基本上主流数值类型都能无脑转换

<span class="hljs-built_in">string</span>-&gt;<span class="hljs-keyword">int</span>:

<span class="hljs-comment">//#include&lt;cstdlib&gt;</span>

<span class="hljs-built_in">std</span>::stoi

<span class="hljs-built_in">std</span>::stol

<span class="hljs-built_in">std</span>::stoll

<span class="hljs-comment">//看名字就知道对应为int,long,long long</span>


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">stoi</span> <span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">string</span>&amp;  str, <span class="hljs-keyword">size_t</span>* idx = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> base = <span class="hljs-number">10</span>)</span>
 
 <span class="hljs-keyword">int</span> x</span>=stoi(s);

 stoi(<span class="hljs-built_in">string</span>.c_str(),idx,base);

<span class="hljs-comment">//比atoi安全</span>
<span class="hljs-comment">//idx是一个指针，该指针指向一个size_t类型的对象</span>
<span class="hljs-comment">//传入指针地址后，该对象的值会被修改为string中数值后的第一个字符所在位置</span>
<span class="hljs-comment">//例如stoi("123abcd",&amp;p),返回的p指向a所在</span>


进制是输入数字的进制；
</div></code></pre>
<h4 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82">二维数组传参</h4>
<p><strong>不常用</strong>。</p>
<pre class="hljs"><code><div>
不用区分行列遍历
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p,<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//或int p[];</span>
</span>{
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//存储在一块连续的区域</span>
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,p[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> s[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]={<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>};
Print((<span class="hljs-keyword">int</span>*)s,<span class="hljs-number">6</span>);<span class="hljs-comment">//(int*)s==s[0];</span>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **p)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, *(( <span class="hljs-keyword">int</span>* )p+ <span class="hljs-number">2</span>*i + j));<span class="hljs-comment">//编译器寻址方式，根据二级指针不能自动寻址</span>
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> s[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};
    Print((<span class="hljs-keyword">int</span> **)s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
二维数组名的类型是type (*)[n];是一个数组指针，可强制转换成type**和type*，地址是一样的
 
</div></code></pre>
<p>常用</p>
<p><strong>int s[][n];n不能为空。一维数组也建议用int s[];较直观，便于与其他的指针区分。</strong></p>
<h4 id="%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</h4>
<pre class="hljs"><code><div> <span class="hljs-keyword">int</span> **s = (<span class="hljs-keyword">int</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> *));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
        s[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)
            s[j][k]=<span class="hljs-number">1</span>;
        }
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)<span class="hljs-comment">//逐层由内向外释放</span>
        <span class="hljs-built_in">free</span>(s[j]);
        <span class="hljs-built_in">free</span>(s);

 <span class="hljs-keyword">int</span> *s[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
        s[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)
            s[j][k]=<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)<span class="hljs-comment">//不用也不能释放s，它不是动态分配的</span>
        <span class="hljs-built_in">free</span>(s[j]);
</div></code></pre>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">unsigned</span> newsize)</span></span>;  
  <span class="hljs-comment">//对malloc申请的内存进行大小的调整.</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> numElements, <span class="hljs-keyword">size_t</span> sizeOfElement)</span></span>; 
        <span class="hljs-comment">//初始化分配的内存,设置为0</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s, <span class="hljs-keyword">int</span> ch, <span class="hljs-keyword">size_t</span> n)</span></span>;
        <span class="hljs-comment">//将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</span>
        <span class="hljs-comment">//memset函数按字节对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。</span>
</div></code></pre>
<p>calloc相当于malloc加memset;</p>
<p><strong>函数需要返回字符串时不能返回局部变量，只能返回形参中的字符串或用动态分配的空间，一般用<em>calloc</em>(不用担心结尾是否为0)</strong></p>
<h4 id="ab%E5%92%8Cab%E7%9A%84%E7%9F%AD%E8%B7%AF%E8%A7%84%E5%88%99short-circuited">A&amp;&amp;B和A||B的短路规则(short-circuited)</h4>
<p>如果A为假，则A&amp;&amp;B短路，如果A为真，则A||B短路，不再判断B。</p>
<p>应用：对于A||B如果A真时B可能溢出则A必须在前；</p>
<p>避免短路时可用按位操作，注意只能是bool之间比较</p>
<h4 id="%E6%9F%A5%E7%9C%8B%E5%87%BD%E6%95%B0%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC">查看函数中数组的值</h4>
<p>1，*(type(*)[len])arrname;强制转换为数组指针（它的最本质类型），再取值。</p>
<p>2,*(arrname)@len;用这个简单。</p>
<h4 id="%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%92%8C%E6%B1%82%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0">删除元素和求特定元素</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delchar</span><span class="hljs-params">( <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> c )</span><span class="hljs-comment">//删除单个位置的元素时用顺移较为简单</span>
</span>{
   <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<span class="hljs-comment">//</span>
    <span class="hljs-keyword">while</span>(str[i])<span class="hljs-comment">//用j的话需要在结尾加\0</span>
    {
        <span class="hljs-keyword">if</span>(str[j]!=c)
        str[i++]=str[j];
        j++;
    }
}
<span class="hljs-keyword">while</span> (i&lt;L.num)<span class="hljs-comment">//线性表删除特定元素</span>
    {
        <span class="hljs-keyword">if</span> (L.data[i] != x)
        {
            L.data[j++] = L.data[i];
        }
        i++;
    }
    L.num =j;
}
 <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L.num; i++)<span class="hljs-comment">//无序线性表删除重复元素，有序的与有序区的结尾元素进行比较即可</span>
    {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= k; j++)<span class="hljs-comment">//k:border of non-repreting region</span>
        {
            <span class="hljs-keyword">if</span> (L.data[i] == L.data[j])
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (j &gt; k)
            L.data[++k] = L.data[i];
    }
    L.num = k + <span class="hljs-number">1</span>; 

<span class="hljs-keyword">while</span>(i&lt;A.num&amp;&amp;j&lt;B.num)<span class="hljs-comment">//求有序表共有元素</span>
{
    <span class="hljs-keyword">if</span>(A.data[i]&lt;B.data[j])
    i++;<span class="hljs-comment">//跳过小的元素</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A.data[i]&gt;B.data[j])
    j++;
    <span class="hljs-keyword">else</span> same=A.data[i];
}
</div></code></pre>
<h4 id="%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ten2two</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)
{
ten2two(n/<span class="hljs-number">2</span>);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,n%<span class="hljs-number">2</span>);   <span class="hljs-comment">//递归为逆序输出，故先写调用函数，后写printf</span>
}
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">return</span>;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> n;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> n%<span class="hljs-number">10</span>+<span class="hljs-number">2</span>*convert(n/<span class="hljs-number">10</span>);
}
</div></code></pre>
<p>将2到36进制数转换为10进制</p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Atoi</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s,<span class="hljs-keyword">int</span> radix)</span>    <span class="hljs-comment">//s是给定的radix进制字符串</span>
</span>{
    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;s.size();i++)
    {
        <span class="hljs-keyword">char</span> t=s[i];
        <span class="hljs-keyword">if</span>(t&gt;=<span class="hljs-string">'0'</span>&amp;&amp;t&lt;=<span class="hljs-string">'9'</span>) ans=ans*radix+t-<span class="hljs-string">'0'</span>;
        <span class="hljs-keyword">else</span> ans=ans*radix+t-<span class="hljs-string">'a'</span>+<span class="hljs-number">10</span>;
    }
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-comment">//利用库函数</span>
 <span class="hljs-built_in">string</span> s = <span class="hljs-string">"bacppp"</span>;
    <span class="hljs-keyword">char</span> *stop;
    <span class="hljs-built_in">cout</span> &lt;&lt; strtol(s.c_str(), &amp;stop, <span class="hljs-number">16</span>) &lt;&lt;<span class="hljs-built_in">endl</span>&lt;&lt;stop&lt;&lt; <span class="hljs-built_in">endl</span>;<span class="hljs-comment">//stop是非法部分,注意引用符号</span>
<span class="hljs-comment">//返回值类型是long</span>
<span class="hljs-number">2988</span>
ppp

<span class="hljs-comment">//利用栈</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SysConvert</span><span class="hljs-params">( <span class="hljs-built_in">string</span> s, <span class="hljs-keyword">int</span> init, <span class="hljs-keyword">int</span> k)</span>
</span>{
    <span class="hljs-keyword">char</span> *t;
    <span class="hljs-keyword">long</span> num = strtol(s.c_str(), &amp;t, init);
    SeqStack(S);
    InitStack(S,<span class="hljs-keyword">int</span>(<span class="hljs-built_in">log</span>(num)/<span class="hljs-built_in">log</span>(k))+<span class="hljs-number">1</span>);
     <span class="hljs-keyword">while</span>(num)
     {
         Push(S,num%k);
         num/=k;
     }
     PrintStack(S);
}
</div></code></pre>
<h4 id="log%E5%92%8Cexp">log和exp</h4>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;math.h&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{ 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f\n"</span>,<span class="hljs-built_in">log</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">//以e为底的对数函数 </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f\n"</span>,<span class="hljs-built_in">log10</span>(<span class="hljs-number">100</span>)); <span class="hljs-comment">//以10为底的对数函数 </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f\n"</span>,<span class="hljs-built_in">log</span>(<span class="hljs-number">8</span>)/<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)); <span class="hljs-comment">//计算log_2^8,运用换底公式 </span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%f\n"</span>,<span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span>)); <span class="hljs-comment">//计算自然常数e</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%E5%B0%8F%E7%AE%80%E5%8C%96">选择排序法小简化</h4>
<pre class="hljs"><code><div>
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>,index;j&lt;i<span class="hljs-number">-1</span>;j++)
    {
        index=j;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j+<span class="hljs-number">1</span>;k&lt;i<span class="hljs-number">-1</span>;k++)
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(s[k])&lt;<span class="hljs-built_in">strlen</span>(s[index]))
                index=k;
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s "</span>,s[index]);<span class="hljs-comment">//如果只是要输出将最小的依次输出然后把最小值替换即可，不用交换</span>
        <span class="hljs-built_in">strcpy</span>(s[index],s[j]);
    }
</div></code></pre>
<h4 id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">浅拷贝和深拷贝</h4>
<p>结构体是一种类，拷贝概念上可近似看待</p>
<p>浅拷贝：<strong>拷贝过程中是按字节复制的</strong>，对于指针型成员变量只复制指针本身，而<strong>不复制指针所指向的目标</strong>。<br>
<strong>值传递能保证值不变，但不能保证值上的值不变</strong>。函数传参时<strong>默认拷贝函数就是浅拷贝。</strong><br>
手动实现可以<strong>直接等</strong>或者用memcpy</p>
<p><strong>memcpy(&amp;CpA,&amp;A,sizeof(struct SeqList));</strong></p>
<p>另一个mem函数：void *memset(void *str, char c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。<br>
memset(str,'$',7);</p>
<p>深拷贝：自定义拷贝函数，以实现完全复制</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeepCopy</span><span class="hljs-params">(SeqList &amp;CpTemp, SeqList A)</span>
</span>{
    CpTemp.num = A.num;
    CpTemp.data = <span class="hljs-keyword">new</span> DataType[Length];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.num; i++)
    {
        CpTemp.data[i] = A.data[i];
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>
{</span>
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">char</span> c;
    <span class="hljs-keyword">char</span>* p;
    stu&amp; <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> stu&amp; stuTmp)<span class="hljs-comment">//显式定义拷贝构造函数</span>
    {
        i = stuTmp.i;<span class="hljs-comment">//i==this-&gt;i;两侧能区分时可以省略</span>
        c = stuTmp.c;
        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-built_in">strlen</span>(stuTmp.p) + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">strcpy</span>(p, stuTmp.p);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;返回拷贝的结构体
    };
};

 s2 = s1;当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符
 相当于s2.<span class="hljs-keyword">operator</span>(s1);
</div></code></pre>
<p>operator=() 的返回值类型为引用，这样不但能够<strong>避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的</strong></p>
<h4 id="%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B0">获取随机数</h4>
<p>从X到Y，有Y－X＋1个数，所以要产生从X到Y的数，只需要这样写：<br>
<em>k=rand()%(Y-X+1)+X;</em></p>
<p>每次获取前运行<em>srand(time(NULL))</em>；改变随机数计算函数初值，在time.h下。</p>
<p>一字节（byte）等于八位（bit）；</p>
<p>整数取值范围：$\overbrace{100000....000}^{31}=-2^{31}$ 补码是源码<strong>除符号位</strong>外取反加一，逆推原码也是这样或者减一取反。$\overbrace{01111111111111111}^{32} =2^31-1$，具体值用<strong>pow表达式或者用确切值</strong>。</p>
<h4 id="%E5%BF%AB%E6%8E%92%E5%87%BD%E6%95%B0quick-sort">快排函数（quick sort）</h4>
<pre class="hljs"><code><div>C:stdlib.<span class="hljs-function">h

<span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(
   <span class="hljs-keyword">void</span> *base,
   <span class="hljs-keyword">size_t</span> number,
   <span class="hljs-keyword">size_t</span> width,<span class="hljs-comment">//Element size in bytes.</span>
   <span class="hljs-keyword">int</span> (__cdecl *compare )(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<span class="hljs-comment">//qsort calls the compare routine one or more times during the sort, and passes pointers to two array elements on each call. If compare indicates two elements are the same, their order in the resulting sorted array is unspecified.</span>
)</span></span>;
</div></code></pre>
<p><strong>切记比较函数的参数类型是<em>const void *</em></strong></p>
<table>
<thead>
<tr>
<th>Compare function return value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 0</td>
<td>elem1 less than elem2</td>
</tr>
<tr>
<td>0</td>
<td>elem1 equivalent to elem2</td>
</tr>
<tr>
<td>&gt; 0</td>
<td>elem1 greater than elem2</td>
</tr>
</tbody>
</table>
<p><strong>小于时返回0也行,即要升序时用return elem1&gt;elem2;</strong><br>
The array is sorted in increasing order, as defined by the comparison function. To sort an array in decreasing order, reverse the sense of &quot;greater than&quot; and &quot;less than&quot; in the comparison function.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;//极限：里面有INT_MIN,INT_MAX;</span></span>
<span class="hljs-comment">/*#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1),是一个符号而不是实际存在的数
INT_MAX + 1 = INT_MIN
INT_MIN - 1 = INT_MAX
abs(INT_MIN) = INT_MIN&lt;0
*/</span>
<span class="hljs-comment">//快排整形</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_ints</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* b)</span>
</span>{
    <span class="hljs-keyword">int</span> arg1 = *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*)a;
    <span class="hljs-keyword">int</span> arg2 = *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*)b;
 
    <span class="hljs-keyword">if</span> (arg1 &lt; arg2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">if</span> (arg1 &gt; arg2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 
    <span class="hljs-comment">// return (arg1 &gt; arg2) - (arg1 &lt; arg2); // possible shortcut,注意这种写法</span>
    <span class="hljs-comment">// return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)必须在整形范围内</span>
}
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">int</span> ints[] = { <span class="hljs-number">-2</span>, <span class="hljs-number">99</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">-743</span>, <span class="hljs-number">2</span>, INT_MIN, <span class="hljs-number">4</span> };
    <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">sizeof</span> ints / <span class="hljs-keyword">sizeof</span> *ints;<span class="hljs-comment">//*ints=ints[0];注意学习</span>
    qsort(ints, size, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), compare_ints);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ints[i]);
    }
 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-comment">//快排字符串</span>
<span class="hljs-comment">// crt_qsort.c</span>
<span class="hljs-comment">// arguments: every good boy deserves favor</span>

<span class="hljs-comment">/* This program reads the command-line
* parameters and uses qsort to sort them. It
* then displays the sorted arguments.
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg2 )</span></span>;\\把程序本身的名字赋值给argv[<span class="hljs-number">0</span>]，接着，把后面的第一个字符串赋给argv[<span class="hljs-number">1</span>]
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv )</span>
</span>{
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-comment">/* Eliminate argv[0] from sort: */</span>
   argv++;<span class="hljs-comment">//注意学习</span>
   argc--;

   <span class="hljs-comment">/* Sort remaining args using Quicksort algorithm: */</span>
   qsort( (<span class="hljs-keyword">void</span> *)argv, (<span class="hljs-keyword">size_t</span>)argc, <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">char</span> * ), compare );<span class="hljs-comment">//被排元素是字符串指针</span>
<span class="hljs-comment">//前两个类型转换可以省略</span>
   <span class="hljs-comment">/* Output sorted list: */</span>
   <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; argc; ++i )
      <span class="hljs-built_in">printf</span>( <span class="hljs-string">" %s"</span>, argv[i] );
   <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg2 )</span>
</span>{
   <span class="hljs-comment">/* Compare all of both strings: */</span>
   <span class="hljs-keyword">return</span> _stricmp( * ( <span class="hljs-keyword">char</span>** ) arg1, * ( <span class="hljs-keyword">char</span>** ) arg2 );<span class="hljs-comment">//*（**）将一般指针转化为字符串指针</span>
   <span class="hljs-comment">//stricmp相当于_stricmp的alias，是不区分大小写的strcmp，windows独有，linux下用strcasecmp替代</span>
}
</div></code></pre>
<p>cpp:algorithm</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last )</span></span>;

sort(a,a+<span class="hljs-number">10</span>);<span class="hljs-comment">//</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last, Compare comp )</span></span>;

sort(a,a+<span class="hljs-number">10</span>,compare);
sort(a,a+<span class="hljs-number">10</span>,less&lt;<span class="hljs-keyword">int</span>&gt;());
sort(a,a+<span class="hljs-number">10</span>,greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span>

</span>{
 <span class="hljs-keyword">return</span> a&gt;b;<span class="hljs-comment">//降序</span>
}
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ints = {<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>};
sort(ints.begin(), ints.end(), compare_ints);
 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ints.size(); i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ints[i]);
    }



comp:For all a, comp(a,a)==<span class="hljs-literal">false</span>
If comp(a,b)==<span class="hljs-literal">true</span> then comp(b,a)==<span class="hljs-literal">false</span>
<span class="hljs-keyword">if</span> comp(a,b)==<span class="hljs-literal">true</span> <span class="hljs-keyword">and</span> comp(b,c)==<span class="hljs-literal">true</span> then comp(a,c)==<span class="hljs-literal">true</span>

</div></code></pre>
<p>c的comp参数为（常无类型）指针，返回值为int（不支持bool），c++的comp参数为元素本身，返回值为bool。<br>
c return a&gt;b是升序，c++的是降序；</p>
<p>**快排的时间复杂度为O(nlogn);</p>
<h3 id="%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">算法和算法设计</h3>
<p><strong>算法：一个有穷的指令集。</strong></p>
<h4 id="%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7">算法的特性</h4>
<p>1，有输入：可以通过输入语句<strong>由外部显式提供</strong>，也可以<strong>由赋值或定值语句隐式提供</strong>，即 <strong>“0个输入“</strong> 情况；<br>
2，有输出；<br>
3，确定性：每一步都确切，无歧义的定义，<strong>对于一组确定的输入对应一条确定的路径运算</strong>，如果会因系统状态而导致结果不一致，则只要对于每个系统状态有确定的处理手段就不影响确定性，没赋初值导致的结果不同没有对应不同状态的处理，违反确定性。<br>
4，有穷性：<strong>初值导致算法不收敛的与算法本身无关，不违反有穷性</strong>；<br>
5，可行性：每一条运算都足够基本（<strong>可以用基本操作或调用已实现的基本算法</strong>），都能精确执行，但<strong>并不一定都与机器指令有直接关系</strong>，并<strong>能在常数时间内完成</strong>。</p>
<p>基本设计步骤：<strong>理解需求-&gt;设计思路-&gt;算法框架-&gt;程序实现</strong>；</p>
<p>算法与程序的关系：<br>
(1)算法在描述上一般使用半形式化的语言，而程序是用形式化的计算机语言描述的。<br>
(2) 程序是计算机指令的有序集合。<br>
(3)程序并不都满足算法所要求的特征，例如操作系统，是一个在无限循环中执行的程序，因而不是一个算法。<br>
(4)一个算法可以用不同的编程语言编写出不同的程序。<br>
(5)算法是解决问题的步骤；程序是算法的代码实现。<br>
(6)算法要依靠程序来完成功能；程序需要算法作为灵魂。<br>
(7)程序=算法+数据结构。</p>
<p>算法设计基本方法：</p>
<p>1，穷举法（枚举法）：&lt;1&gt;按规则列举，&lt;2&gt;盲目列举，并检查之前的列举是否重复；</p>
<p>2，迭代法（反复法）:iteration：不断用原值得到的新值代替原值，直到得到满意的解 ，新值与原值之间的关系用迭代公式表示，主要用于很难用或无法用解析法求解的计算问题，例如区间折半法求方程的根，也用来遍历表树图等数据结构。</p>
<p>3，递推法：递归的递推求解使用递归法，自顶向下，非递归的递推求解使用迭代法，自底向上；</p>
<p>4，递归法：包括自身的数据对象和调用本身的过程是递归的；递归从问题规模为n的场合开始，通过递归降低问题规模，直到递归出口，再倒推回来得到最初的值；递推是从已知条件出发；一般一个递推算法总可以转化为递归算法；例如二分法求根和求Fibonacci数两种方式的转换。但递归法不仅仅用于递推的实现（还有数据结构如链表，树图等的建立等等）。</p>
<p>递归是算法设计的基本技术，是降低分析设计难度提高程序设计效率的重要手段和工具；迭代具有更高的时空效率。</p>
<p>穷举过程中被穷举对象可能需要其他方法求解，各种方法是配合使用的。</p>
<p>算法度量</p>
<p>算法的评价标准：<br>
1，正确性；<br>
2，健壮性：在不正确输入条件下能自我保护，包括自动检错，报错，与用户对话来纠错；<br>
3，可读性；变量名，函数名要有实际意义，必须加入注释；<br>
4，高效性：主要指算法的时间代价和空间代价；<br>
5，简单性：主要用环路复杂度度量，等于程序中判断语句和子程序调用总数加一，软件工程要求不能超过10；</p>
<p>算法分析的主要方法：<strong>事后<em>估算</em>法</strong>（插入<em>测量时间语句</em>来估算）和<strong>事前<em>统计</em>法</strong>（通过对<em>问题规模，执行频度，时间，空间复杂度</em>的进行估算。<strong>主要目的是分析算法的效率以求改进</strong>。<strong>主要方面是时间性能和空间性能</strong>。</p>
<h4 id="%E6%B5%8B%E9%87%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4">测量程序运行时间</h4>
<p>clock_t start_time, end_time;给两个变量赋给当时时间，它们的差就是它们之间程序的运行时间</p>
<p>clock_t是长整形。</p>
<p>用clock()(精确到豪秒）或者time(NULL/0)（精确到秒）</p>
<p>用time直接作差即可，用clock的需要使用表达式(double)(end_time-start_time)/CLOCK_PER_SEC(每秒钟clock的增量，linux下为1000000，window下为1000)；</p>
<p>特别的sleep(x)（unisted.h)下会<strong>使linux下的clock暂停</strong>(它返回的是CPU耗费在本程序上的时间。也就是说，途中sleep的话，由于CPU资源被释放，那段时间将不被计算在内。)等待输入时clock也会暂停，<strong>带有sleep的程序运行时间精度要求不高时只能用time；windows不会</strong>；</p>
<p>window下sleep(n)单位是ms，linux下单位是s；linux下还有usleep(n),单位是um。里面乘以1000就等同于window下的sleep。</p>
<p>精确计算运行时间</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt; </span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span>  <span class="hljs-title">start_time</span>,<span class="hljs-title">end_time</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
 gettimeofday(&amp;start_time,<span class="hljs-literal">NULL</span>);
 <span class="hljs-comment">/*
 代码块
      */</span> 
gettimeofday(&amp;end_time,<span class="hljs-literal">NULL</span>); 
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lf"</span>,(end_time.tv_sec-start_time.tv_sec)+(<span class="hljs-keyword">double</span>)(end_time.tv_usec-start_time.tv_usec)/CLOCKS_PER_SEC);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}
<span class="hljs-comment">/*
gettimeofday()会把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中。
一般情况下 ，我们并不需要时区信息，所以第二个参数通常为空。
timeStart.tv_sec 这个就是秒为单位的时间戳。(double)
timeStart.tv_usec 这是当前秒中的毫秒数。(int,需要除以CLOCK_PER_SEC并转为double)；
*/</span>
</div></code></pre>
<p>C++利用<strong>chrono库</strong>也可以测量时间,可以使用更适合测量程运行时间的steady_clock()来测量。</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Timer</span>
{</span>
    <span class="hljs-built_in">std</span>::chrono::time_point&lt;<span class="hljs-built_in">std</span>::chrono::high_resolution_clock&gt; start, end;
    <span class="hljs-comment">//hign_resolution_clock是steady_clock的进阶版(系统所能提供的最精确),同时steady_clock(表在裁判手里，不能修改)相比于system_clock(表在系统手里，会被各种行为修改)更适合计时</span>
    <span class="hljs-built_in">std</span>::chrono::duration&lt;<span class="hljs-keyword">float</span>&gt; duration;
    Timer()
    {
        start = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();<span class="hljs-comment">//nm clock</span>
    }
    ~Timer()
    {
        end = <span class="hljs-built_in">std</span>::chrono::high_resolution_clock::now();
        duration = end - start;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Timer took"</span> &lt;&lt; duration.count() * <span class="hljs-number">1000</span>&lt;&lt; <span class="hljs-string">"ms"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-comment">//float型的duration是mircoseconds类型,乘1000是毫秒</span>
    }
};
<span class="hljs-comment">//在函数前面定义一个Timer对象即可计时</span>
<span class="hljs-comment">//手动计时</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;thread&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::chrono;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>::literals::chrono_literals;<span class="hljs-comment">//为sleep部分提供命名空间</span>
<span class="hljs-keyword">auto</span> begin =high_resolution_clock::now();
 this_thread::sleep_for(<span class="hljs-number">1</span>s);
<span class="hljs-keyword">auto</span> end = high_resolution_clock::now();
<span class="hljs-keyword">auto</span> duration = end - begin;<span class="hljs-comment">//auto推断得到的是 nanoseconds</span>
 <span class="hljs-keyword">double</span> ms=(<span class="hljs-keyword">double</span>)duration.count()/CLOCKS_PER_SEC;
    <span class="hljs-comment">//auto deration =duration_cast&lt;milliseconds&gt;(end-begin);//强制转换为ms，精度不如上面的方式</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; duration.count() &lt;&lt;<span class="hljs-string">"ms"</span>&lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span>&lt;&lt;ms&lt;&lt;<span class="hljs-string">"ms"</span>&lt;&lt;<span class="hljs-built_in">endl</span>;
</div></code></pre>
<p>算法的计算量的大小称为算法的<em>复杂性</em>。</p>
<h4 id="%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6complexity%E5%BA%A6%E9%87%8F%E5%92%8C%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1">算法的复杂度(complexity)，度量和问题规模</h4>
<p>问题规模从问题的描述中找到：例如在n个学生中查找和求解n阶线性方程组的问题规模都是n；</p>
<p>时间复杂度T(n)：当问题的规模从1增加到n时，解决问题的算法所耗费的时间也由1增加到T(n);</p>
<p>空间复杂度S(n):空间由1到S(n)；</p>
<p>两种度量都是问题规模n的函数，单位都是1，即单位时间(ont time unit)和单位空间都是1(ont space unit)；</p>
<p>时间复杂度度量的计算</p>
<p>算法的执行频度=每条语句的执行次数（频度）x该语句执行时间（每一条基本语句执行时间视为单位时间1，语句执行时间等于语句中基本运算语句数）=算法中所有<strong>运算语句</strong>执行频度的总和；</p>
<p>for循环控制语句的执行次数为n+1,；单位执行时间（一次执行所需语句数）为2（不包括内部），执行频度（总次数）为2(n+1)(共执行n+1次表达式2，1次表达式1，n次表达式3），循环体执行次数是n；</p>
<p>运算赋值语句是<strong>一个</strong>基本运算语句（<strong>加减乘除，转移，存取以及他们的复合</strong>），如a=b+c，return b+c，执行频度都是1；定义语句不是运算语句；</p>
<p>递归算法的执行频度可通过写出T(n)的递推形式来计算；例如T(n)=2,n&lt;=0（if判断和return）;T(n)=2+T(n-1);n&gt;0;（比上次多两次执行（if和return加和，<strong>调用函数以及return的执行次数和加和合并了，还是1</strong>）；</p>
<p>空间复杂度度量指算法所需附加存储空间，包括固定部分和可变部分（与问题规模有关）；</p>
<p>阶乘的非递归实现中，只用了一个整数存放连乘结果，附加空间数为1，空间复杂度也为1；</p>
<p>递归的空间复杂度=每次递归所要的辅助空间x递归深度</p>
<p><strong>阶乘的递归i实现中每一层递归都需要三个栈空间来存放形式参数，返回值以及返回地址</strong>（一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点）</p>
<p>递归深度是n，所以所需的栈空间是3n，空间复杂度为3n；</p>
<p>动态分配所涉及的空间复杂度 等于malloc的空间减去free的空间；</p>
<h4 id="%E6%B8%90%E8%BF%9B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">渐进的时间复杂度</h4>
<p>执行频度不能确切地反映运行时间，所以用其来比较两个程序结果不一定有价值，所以只需给出算法执行频度的数量级即可达到分析的目的。</p>
<p>大<em>O</em>表示：当且仅当存在正整数c和n_0,使得T(n)&lt;=cxf(n)对所有的n&gt;=n_0成立，则称该算法的时间增长率在<em>O</em>(f(n))中，记为T(n)=<em>O</em>(f(n)).</p>
<p>算法时间复杂度T(n)增长的上限为f(n);<em>Never to underestimate the runing time of the program.</em></p>
<p>O  函数的渐近上界 upper bound<br>
Ω 函数的渐近下界 lower dound<br>
Θ  函数的准确界</p>
<p>Θ(f(n))=T(n):存在正常数c1,c2和n0，使对所有的n⩾n0，有0⩽c1f(n)⩽T(n)⩽c2f(n) f(n)=2n^2+n,T(n)=n^2;(同阶)同速</p>
<p>O(f(n))=T(n): 存在正常数c和n0，使对所有n⩾n0，有0⩽T(n)⩽cf(n) f(n)=n^2;T(n)=2n^2+n; f(n)_rate&gt;=T(n)_rate</p>
<p>Ω(f(n))=T(n): 存在正常数c和n0，使对所有n ⩾ n0，有0⩽cf(n)⩽T(n) f(n)=n^2,T(n)=2n^2+n;f(n)_rate&lt;=T(n)_rate</p>
<p>o(f(n))=T(n): 对任意正常数c，存在常数n0&gt;0，使对所有的n⩾n0，有0⩽T(n)⩽cf(n) T(n)=O(f(n))&amp;&amp;T(n)!=Ω(f(n));f(n)=2n^2+n;T(n)=2n;</p>
<p>f(n)_rate&gt;T(n)_rate</p>
<p>lim(T(n)/f(n))=<em>lim(T'(n)/f'(n))</em>(n-&gt;inf):1,==c:Θ(f(n))=T(n);2,-&gt;inf:o(T(n))=f(n);3,==0;o(f(n))=T(n);</p>
<p>Thus T(n)=n^2=O(n^2)=O(n^3),the first option is the best answer.</p>
<p>一般情况下O就是指Θ，前者范围更广所以一般用前者表示。</p>
<p>If T(N)is a polynomial(/ˌpɑːliˈnoʊmiəl/ 多项式) of degree k(equal to k-order),then T(N)= Θ(N^k);</p>
<p><strong>Lower-order terms</strong> can generally be ignored,and the <strong>constants</strong> can be throw away.</p>
<p>If T1(n) = O(F(N)) and T2(N) = O(g(N)),then<br>
(a),T1(N)+T2(N) = max{O(f(N)),O(g(N))}<br>
(b),T1(N)*T2(N) = O(f(N)*g(N)).</p>
<p>When n is sufficiently large, the growth of various functions has the following relationship:</p>
<p>c &lt;      log2n &lt; (log2n)^k&lt;n &lt; nlog n &lt; n^2 &lt;    n^3 &lt; 2^n &lt; 3^n &lt;   n!  &lt;n^n</p>
<p>Constant logarithmic      Linear     Quadratic   Cubic  Exponential  factorial<br>
/ˌekspəˈnenʃl/<br>
The logarithms grow very slowly.</p>
<p>$$<br>
\log_{k_1} n&lt;n^{k_2}&lt;{k_3}^n(k_1,k_2&gt;0,k_3&gt;1)<br>
$$</p>
<p>the rate of <strong>logarithm slower than power slower than exponient,there is no power function between n and nlogn.</strong></p>
<p>such as :</p>
<p>$$<br>
N^{1+\frac{\varepsilon}{\sqrt{\log n}}}&lt;N\log N<br>
$$</p>
<p><strong>O(log2n)可以简记为O(logn);由换底公式知不同底数的对数阶只差了常数倍，n(log2n)也满足</strong>.</p>
<p><strong>for loop statement</strong>:The total running time of a statement（语句） inside a group of nested loops(嵌套循环) is the running time of statement multiplied by the product（乘积） of the size of all the for loops;</p>
<p><strong>if/else statement</strong>:time of <em>test</em> plus the <em>lager</em> of the running time of S1 and S2.</p>
<p>函数或语句嵌套的相乘，并列的取最大。</p>
<p>计算递归的时间复杂度时，简单的可以直接当作for循环来看，复杂的通过递推式计算，结束递归那一步的执行频度如果是c可以简化为1，递推式中的常数必须严格按其执行频度来，例如裴波那契数列递归式是T(n)=T(n-1)+T(n-2)+2(if和return那一句)，n=1,2时看作1还是2无所谓。</p>
<h4 id="markdown-%E8%AF%AD%E6%B3%95">markdown 语法</h4>
<p><a href="https://www.cnblogs.com/wuxero/p/14171220.html">markdown数学公式</a></p>
<p><a href="https://latex.codecogs.com/eqneditor/editor.php">在线生成</a></p>
<pre class="hljs"><code><div>图片:超链接的格式前加!
一个行内，两个行外；_下标，^上标 逻辑上的括号:{}
分数：\frac{}{}
方程组：\begin{cases} \\ \\ \\ \end{cases}
求和:\sum_{i=<span class="hljs-number">0</span>}^k;
连乘:\prod_{i=<span class="hljs-number">0</span>}^n
换行\\,空格\;
箭头\rightarrow
自适应括号\left( \right)
\<span class="hljs-built_in">sqrt</span>{}
大于等于：\geq;
属于 \in 
小于等于：\leq; 
不等于：\neq;
$\lfloor x \rfloor$向下取整；
$\lceil x \rceil$向上取整

行内:一个\$,或**ctrlM**行外两个\$,

有两种省略号，\ldots 表示语文本底线对其的省略号，\cdots表示与文本中线对其的省略号。

\cap:∩ \bigcap \cup ∪  $

</div></code></pre>
<p>$$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$$</p>
<p>注意竖线与内容间的空格和标题与内容的分割线,不需要用$包围</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>JavaScript</td>
<td>js</td>
</tr>
<tr>
<td>Python</td>
<td>py</td>
</tr>
<tr>
<td>C++</td>
<td>cpp</td>
</tr>
<tr>
<td>“：”：决定对齐方式</td>
<td></td>
</tr>
<tr>
<td>题号</td>
<td>标题</td>
</tr>
<tr>
<td>:---</td>
<td>---:</td>
</tr>
<tr>
<td>1</td>
<td>两数之和</td>
</tr>
<tr>
<td>15</td>
<td>三数之和</td>
</tr>
<tr>
<td>262</td>
<td>行程和用户</td>
</tr>
</tbody>
</table>
<h4 id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B%E9%A2%98">时间复杂度例题</h4>
<h5 id="%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97">循环嵌套</h5>
<pre class="hljs"><code><div>{
<span class="hljs-keyword">int</span>  i,j,k,x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=j;k++)
x=x+y;
}
</div></code></pre>
<p>$$<br>
T(n) = \sum_{i=1}^n \sum_{j=1}^i  \sum_{k=1}^j = \sum_{i=1}^n \sum_{j=1}^i j = \sum_{i=1}^n \frac{i(i+1)}{2} =\ \frac{1}{2}\times\frac{n(n+1)(2n+1)}{6}+\frac{1}{2}\times\frac{n(n+1)}{2} = \frac{n(n+1)(n+2)}{6}\<br>
\sum_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}\ \sum_{i=1}^n i^3=\left(\sum_{i=1}^n i\right)^2;\<br>
\sum_{i=0}^n f(n-i)=\sum_{i=0}^n f(i)<br>
$$</p>
<pre class="hljs"><code><div>{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
    </span>{
    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,s=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(s&lt;n)
    s+=++i;
    <span class="hljs-keyword">return</span> i
    }
}
第一轮 ：s=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>;第二轮：s=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>；第n轮：s=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+...+i;
</div></code></pre>
<p>跳出循环时，函数执行次数i满足$\frac{n(n- 1)}{2}\geq n$;即 $i^2-i-2n\geq0$,解得$i\geq\frac{1\pm\sqrt{1+8n}}{2}$.故时间复杂度为$O(\sqrt{n}$);</p>
<p>Find the maximum of subsequence(substring) sum in A[n]:{A0,A1,...An};</p>
<p>$$<br>
\sum_{k=i}^jA_k<br>
$$</p>
<pre class="hljs"><code><div>Algorithm <span class="hljs-number">1</span> 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> ThisSum,Maxsum,i,j,k;
    Maxsum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)
    <span class="hljs-keyword">for</span>(j=i;j&lt;N;j++)
    {
        ThisSum=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(k=i;k&lt;=j;k++)
        ThisSum+=A[k];
        <span class="hljs-keyword">if</span>(ThisSum&gt;Maxsum)
        Maxsum=ThisSum;
    }
    <span class="hljs-keyword">return</span> Maxsum;
}
</div></code></pre>
<p>$$<br>
\sum_{i=0}^N \sum_{j=i}^N \sum_{k=i}^j = \frac{N^3+3N^2+2N}{6}<br>
$$</p>
<p>evaluated inside out（由内到外计算）</p>
<p>求内层变量和时外层的变量当常量对待。</p>
<p><strong>时间复杂度为O(n^3);不需要精确计算时可以通过三层循环的次数都小于等于n得到结果；</strong></p>
<pre class="hljs"><code><div>Algorithm2:
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> ThisSum,Maxsum,i,j,k;
    Maxsum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)
    {
        ThisSum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(j=i;j&lt;N;j++)
    {
       ThisSum+=A[j]；
        <span class="hljs-keyword">if</span>(ThisSum&gt;Maxsum)
        Maxsum=ThisSum;
    }
    }
    <span class="hljs-keyword">return</span> Maxsum;
}
<span class="hljs-function">clearly is <span class="hljs-title">O</span><span class="hljs-params">(n^<span class="hljs-number">2</span>)</span>；
</span></div></code></pre>
<h5 id="%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB">递归，分治</h5>
<pre class="hljs"><code><div>Algorithm3:

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-8</span>};
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, MaxSubSum(a, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span>
</span>{
    <span class="hljs-keyword">if</span> (a &gt; b)
        <span class="hljs-keyword">return</span> a;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt; b)
        <span class="hljs-keyword">return</span> c;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> b;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Ri ght)</span>
</span>{
    <span class="hljs-keyword">int</span> MaxLeftSum, MaxRightSum;
    <span class="hljs-keyword">int</span> MaxLeftBorderSum, MaxRightBorderSum;
    <span class="hljs-keyword">int</span> LeftBorderSum, RightBorderSum;
    <span class="hljs-keyword">int</span> Center, i;
    <span class="hljs-keyword">if</span> (Left == Right)<span class="hljs-comment">//递归返回终点</span>
        <span class="hljs-keyword">if</span> (A[Left] &gt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> A[Left];
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    Center = (Left + Right) / <span class="hljs-number">2</span>;
    MaxLeftSum = MaxSubSum(A, Left, Center);<span class="hljs-comment">//递归计算两边的最大子列和，分治思想体现。</span>
    MaxRightSum = MaxSubSum(A, Center + <span class="hljs-number">1</span>, Right);
    MaxLeftBorderSum = <span class="hljs-number">0</span>;
    LeftBorderSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i = Center; i &gt;= Left; i--)
    {
        LeftBorderSum += A[i];
        <span class="hljs-keyword">if</span> (LeftBorderSum &gt; MaxLeftBorderSum)
            MaxLeftBorderSum = LeftBorderSum;
    }
    MaxRightBorderSum = <span class="hljs-number">0</span>;
    RightBorderSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i = Center + <span class="hljs-number">1</span>; i &lt;= Right; i++)
    {
        RightBorderSum += A[i];
        <span class="hljs-keyword">if</span> (RightBorderSum &gt; MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum;
    }
    <span class="hljs-keyword">return</span> Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
               <span class="hljs-comment">// 最大值在这三个值里产生</span>
}
</div></code></pre>
<p>The algorithm uses a &quot;divide-and-conqure&quot;(分治) strategy.The idea is spit the problem into two roughly equal subproblems,which are the solved recursively.</p>
<p>An Algorithm is<strong>O(log(N))<strong>if it takes constant(O(1))time to <strong>cut the problem size by a <em>fraction</em></strong>(which is usually 1/2).On the other hand,if constant time is required to merely <strong>reduce the problem by a <em>constant amount</em></strong>(such as make the problem smaller by 1),then the algorithm is</strong>O(N)</strong>.</p>
<p>$$<br>
\begin{cases} T(n)=T(n/2)+O(1)\rightarrow T(n)=kO(1)=O(1)\log n=O(\log n)\ T(n)=2T(n/2)+O(1)\rightarrow T(n)=2^k+kO(1)=n+O(1)\log n=O(n)\ T(n)=2T(n/2)+O(n)\rightarrow T(n)=2^k+n+\frac{n}{2}\times2+\cdots=2^k+n\times k\=n+n\log n=O(n\log n)\ \end{cases}<br>
$$</p>
<p>Simple intuition obviates the need for a brute-force approach.</p>
<p><em>接收n个数据至少需要O(N)的复杂度，故O(logN)是针对对应函数而不是程序整体说的。</em></p>
<p><strong>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</strong></p>
<p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解这种算法设计策略叫做分治法。</p>
<p>如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<pre class="hljs"><code><div><span class="hljs-function">Algorithm4
<span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> ThisSum,Maxsum,j;
    ThisSum=MaxSum=<span class="hljs-number">0</span>;Maxsum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;N;j++){
        ThisSum+=A[j];
        <span class="hljs-keyword">if</span>(ThisSum&gt;MaxSum)<span class="hljs-comment">//ThisSum大于零时更新（段内回撤不大不影响本金，长期持有）</span>
        MaxSum= ThisSum;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ThisSum&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//小于零后对后面部分的增长没有作用(回撤过大，割肉跑路），断开重新计算下一段的最大和</span>
        ThisSum=<span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> Maxsum;
}

</div></code></pre>
<h5 id="binary-search%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">Binary Search(二分查找)</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//A[N] has presorted（一次排序，永远方便，需要多次查找的都可以这样搞）</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(Const ElementType A[],ElementType X,<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> Low,Mid,High;
    Low=<span class="hljs-number">0</span>;High=N<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">while</span>(Low&lt;=High)
    {
        Mid=(Low+High)/ <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(X&gt;A[Mid])
        Low=Mid+<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">if</span>(X&lt;A[Mid])
        High=Mid<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> Mid;<span class="hljs-comment">//Found</span>
    }
    <span class="hljs-keyword">return</span> NotFound<span class="hljs-comment">//is defined as -1;</span>
}
每次循环使问题的规模减小一倍，故时间复杂度是O(logn);
</div></code></pre>
<h5 id="%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%BB%A5%E5%8F%8A-%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%A0%B9">最大公约数和最小公倍数以及 二分法求根</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GCD</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a , <span class="hljs-keyword">int</span> b )</span><span class="hljs-comment">//辗转相除法(Greatest Common Divisor)</span>
</span>{
    <span class="hljs-keyword">int</span> temp;
    <span class="hljs-keyword">if</span>(!(a%b))
    { <span class="hljs-keyword">return</span> b;<span class="hljs-keyword">break</span>;}
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> GCD(b,a%b);<span class="hljs-comment">//除数除余数</span>
}
<span class="hljs-comment">//都不用判断a，b大小，如果a&lt;b,第一次递归或迭代会交换他们。</span>
迭代写法（推荐）：
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GCD</span><span class="hljs-params">(<span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> N)</span> <span class="hljs-comment">//(Euclid's algorithm)</span>
</span>{
    <span class="hljs-keyword">int</span> Rem;
    <span class="hljs-keyword">while</span>(N&gt;<span class="hljs-number">0</span>)
    {
        Rem=M%N;
        M=N;
        N=Rem;
    }
    <span class="hljs-keyword">return</span> M;
}

</div></code></pre>
<p><strong>if M&gt;N,then M mod N &lt; M/2;(If N&lt;=M/2,then remainder is smaller than N;if N&gt;M/2,then remainder is M-Nalso smaller than M/2);</strong></p>
<p>考虑(a,b)$\rightarrow$(b,a mod b)这个迭代，有两种情况：<br>
1，如果a&gt;b,那么迭代两次后得到(a mod b,b mod (a mod b)),<br>
有a mod b &lt; $\frac{a}{2}$, b mod (a mod b) &lt; $\frac{b}{2}$,<br>
即迭代两次后问题的规模减小一倍；<br>
2，如果a&gt;b,迭代一次后归入情况a，至多出现一次，可以忽略。<br>
故其时间复杂度为 $2\log n=O(\log n)$;</p>
<pre class="hljs"><code><div>
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span>更相减损术
</span>{
    <span class="hljs-keyword">if</span>(m&gt;n)
    <span class="hljs-keyword">return</span> gcd(m-n,n);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n&gt;m)
    <span class="hljs-keyword">return</span> gcd(m,n-m);<span class="hljs-comment">//大数减小数</span>
    <span class="hljs-keyword">else</span> 
    <span class="hljs-keyword">return</span> m;
}
</div></code></pre>
<p>设gcd(a,b)=c,lcm(a,b)=d，即ab的最大公因数为c，最小公倍数为d，则一定有a=k1*c ， b=k2*c （1）      a=d/t1       b=d/t2   （2）,其中k1,k2必然互质（反证法：假设k1，k2不互质，则必定有一个大于1的最大公因数，设其为x，则有a=k1/x * xc, b=k2/x * xc,此时k1/x和k2/x已经互质，但是明显a和b有一个公因数xc,又因为x&gt;1，则xc&gt;c，和前提ab的最大公因数c矛盾，则k1,k2必然互质，同理可证t1,t2互质）</p>
<p>对于（1）式，可有b/a=k2/k1.对于（2）式，可有b/a=t1/t2,即k2/k1=t1/t2,定有常数y,使得k2=y*t1,k1=y*t2,即k2/k1=y*t1/y*t2=t1/t2,</p>
<p>而k2和k1是互质的，y只能为1，所以k2=t1,k1=t2,而k1=a/c,t2=d/b,所以a/c=d/b,即ab=cd，证毕</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span>
</span>{
    <span class="hljs-keyword">return</span> a3*(x)*(x)*(x)+a2*(x)*(x)+a1*(x)+a0;
}
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">isroot</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span>  b)</span>
</span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(f((a+b)/<span class="hljs-number">2</span>))&lt;<span class="hljs-number">1e-6</span>)<span class="hljs-comment">//也可用区间长度作为控制精度结束条件</span>
        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span>(f((a+b)/<span class="hljs-number">2</span>)*f(a)&lt;<span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> isroot(a,(a+b)/<span class="hljs-number">2</span>);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> isroot((a+b)/<span class="hljs-number">2</span>,b);

</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//Exponentiation:</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span>)<span class="hljs-comment">//unneceaaary</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(IsEven(N))
    <span class="hljs-function">retuen <span class="hljs-title">Pow</span><span class="hljs-params">(x*x,N/<span class="hljs-number">2</span>)</span></span>;
    <span class="hljs-keyword">else</span>
    retuen Pow(x*x,N/<span class="hljs-number">2</span>)*x;
}
O(<span class="hljs-built_in">log</span> N)


</div></code></pre>
<h5 id="%E6%B1%89%E8%AF%BA%E5%A1%94">汉诺塔</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> A, <span class="hljs-keyword">char</span> B, <span class="hljs-keyword">char</span> C)</span><span class="hljs-comment">//盘子数量，初始轴，中间轴，目标轴；</span>
</span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-comment">//!最频繁的操作，是两个递归调用的终止条件</span>
    {
        move(<span class="hljs-number">1</span>,A, C);
        <span class="hljs-keyword">return</span>;<span class="hljs-comment">//或else</span>
    }
    hanoi(n - <span class="hljs-number">1</span>, A, C, B);<span class="hljs-comment">//将A上面n-1个移动到B</span>
    move(n,A, C);<span class="hljs-comment">//将A上最后一个最大的移动到C，也是移动每个子递归上最大的；</span>
    hanoi(n - <span class="hljs-number">1</span>, B, A, C);<span class="hljs-comment">//将中间轴B上的移动到C</span>
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span> A, <span class="hljs-keyword">char</span> C)</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; m++&lt;&lt;<span class="hljs-string">':'</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">"from"</span> &lt;&lt; A &lt;&lt; <span class="hljs-string">" to"</span> &lt;&lt; C &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p><img src="https://pic2.zhimg.com/80/v2-0f0904276be548357ae841fe137230d1_1440w.jpg" alt="a"><br>
先从左边三号节点进入，到最左边的一号节点开始逐层退出递归，全部退出后执行节点4，然后从右边三号节点进入到其左下角的一号节点开始逐层退出递归。</p>
<p>$$<br>
T(n)=2T(n-1)+k\rightarrow T(n)=2^n<br>
$$</p>
<h5 id="%E9%9A%8F%E6%9C%BA%E7%BD%AE%E6%8D%A2%E6%95%B0%E7%BB%84">随机置换数组</h5>
<pre class="hljs"><code><div>Algorithm1:
<span class="hljs-keyword">int</span> A[MAXN] = {<span class="hljs-number">0</span>},i,j,temp;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; )
    {
        srand(time(<span class="hljs-literal">NULL</span>));
        temp = rand() % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i; j++)
        {
            <span class="hljs-keyword">if</span> (temp == A[j])
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span>(j==i)
        A[i++]=temp;
    }

</div></code></pre>
<p>The expected number of random numbers that need to be tried is N/(N-i), This is obtained as follows: i of the N numbers would be duplicates.Thus the probability of success is N-i/N(if成功的概率); Thus the expected number of independent trials  is N/N-i（if 成功一次所需的次数）;在x次独立重复事件中，该事件发生xp次；所以该事件发生一次的概率是1/p（两边同除以xp)<br>
The time bound is thus:</p>
<p>$$<br>
\sum_{i=0}^{i-1} \frac{Ni}{N-i} &lt; \sum_{i=0}^{N-1} \frac{N^2}{N-i}=N^2\sum_{i=0}^{N-1} \frac{1}{N-i}=\sum_{j=1}^N \frac{1}{j}=N^2\log N<br>
$$</p>
<p>The time bound is thus</p>
<pre class="hljs"><code><div>Algorithm2:

<span class="hljs-keyword">int</span> A[MAXN] = {<span class="hljs-number">0</span>},Used[MAXN]={<span class="hljs-number">0</span>},i,j,temp;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; )
    {
        srand(time(<span class="hljs-literal">NULL</span>));
       temp=rand()%MAXN+<span class="hljs-number">1</span>;
       <span class="hljs-keyword">if</span>(!Used[temp<span class="hljs-number">-1</span>])
       {
           A[i++]=temp;Used[temp<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;
       }
  
    }
</div></code></pre>
<p>Obviously time complexity is O(nlogn);</p>
<pre class="hljs"><code><div>Algorithm3:
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)
    {
        A[i] = i + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)
    {
        srand(time(<span class="hljs-literal">NULL</span>));
        swap(A[i], A[rand() % (i+<span class="hljs-number">1</span>)]);
    }

</div></code></pre>
<p>The worst-case running time of algorithms I and II <strong>cannot be bounded</strong>because there is always a <strong>finite probability</strong> that the program <strong>will not terminate by some given time TO</strong>. The algorithm does, however, terminate with probability 1. <strong>The worst-case running time of the third algorithm is linear</strong> - its running time does not depend on the sequence of random numbers.</p>
<h2 id="%E7%BA%BF%E6%80%A7%E8%A1%A8list">线性表(List)</h2>
<h3 id="%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9">定义和特点</h3>
<p>L       =     (a1, a2, a3,...,an).<br>
表名           首元(head)      尾元(tail)  ai：结点（数据元素） 没有元素时是空表。</p>
<p>要点：</p>
<p>1，表中元素具有逻辑上的顺序性；</p>
<p>2，表中元素个数有限；</p>
<p>3，表中元素都是数据元素（<strong>不可分</strong>）；</p>
<p>4，元素的数据类型都相同（<strong>等价类型变量（union）也可以</strong>）；</p>
<p>5，表中元素具有抽象性。</p>
<h3 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8">顺序表</h3>
<p><strong>线性表的顺序存储</strong>.</p>
<p><a href="/home/fengsc/Desktop/cpp/DataStructure/SeqList">源代码位置</a></p>
<h4 id="%E5%AD%98%E5%82%A8">存储</h4>
<p><strong>动态存储结构就是在程序运行期间动态的分配内存。一维数组既可以动态存储也可以静态存储</strong>.</p>
<pre class="hljs"><code><div>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxSize 30<span class="hljs-comment">//静态存储</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> DataType;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
    DataType data[maxSize];
    <span class="hljs-keyword">int</span> n;
}  Seqlist;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxSize 30<span class="hljs-comment">//动态存储</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> DataType;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
    DataType *data;
    <span class="hljs-keyword">int</span> n;
}  Seqlist;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initList</span><span class="hljs-params">(Seqlist &amp;L)</span>
</span>{
L.Data=(DataType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DataType));
<span class="hljs-keyword">if</span>(!L.Data)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DataType));
<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
L.Maxsize=InitSize;
L.n=<span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0">顺序表查找时的平均比较次数</h4>
<p>$$<br>
ACN=\sum_{i=1}^n p_i\times c_i=\sum_{i=1}^n \left( \frac{1}{n} \right) \times i=\frac{1}{n}\sum_{i=1}^n i=\frac{1}{n}\times\frac{(1+n)n}{2}=\frac{1+n}{2}<br>
$$</p>
<p>$p_i:\frac{1}{n}$：查找对象为某个元素的平均概率;$c_i: i$：顺序查找某个元素所要比较的次数</p>
<p>最小是1，最多是n；</p>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8F%92%E5%85%A5%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0">顺序表插入时的平均移动次数</h4>
<p>$$<br>
AMN=\frac{1}{n+1}\sum_{i=1}^{n+1} \left( n-i+1 \right) =\frac{1}{n+1}\times \frac{n(n+1)}{2}= \frac{n}{2}<br>
$$</p>
<p>移动第ℹ-1到第n-1位置间共n-i+1个元素，最少移动0次，在第n+1个位置插入；最多移动n次，在第一个位置插入。</p>
<p>不要求顺序时可以直接插在后面。</p>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0">顺序表删除时的平均移动次数</h4>
<p>$$<br>
AMN=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{1}{n}\times \frac{n(n-1)}{2}= \frac{n-1}{2}<br>
$$</p>
<p>把第i到第n-1共n-i个元素顺序前移，最少移动0个，最多移动n-1个。</p>
<p>不要求顺序时可以直接将最后一个元素覆盖要删除的元素。</p>
<p><strong>各种操作的时间复杂度都是O（N），大小都是二分之最小加最大</strong>.</p>
<p>顺序表的缺陷：在插入和删除时需要频繁的执行成块的数据移动，所以主要用于不经常插入或删除的应用程序，它具有<strong>直接存取</strong>的特性。</p>
<hr>
<h3 id="%E9%93%BE%E8%A1%A8linked-list">链表（Linked List）</h3>
<p><a href="/home/fengsc/Desktop/cpp/DataStructure/LinkedList">相关程序源文件位置</a></p>
<h4 id="%E5%8D%95%E9%93%BE%E8%A1%A8singly-linked-list">单链表（Singly Linked List）</h4>
<p><strong>也叫线性链表或单链表，是线性表的链接存储表示</strong>.</p>
<p>结构：为元素附加指针形成一个个结点（<em>node</em>），通过指针将各个数据元素按其逻辑顺序勾连起来，结点包括数据域（<em>data</em>）和指针域（链域）（<em>link</em>）；第一个结点称为首元结点(表头指针指向），没有前置结点(predeceor).可以通过头指针(<em>Header/Dummyhead</em>)（有利于插入删除首元节点）找到，最后一个结点称为尾元结点（表尾指针指向），没有后继结点(<em>successor</em>);</p>
<p><strong>一般用带头结点的，递归函数一般用不带头结点的，不带头结点更为简洁和通用</strong>.</p>
<p>添加头结点：*header = new ListNode(head);注意利用结构体里的构造函数。</p>
<p><strong>链表非引用传入的指针只能改变它们之后的结点，如果不用返回值，而其本身结点需要改变，可以解引用赋值浅拷贝，也可以用成员运算符深拷贝，一般用前者即可。</strong></p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveByValWithoutReferAndHeader</span><span class="hljs-params">(LinkList Head, DataType x)</span> <span class="hljs-comment">//形参和实参唯一的区别是地址不同，它们连接着同一条链表，都可以改变首元结点</span>
</span>{
    LinkList *pcur = &amp;Head, p, phead = Head;<span class="hljs-comment">//保留原首元节点指针</span>
    <span class="hljs-keyword">while</span> (p = *pcur)
    {
        <span class="hljs-keyword">if</span> (p-&gt;data == x)
        {
            *pcur = p-&gt;next;
            <span class="hljs-built_in">free</span>(p);
        }
        <span class="hljs-keyword">else</span>
            pcur = &amp;p-&gt;next;
    }
    *phead = *Head;<span class="hljs-comment">//更新首元结点</span>
    <span class="hljs-comment">/*phead-&gt;next=head-&gt;next;
    phead-&gt;data=head-&gt;data;*/</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    DataType data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">Next</span>;</span>
     Node(<span class="hljs-keyword">int</span> val) :data(val),next(<span class="hljs-literal">nullptr</span>) {}
     Node(Node *ptr):next(ptr){}
    Node():data(<span class="hljs-number">0</span>),next(<span class="hljs-literal">nullptr</span>) {}

    Node(<span class="hljs-keyword">int</span> val,node* ptr):data(val),next(<span class="hljs-literal">nullptr</span>){}
}LinkNode,*LinkList;
p=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode))=<span class="hljs-keyword">new</span> LinkNode=<span class="hljs-keyword">new</span> LinkNode()=<span class="hljs-keyword">new</span> LinkNode(<span class="hljs-number">0</span>)=<span class="hljs-keyword">new</span> LinkNode(<span class="hljs-number">0</span>,<span class="hljs-literal">nullptr</span>)=<span class="hljs-keyword">new</span> Node(**);<span class="hljs-comment">//可以用别名也可以用结构体名,类也一样</span>

</div></code></pre>
<h4 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C%E9%93%BE%E8%A1%A8">二级指针操作链表</h4>
<pre class="hljs"><code><div> LinkList *cur = &amp;Head, p;<span class="hljs-comment">//注意取地址符和引用的区别</span>
    <span class="hljs-keyword">while</span> (p = *cur)
    {
        <span class="hljs-keyword">if</span> (p-&gt;data == x)
        {
            *cur = p-&gt;next;<span class="hljs-comment">/*通过当前结点的指针（pred-&gt;next）的地址直接改变当前结点指针，直接赋值会使结点脱离（操作对象只是个中间变量P），所有需要维护或通过前置结点进行的操作例如插入，删除等都可以这样，也可以同时使操作不再依赖头结点（当然一般情况还是优先加头结点），频繁的插入删除优先采用此方法，注意指针起始地址，从首元结点开始：&amp;head,从头结点开始:&amp;header-&gt;next(!=&amp;head)*/</span>
            <span class="hljs-built_in">free</span>(p);
        }
        <span class="hljs-keyword">else</span>
            cur = &amp;p-&gt;next;<span class="hljs-comment">/*cur=&amp;(*cur)-&gt;next;'-&gt;','.'优先级最高，'&amp;'，'*'其次，取得链表结点指针的地址而不是中间指针变量的地址*/</span>
    }
  {
 LinkList *pcur = &amp;Head;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter "</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">"datas"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">while</span> (num--)
    {
        LinkList cur = <span class="hljs-keyword">new</span> LinkNode;
        <span class="hljs-keyword">if</span> (!cur)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Memory allocation failed"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
        }
        <span class="hljs-built_in">cin</span> &gt;&gt; cur-&gt;data;
        *pcur = cur;
        pcur = &amp;cur-&gt;next;
    }
    *pcur = <span class="hljs-literal">nullptr</span>;
  }
  <span class="hljs-comment">/*注意辨析*pcur=(*pcur)-&gt;next(删除结点),pcur=&amp;(*pcur)-&gt;next(移动结点，底层，借助指针地址)与cur=cur-&gt;next（移动结点，表面，借助中间变量）*/</span>
</div></code></pre>
<h4 id="%E5%88%A4%E6%96%AD%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4"><a href="https://blog.csdn.net/fengxinlinux/article/details/78885764">判断环和相交</a></h4>
<p>$$ 2(a+b)=a+b+kr,a+b=kr;a=kr-b=(k-1)r+r-b \a：环入口到表头的距离，b:环入口到两指针第一次相遇结点的距离 $$</p>
<p>当慢指针从表头移动a次后快指针也将到达环的起点。</p>
<pre class="hljs"><code><div><span class="hljs-function">LinkNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(LinkNode *head)</span> </span>{
         LinkNode *slow = head, *fast = head;
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">if</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; (fast = fast-&gt;next-&gt;next))
            {
                slow = slow-&gt;next;
                <span class="hljs-keyword">if</span> (fast == slow)
                    <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
        }
        slow=head;
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">if</span>(fast == slow)
            <span class="hljs-keyword">return</span> fast;
            slow= slow-&gt;next;
            fast= fast-&gt;next;
        }
        
    }
</div></code></pre>
<pre class="hljs"><code><div>      ListNode *p = headA, *q = headB;
        <span class="hljs-keyword">int</span> gap = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (p || q)
        {
            <span class="hljs-keyword">if</span> (!(p &amp;&amp; q))
            {
                flag = p ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">//标记较长串</span>
                gap++;<span class="hljs-comment">//长度差值</span>
            }
            <span class="hljs-keyword">if</span> (p)
                p = p-&gt;next;
            <span class="hljs-keyword">if</span> (q)
                q = q-&gt;next;
        }
        flag ? (p = headA, q = headB) : (p = headB, q = headA);
        <span class="hljs-keyword">while</span> (gap--)
            p = p-&gt;next;
        <span class="hljs-keyword">while</span> (p != q)
        {
            p = p-&gt;next;
            q = q-&gt;next;
        }
        <span class="hljs-keyword">return</span> p;

</div></code></pre>
<pre class="hljs"><code><div>    fast=slow=head;
    <span class="hljs-keyword">while</span> (fast&amp;&amp; fast-&gt;next){<span class="hljs-comment">//find mid node</span>
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
</div></code></pre>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83">顺序表和线性链表的比较</h4>
<h5 id="%E5%AD%98%E5%82%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E6%AF%94%E8%BE%83">存储方面的比较</h5>
<p>（1）存储利用率：</p>
<p>$$存储密度=\frac{数据结构占用的存储字节数}{为结构分配的最大字节数}$$<br>
顺序表的存储密度为1，利用率很高；单链表小于1，数据元素需要附加指针指示元素之间的逻辑关系，利用率较差；</p>
<p>（2）空间限制：</p>
<p>顺序表只有在动态分配内存时可以扩充，但存储开销和时间开销大，效率低；单链表随用随申，一般没有存储溢出的问题，空间限制小；</p>
<p>（3）存储的占用方式：</p>
<p>顺序表的存储空间不随表的操作改变，事先估计不足或过大都会造成问题；链表占用空间随用随变，很灵活。</p>
<h5 id="%E5%AD%98%E5%8F%96%E6%96%B9%E9%9D%A2%E7%9A%84%E6%AF%94%E8%BE%83">存取方面的比较</h5>
<p>（1）存储结构特点：</p>
<p>顺序表用物理关系上的邻接关系来表示结点间的逻辑关系，结构简单；链表元素的物理存储位置和逻辑链接关系不一定一致；链表<strong>结点间的存储一般是不连续的</strong>，但<strong>链表结点内部的存储空间是连续的</strong>。</p>
<p>（2）访问方式：</p>
<p>顺序表可以从前往后或从后往前或按下标存取，链表只能沿着指针逐个节点存取，顺序表查找比链表快；</p>
<p>（3）插入删除速度：</p>
<p>顺序表平均要移动一半元素，链表只需要修改链接指针，无需移动元素；</p>
<p><strong>如果表头指针被保护，单链表的安全保密性比顺序表好</strong>.</p>
<p><strong>顺序表适合频繁查找，不适合频繁插入删除，链表反之。</strong></p>
<p><strong>其他链表的逻辑结构也是线性表</strong>.</p>
<h2 id="%E6%A0%88stack%E5%92%8C%E9%98%9F%E5%88%97queue">栈(Stack)和队列(Queue)</h2>
<p><strong>栈，队列和双端队列的逻辑结构与线性表相同，但有更多限制(restrictions)，称为运算受限的线性表或限制了存取点的线性表</strong>.</p>
<h3 id="%E6%A0%88">栈</h3>
<p><a href="../DataStructure/Stack/Stack.cpp">相关文件位置</a></p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeqStack</span>
{</span>
    <span class="hljs-keyword">public</span>:
    DataType *elem;
    <span class="hljs-keyword">int</span> maxSize, top;
    SeqStack(<span class="hljs-keyword">int</span> size) : maxSize(size), top(<span class="hljs-number">-1</span>), elem(<span class="hljs-keyword">new</span> DataType[size]) {}
    SeqStack(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;DataType&gt; &amp;value) <span class="hljs-comment">//利用vector初始化</span>
    {
        maxSize = value.size();
        top = maxSize - <span class="hljs-number">1</span>;
        elem = <span class="hljs-keyword">new</span> DataType[maxSize];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; maxSize; i++)
            elem[i] = value[i];
    }
    ~SeqStack() { <span class="hljs-keyword">delete</span>[] elem; }<span class="hljs-comment">//释放内存</span>
} ;
</div></code></pre>
<h4 id="%E5%9F%BA%E6%9C%AC">基本</h4>
<p><strong>可定义为只允许在表的末端进行插入和删除操作的线性表(LIFO,Last In First Out)，允许操作的一端叫栈顶(top),另一端叫栈底(bottom),没有元素时叫空栈，主要操作是Pop(出栈)和Push(进栈)</strong>.</p>
<p>栈空时退栈要进行<strong>栈空处理</strong>，栈满时入栈要进行<strong>栈满处理</strong>，它们<strong>不是出错处理</strong>，而是使用这个栈的算法结束时需要执行的处理(It's an implementation error but not an ADT error)</p>
<p>栈的基本性质：(1):集合性；(2):线性；(3):运算受限；(4):数学性质；</p>
<p>栈在生命周期内的状态:栈满，栈空，栈半满；可能的操作：进栈（入栈），出栈（退栈），置空；</p>
<p>合理的S/X序列满足:(1):最终S==X;(2):任意状态S&gt;=X;</p>
<p>顺序栈的优点是<strong>存取速度快，插入，删除方便</strong>；缺点是<strong>容量不好把握，空间利用率底,多栈共享空间时效率低</strong>。</p>
<p>链栈的优点是<strong>插删方便，不存在栈满的问题，同时使用多栈时效率高，便于共享空间</strong>。缺点是<strong>需要额外空间存放指针域</strong>。</p>
<p>单调栈不一定是栈内的元素本身单调，也可能是储存的数组下标对应的元素单调，这样存储的信息更多。注意数组最后<strong>哨兵</strong>的添加。</p>
<h4 id="%E6%A0%88%E7%9A%84%E6%B7%B7%E6%B4%97stack-shuffl">栈的混洗(stack shuffl)</h4>
<p><strong>通过控制入栈和退栈时机得到不同的退栈序列</strong>.</p>
<p>不可能的退栈序列：例如进栈时按$\cdots p_i\cdots p_j\cdots p_k\cdots$次序，则$\cdots p_k\cdots p_i\cdots p_j\cdots$就是不可能的出栈序列，因为当$p_k$出栈时，$p_i$和$p_j$在其之前入栈，故还按原顺序在栈内，$p_i$先进于$p_j$，不可能先出于它。即在某个出栈元素之前进栈且之后出栈的几个元素，出栈后<strong>在该元素之后的顺序遵循先进后出</strong>。</p>
<p>判断是否为可能的退栈序列更直观的分析方式是根据最后一个出栈的元素将原序列分段，比它(序号)小的元素（如果存在）比他先入栈也先出栈，比它大的元素（如果存在）随后出栈，且这两部分本身也满足这个规律，具体就是将原序列递归拆解为许多n&lt;=3的序列，拆解时大区域和小区域混合或拆解成的序列存在不可能退栈序列则该序列为不可能退栈序列。<strong>n=0,1,2,3,时只有n=3时的312是不可能序列</strong>，例如dbca，没有小区域，只有大区域，但大区域是312型，故为不可能序列，dabc,大小区域混合。</p>
<p>卡特兰数(catalan)推导:对于任意的出栈序列，设最后一个元素序号是k,则比最后一个元素小的有k-1个，比它大的有n-k个，根据前面说明这两部分也是可能出栈序列并相互独立，满足乘法原则，设可能出栈序列数为f(k),则f(k)=f(k-1)*f(n-k)，k属于1到n,不同k的情况满足加法原则，故总的可能序列数是f(n) = f(0)f(n-1) + f(1)f(n-2) + …… + f(n-1)f(0)。$C_{n+1}=\sum_{i=0}^n C_i\times C_{n-i} = \frac{1}{n+1}C_{2n}^n = \frac{1}{n+1}\times \frac{(2n)!}{n!\times n!}=\frac{2n(2n-1)\cdots(n+2)}{n!}$<a href="https://en.wikipedia.org/wiki/Catalan_number">详细证明</a></p>
<h4 id="%E5%BA%94%E7%94%A8">应用</h4>
<h5 id="%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87">判断回文</h5>
<p>(1)全部压栈再边退边和原序列比较;(2):压栈一半再边退栈边和剩余的一半比较；中点容易确认或已确认的用2；</p>
<h5 id="%E6%8E%92%E5%BA%8F">排序</h5>
<p>将待排元素放在辅助栈，将目标栈栈顶元素与辅助栈新出栈元素比较，满足大小关系或空栈则入目标栈，否则目标栈退栈到到辅助栈直到满足关系或空栈，辅助栈空时退出。</p>
<h5 id="%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换()</h5>
<p>十进制与k进制数的关系：$N=\sum_{i=0}^{[\log_k^N]}(b_i\times k^i),b_i=0,1,\cdots,k-1$</p>
<p>例如，$49_{10}=1\times 2^5+1\times 2^4+\cdots +1\times 2^0=110001_2$</p>
<p>这样，十进制数N可以用长度为$[\log_k^N]+1$位的k进制数表示为$b_{[\log_k^N]}\cdots b_2b_1b_0$</p>
<p>不断通过取余取商可以将$b_0到b_{[\log_k^N]}$顺序求出来,先全部入栈最后出栈就可以顺序输出。</p>
<h5 id="%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8Dparenthesis-matching">括号匹配(parenthesis matching)</h5>
<p>遇到左括号进栈，遇到右括号出栈（多种括号需比较后出栈），如果中途出栈时栈空（一种括号）或没有与右括号匹配的左括号（多种）或者最终栈不空则匹配失败。</p>
<p>使用计数器只能处理一种括号的情况，([)]的情况将误判。</p>
<h5 id="%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97">表达式的计算</h5>
<p><a href="/home/fengsc/Desktop/cpp/DataStructure/Stack/EvaluateExpression.cpp">源文件</a></p>
<p>注:用vector&lt;string&gt;代替string可实现更大范围的输入；</p>
<p>算数表达式分为：前缀，中缀和后缀表达式；一般输入的表达式是中缀表达式，后缀表达式也叫RPN即逆波兰表达式，不用考虑优先级，程序计算时使用，它们的区别在于运算符的位置，<strong>运算数的相对位置是一样的</strong>。</p>
<h4 id="%E5%B0%86%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">将中缀表达式转换为后缀表达式</h4>
<p>运算符之间的优先级可以用算符优先矩阵或数字表示；</p>
<table>
<thead>
<tr>
<th>操作符op</th>
<th>$</th>
<th>(</th>
<th>!</th>
<th>^</th>
<th>*,/,%</th>
<th>+,-</th>
<th>)</th>
</tr>
</thead>
<tbody>
<tr>
<td>isp(栈内)</td>
<td>0</td>
<td>1</td>
<td>9</td>
<td>7</td>
<td>5</td>
<td>3</td>
<td>10</td>
</tr>
<tr>
<td>icp(栈外)</td>
<td>0</td>
<td>10</td>
<td>8</td>
<td>6</td>
<td>4</td>
<td>2</td>
<td>1(无实际意义)</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>左括号在栈外的优先级最高，使它前面的表达式先搁置，进栈后优先级极低，使得后面的表达式进入，遇到进入的右括号优先级极低，使后面的表达式先搁置，直至括号相遇一起出栈，满足括号内优先级最高。</p>
</li>
<li>
<p>表达式进入栈内后优先级增加，满足同级从左到右的优先级。</p>
</li>
<li>
<p>开头结尾的标志相遇后栈空结束，标志一般用\0，处理前在栈内加入\0,与字符串结尾的\0配对。前者与第一个读取元素比较，后者用于结束，(便于方便应使用char *字符串输入，string无结尾0，可将string.c_str()拷贝到char *P上，注意预先给P分配s.length()+1个空间,然后修改原串，免于返回(注意要引用string))</p>
</li>
</ul>
<p>具体算法：</p>
<p>(1),初始化栈，将结束符\0进栈，开始读入表达式串；</p>
<p>(2),重复执行以下步骤直到遇到ch=='\0',与最后的栈顶配对并退栈然后停止循环。</p>
<ul>
<li>
<p>如果ch是操作数直接赋给结果串；</p>
</li>
<li>
<p>如果ch是操作符，比较ch与栈顶元素的优先级；</p>
<ul>
<li>
<p>if icp(ch)&gt;isp(op)，进栈，读下一个字符；</p>
</li>
<li>
<p>if icp(ch)&lt;isp(op),退栈赋给结果串；</p>
</li>
<li>
<p>if icp(ch)==isp(op),退栈，如果没到结尾就读入下一个字符；</p>
</li>
</ul>
</li>
</ul>
<h5 id="%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F">计算后缀表达式</h5>
<p>顺序扫描表达式，操作数进栈，遇到二元操作符，连续退出两个操作数Y和X，形成运算指令X&lt;op&gt;y，一元操作符退出一个，形成指令X&lt;op&gt;,并将结果重新入栈，表达式扫描完后，栈顶存放的就是计算结果。</p>
<h3 id="%E9%98%9F%E5%88%97">队列</h3>
<p><a href="/home/fengsc/Desktop/cpp/DataStructure/Quene/Queue.h">源文件</a></p>
<pre class="hljs"><code><div><span class="hljs-comment">/*也可以将EnQuene作为类的友元，这时它的声明可以放在后面*/</span>
<span class="hljs-comment">/*class CircQueue;                        //前向声明，作为EnQuene的形参
bool EnQueue(CircQueue &amp;Q, DataType x); //结构体调用，需在其之前声明；*/</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CircQueue</span>
{</span>
<span class="hljs-keyword">public</span>:
  DataType *elem;
  <span class="hljs-keyword">int</span> maxSize;
  <span class="hljs-keyword">int</span> front, back；
    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">EnQueue</span><span class="hljs-params">(CircQueue &amp;Q, DataType x)</span></span>;<span class="hljs-comment">//类和非成员函数友元不需要提前声明</span>
  CircQueue(<span class="hljs-keyword">int</span> size) : maxSize(size + <span class="hljs-number">1</span>), front(<span class="hljs-number">0</span>), back(<span class="hljs-number">0</span>), elem(<span class="hljs-keyword">new</span> DataType[size + <span class="hljs-number">1</span>]) {}
  <span class="hljs-comment">/*注意预留一个位置*/</span>
  CircQueue(<span class="hljs-built_in">vector</span>&lt;DataType&gt; &amp;value)
  {
    maxSize = value.size() + <span class="hljs-number">1</span>; <span class="hljs-comment">//不能调用另一个构造函数，因为这一个还没构造完</span>
    elem = <span class="hljs-keyword">new</span> DataType[maxSize];
    front = back = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; value.size(); i++)
      EnQueue(*<span class="hljs-keyword">this</span>, value[i]); <span class="hljs-comment">//全局函数（已声明或友元）可直接调用，与成员函数同名时前加::</span>
  }
  ~CircQueue()
  {
    <span class="hljs-keyword">delete</span>[] elem;
  }
};
</div></code></pre>
<h4 id="%E5%9F%BA%E6%9C%AC">基本()</h4>
<p>只允许在队头(front)插入，队尾(back)删除，先进先出(FIFO);</p>
<h5 id="%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">循环队列</h5>
<p>初始时，rear=back=0,当back==maxSize时队满，但rear可能不是0，形成假溢出，为了充分使用数组的空间，把数组的前端和后端连接起来，形成一个环形的表，即把存储元素的表逻辑上看做一个环，成为循环队列。</p>
<p>队列的头尾指针时同向运动，栈是反向运动；</p>
<p>队头/队尾指针进一:ptr=(ptr+1)%maxSize;</p>
<p>为了使队满条件区别于队空条件，用(back+1)%maxSize==front来判断是否队空，队满时空了一个位置，不空就无法区别，所以<strong>设置初始容量时要预留一个位置</strong>。</p>
<p>其它实现方式：</p>
<p>(1)元素进队时tag设为1，用back==front&amp;&amp;tag==1判断队满，元素出队时tag设为0，用back==front&amp;&amp;tag==0判断队空；</p>
<p>(2)记录队列长度；</p>
<p>双端队列(double-ended queue),允许在两端插入和删除，输出受限时有三种可能的输出:(1):在同一端输入输出，相当于栈；(2):在一端输入，另一端输出，相当于队列；(3):混合进出；优先队列：取出的不是最先加入的而是优先级最高的(输出时需要遍历数据)。</p>
<h4 id="%E5%BA%94%E7%94%A8">应用()</h4>
<p>逐行输出杨辉三角形;</p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintTriangle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    LinkQueue Q;
    EnQueue(Q, <span class="hljs-number">1</span>);
    EnQueue(Q, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>, t = <span class="hljs-number">0</span>; i &lt;= n; i++)
    {
        EnQueue(Q, <span class="hljs-number">0</span>); <span class="hljs-comment">//每一行之间添加0，便于计算最右侧的数</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= i + <span class="hljs-number">2</span>; j++)
        {
            EnQueue(Q, GetFront(Q) + t); <span class="hljs-comment">//计算下一行并入列</span>
            t = DeQueue(Q);              <span class="hljs-comment">//保留以计算下一个下一行的元素</span>
            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span>)<span class="hljs-comment">//保留行前空格</span>
                <span class="hljs-built_in">cout</span> &lt;&lt; setw(n - i + <span class="hljs-number">2</span>) &lt;&lt; setiosflags(ios::right)&lt;&lt; setfill(<span class="hljs-string">' '</span>) &lt;&lt;t&lt;&lt;<span class="hljs-string">' '</span>;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (j != i + <span class="hljs-number">2</span>) <span class="hljs-comment">//输出本行，除了添加的0</span>
                <span class="hljs-built_in">cout</span> &lt;&lt; setw(<span class="hljs-number">2</span>) &lt;&lt;setiosflags(ios::left)&lt;&lt; t &lt;&lt; <span class="hljs-string">' '</span>;
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}
</div></code></pre>
<h2 id="%E7%9F%A9%E9%98%B5%E5%AD%98%E5%82%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8">矩阵存储，字符串匹配和广义表</h2>
<h3 id="%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA">多维数组的存储表示</h3>
<p>对于数组$a[m_1][m_2]\cdots[m_n]$, $LOC(a[i_1][i_2]\cdots[i_n])=LOC(a[0][0]\cdots[0]])+(i_1\times m_2\times m_3\times \cdots \times m_n+i_2\times m_3\times\cdots \times m_n+\cdots+i_{n-1}\times m_n+i_n)\times l=LOC(a[0][0]\cdots[0])+\left(\sum_{j=1}^{n-1} i_j\times \prod_{k=j+1}^n m_k+i_n\right)\times l$,l为单个元素占据的存储大小。</p>
<h3 id="%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8">对称矩阵的压缩存储、</h3>
<p>上下三角矩阵非零元素个数是:$\frac{n(n+1)}{2}$，三对角矩阵非零元素个数是$3n-2$</p>
<p>行优先存储下三角钜阵的访问地址:$\frac{i(i+1)}{2}+j,i,j\geq 0$</p>
<p>行优先存储上三角矩阵的访问地址:$\frac{i(2n-i-1)}{2}+j$</p>
<p>行优先存储三对角矩阵的访问地址：$2\times i+j$</p>
<p>互换i,j就是列优先。</p>
<p>反解可由压缩数组映射到矩阵；</p>
<h3 id="%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8">稀疏矩阵的存储</h3>
<p>稀疏因子$\delta=\frac{t}{m\times n}$;通常当这个值小于0.05时可以认为是稀疏矩阵。对于nxn的当非零元素数小于$\frac{n^2}/{3}$时是稀疏矩阵，某些场合应小于$\frac{n^2}/{5}$</p>
<p>三角矩阵是稠密矩阵，三对角矩阵当n&gt;8时是稀疏矩阵</p>
<p>以下存储方法都失去了直接存取的特性，只能顺序查找；</p>
<h4 id="%E4%B8%89%E5%85%83%E7%BB%84%E8%A1%A8">三元组表</h4>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triple</span>
{</span>
    <span class="hljs-keyword">int</span> row,column;
    Datatype value;
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpareMatrix</span>
{</span>
    <span class="hljs-keyword">int</span> rows,cols,terms;
    Triple elem[MAXN];
}
<span class="hljs-comment">//还可以改进，例如添加标识每行首个非零元素位置的数组，这样还可以只使用二元组，不用额外储存行号(数组进一位就标志到新行)，具体实现最方便的就是在输入的时候放在每一行的terms（当前总数）位置上(上一行的下一个位置)，也可以根据已建立的三元组表计算</span>

<span class="hljs-comment">//计算每行非零元素开始位置</span>
<span class="hljs-keyword">int</span> rowSize[a.rows],rowStart[a.rows];
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;a.terms; i++)<span class="hljs-comment">//计算每一行非零元素的数量</span>
rowSize[a.elem[row]]++;
rowStart[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;a.terms;i++)
rowStart[i]=rowStart[i<span class="hljs-number">-1</span>]+rowSize[i<span class="hljs-number">-1</span>];<span class="hljs-comment">//递推式；</span>
</div></code></pre>
<h4 id="%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA">链表表示</h4>
<p>(1)简单链表存储；</p>
<p>(2)行链表组；</p>
<p>(3)正交链表(十字链表)；</p>
<p>头结点和非零元素结点的共有部分是tag,down,right;不同的部分是头结点有next,非零元素结点有col,row和val；总的头结点结构像两种结点的叠加，和元素结点一样的特有部分变成了rows，cols，和size；已知行列数时头结点用数组存储比较方便；</p>
<h3 id="kmp">KMP</h3>
<p>P 的 next 数组定义为：next[i] 表示 P[0] ~ P[i-1] 这一个子串，使得 前k个字符恰等于后k个字符 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。</p>
<p>性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。既然如此，如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，前next[r]个字符恰好和后next[r]个字符相等——也就是说，我们可以拿长度为 next[r] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去.</p>
<p>另一种思考:如果某一次匹配后失配字符前配合部分的最长前缀p0...pn-2不等于最长后缀p1...pn-1;则如果从主串的下一个字符开始匹配必定失配,因为这次匹配的开头部分相当于刚才假设的不相等串匹配(相等传递)，（而BF算法不考虑这个，每次失配只进行这一步），继续考虑次长前后缀P0...pn-3,p2...pn-1，此时模式串移动的距离相当于第一次失配后按BF算法的第二次匹配,直到第k次考虑找到最大相同前后缀前面这一段才可能匹配成功，这时模式串后移距离相当于BF算法第一次失配后的第k次匹配，所以可以直接进行BF第k次，并直接从失配字符而非从头继续匹配(移过去之后前面这一段是公共部分,具体距离最大相同前后缀的长度+1)，主串不用动，通过j=next[j]就将模式串调到合适的地方，j向前移实现模式串向后走。</p>
<p>主串影响失配的位置和多少，模式串影响回溯的步数；</p>
<p>next失配函数定义:<br>
$$next(j)=\begin{cases}-1;j=0\ k+1;0\leq k&lt;j-1且使得p_0p_1\cdots p_k=p_{j-k-1}p_{j-k}\cdots p_{j-1}的最大整数\ 0,其它情况\ \end{cases}$$</p>
<p>求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。最大步增为1，最小值为0；</p>
<p><img src="https://pic2.zhimg.com/80/18a9ee17b0eebabab0672687b721aee1_1440w.png" alt="a" title="配合"></p>
<p><img src="https://pic3.zhimg.com/80/f37911dc3ace184a393f359f04944e06_1440w.png" alt="a" title="失配"></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * p, <span class="hljs-keyword">int</span> * next)</span>
</span>{
    next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">strlen</span>(p))
{
    <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])
    {
        j++;
        next[++i] = j;<span class="hljs-comment">//下一位的next值是包括当前位最长前后缀的长度加1；</span>
}
<span class="hljs-keyword">else</span>
    j = next[j];
}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * t, <span class="hljs-keyword">char</span> * p)</span> 
</span>{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; 
    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;

<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">strlen</span>(t) &amp;&amp; j &lt; <span class="hljs-built_in">strlen</span>(p))
{
        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || t[i] == p[j]) <span class="hljs-comment">//当p[0]（后面最差情况会转到0）与失配的t[i]匹配不上时j会等于-1，即模式串与t[i+1]对齐，next数组的作用就是利用已经配对过的部分控制模式串的偏移量</span>
        { 
            i++;
            j++;
        }
        <span class="hljs-keyword">else</span> 
            j = next[j];
        }

    <span class="hljs-keyword">if</span> (j == <span class="hljs-built_in">strlen</span>(p))
       <span class="hljs-keyword">return</span> i - j;模式串的位置
    <span class="hljs-keyword">else</span> 
       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}

</div></code></pre>
<h2 id="%E5%B9%BF%E4%B9%89%E8%A1%A8">广义表</h2>
<p>广义表，又称列表，也是一种线性存储结构。同数组类似，广义表中既可以存储不可再分的元素，也可以存储广义表，记作：</p>
<p>LS = (a1,a2,…,an)</p>
<p>其中，LS 代表广义表的名称，an 表示广义表存储的数据。广义表中每个 ai 既可以代表单个元素，也可以代表另一个广义表。</p>
<p>通常，广义表中存储的单个元素称为 &quot;原子&quot;，而存储的广义表称为 &quot;子表&quot;。</p>
<p>例如创建一个广义表 LS = {1,{1,2,3}}，我们可以这样解释此广义表的构成：广义表 LS 存储了一个原子 1 和子表 {1,2,3}。</p>
<p>以下是广义表存储数据的一些常用形式：<br>
A = ()：A 表示一个广义表，只不过表是空的。<br>
B = (e)：广义表 B 中只有一个原子 e。<br>
C = (a,(b,c,d)) ：广义表 C 中有两个元素，原子 a 和子表 (b,c,d)。<br>
D = (A,B,C)：广义表 D 中存有 3 个子表，分别是A、B和C。这种表示方式等同于 D = ((),(e),(b,c,d)) 。<br>
E = (a,E)：广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。</p>
<p>注意，A = () 和 A = (()) 是不一样的。前者是空表，而后者是包含一个子表的广义表，只不过这个子表是空表。</p>
<p>当广义表不是空表时，称<strong>第一个数据（原子或子表）为&quot;表头&quot;，剩下的数据构成的新广义表为&quot;表尾&quot;</strong>。</p>
<p>强调一下，除非广义表为空表，否则广义表一定具有表头和表尾，且<strong>广义表的表尾一定是一个广义表</strong>。</p>
<p>例如在广义表中 LS={1,{1,2,3},5} 中，表头为原子 1，表尾为子表 {1,2,3} 和原子 5 构成的广义表，即 {{1,2,3},5}。</p>
<p>再比如，在广义表 LS = {1} 中，表头为原子 1 ，但由于广义表中无表尾元素，因此该表的表尾是一个空表，用 {} 表示。</p>
<p>由于广义表中可以同时存储原子和子表两种类型的数据，因此在计算广义表的长度时规定，<strong>广义表中存储的每个原子算作一个数据，同样每个子表也只算作是一个数据。</strong></p>
<p>例如，在广义表 {a,{b,c,d}} 中，它包含一个原子和一个子表，因此该广义表的长度为 2。</p>
<p>再比如，广义表 {{a,b,c}} 中只有一个子表 {a,b,c}，因此它的长度为 1。</p>
<p>前面我们用 LS={a1,a2,...,an} 来表示一个广义表，其中每个 ai 都可用来表示一个原子或子表，其实它还可以表示广义表 LS 的长度为 n。<br>
广义表规定，空表 {} 的长度为 0。</p>
<p>广义表的性质:</p>
<p>(1):有次序性:各表元素在表中线性排列；</p>
<p>(2):有长度：各表元素个数一定，不能是无限的；</p>
<p>(3):有深度:表中括号的重数即为深度，递归表的深度是无穷大；</p>
<p>(4):可递归:具有这种性质的表为递归表；</p>
<p>(5):可共享:广义表可被其它表共享，被共享的表叫共享表或再入表；</p>
<p>由广义表的性质可知，广义表有深度，它是一种<strong>层次结构</strong>；广义表有共享性，它是一种<strong>有向图</strong>；广义表的表元素有次序，它<strong>类似于一种线性结构</strong>，但只有所有表元素都为原子时才退化为线性表，广义表是一种<strong>非线性结构</strong>。</p>
<h3 id="%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9A%84%E9%93%BE%E6%8E%A5%E8%A1%A8%E7%A4%BA">广义表的链接表示</h3>
<h4 id="%E5%A4%B4%E5%B0%BE%E8%A1%A8%E7%A4%BA">头尾表示</h4>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/2-1Z42F93555L0.gif" alt="a"></p>
<h4 id="%E6%8B%93%E5%B1%95%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA">拓展线性链表表示</h4>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/2-1Z42F93F23F.gif" alt="a"></p>
<p><img src="http://data.biancheng.net/uploads/allimg/181225/2-1Q22520131H15.gif" alt="a"></p>
<p><strong>第一种将原子看作只有一个元素的子表，通过子表互相连接；第二种将两者区分开</strong>都是同深度的互相链接；</p>
<h4 id="%E5%B1%82%E6%AC%A1%E9%93%BE%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95">层次链表表示法</h4>
<p>前两种插删都比较困难，为拓展线性链表表示的每个字表添加一个头结点可简化插删，这种表示有三种结点：原子结点，字表结点，头结点;</p>
<p>字表结点hlink从指向字表首元结点变为指向字表头结点；</p>
<p>用3种tag区分；</p>
<p>表示n元多项式的结点定义：</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolyNode</span>
{</span>
    PolyNode* tlink;<span class="hljs-comment">//同一层下一结点指针</span>
    <span class="hljs-keyword">int</span> <span class="hljs-built_in">exp</span>;<span class="hljs-comment">//指数</span>
    <span class="hljs-keyword">int</span> tag;<span class="hljs-comment">//标志,=0为头结点，=1为子表结点，=2为原子结点；</span>
    <span class="hljs-keyword">union</span>
    {
        <span class="hljs-keyword">char</span> name;<span class="hljs-comment">//表头链表中存放的基于该链表的变量名</span>
        PolyNode *hlink;<span class="hljs-comment">//指向系数子链表的指针</span>
        <span class="hljs-keyword">double</span> coef;<span class="hljs-comment">//系数</span>
    }
}
子表结点中<span class="hljs-built_in">exp</span>是本条链表的变量（头结点name变量）的指数；

将每个子表结点下不同层的多项式相乘的结果相加即为本条链表储存的结果。

</div></code></pre>
<h2 id="%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91">树与二叉树</h2>
<h3 id="%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">树的基本概念</h3>
<h4 id="%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89">树的定义</h4>
<p>一棵树是n(n&gt;=0)个结点的有限集合，n=0时为空树，而非空树可记作$T={r,T_1,T_2,\cdots,T_n}$,其中，r是T的根结点，$T_1,T_2,\cdots,T_m$是除r外其它结点构成的互不相交的m个子集合，子集合也是一棵树，称为根的子树。</p>
<p>每棵子树的根节点有且仅有一个直接前驱(即它的上层结点)，但可以有0个或n个直接后继(即它的下层结点)，m称为r的分支数。</p>
<p>树的定义是一个递归的定义，即树的定义中又用到了树的概念。</p>
<p>除了逻辑表示外，树还有目录结构表示，韦恩图表示，凹入式表示和广义表表示；</p>
<h4 id="%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">树的基本术语</h4>
<p>结点，结点的度(子树棵数)，叶结点(度为0的结点)，分支结点(度不为0)，子女结点，双亲结点，兄弟结点，祖先结点(由根结点到该结点路径上的所有结点(一般指真祖先)，子孙(后裔)结点(一般指真子孙)，结点间的路径，结点的深度(结点所属层次,以最上为基准)，结点的高度(叶结点的高度为1，有的教材定义为0，非叶节点的高度等于它子女结点高度中的最大值加一，以最下为基准)，树的深度(距离根结点最远的结点所处层次)，数的高度(等于根结点的高度,值与树的深度相等)，树的宽度(每一层结点个数的最大值)，树的度(树中结点的度的最大值，度为n就是n叉数)，有序树(各棵子树次序是定的)，无序树(子树次序不定)，森林(是m,m&gt;=0棵树的集合，删去一棵树的根结点，树就变成森林(森林可能为空),反之，将几棵树连接到一个根结点，树就变成森林)；</p>
<p>一些结论:</p>
<ul>
<li>
<p>树中的分支条数等于结点条数减一；</p>
</li>
<li>
<p>树中任意两个结点之间有且仅有一条路径；</p>
</li>
<li>
<p>树中每队结点至少存在一个共同祖先；</p>
</li>
<li>
<p>一对结点的有且仅有的深度最大的祖先结点称为最低共同祖先；</p>
</li>
<li>
<p>所有结点的度数之和为n-1(计算度的时候除了根结点都被计算了一遍);设度为$k_i$的结点有$m_i$个，则$\sum_{i}^{n}m_i-1=\sum_{i}^{n}(m_i\times k_i)$</p>
</li>
<li>
<p>高度为k的满n叉树的最大宽度为$n_{k-1}$结点总数为:$\sum_{i=1}^{k}n^{i-1}=\frac{n^{k}-1}{n-1}$，反解可得结点总数为n的m叉树的最小深度为$\lceil\log_m(n(m-1)+1\rceil$,(列式时n大于上层最大总数，小于等于本层最大总数)</p>
</li>
<li>
<p>从1开始自顶向下给一个N叉树的结点编号，则编号为i的结点的双亲结点编号为$\lfloor i/N\rfloor$;</p>
</li>
</ul>
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%8A%E5%85%B6%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA">二叉树及其存储表示</h3>
<h4 id="%E5%AE%9A%E4%B9%89">定义</h4>
<p>$T=\begin{cases}\emptyset,n=0 \ {r,T_L,T_R}\ \end{cases}$</p>
<p>特殊二叉树</p>
<ul>
<li>
<p>完全二叉树:上面从第一层到第k-1层的结点数都是满的，仅最下面的第k层或是满的，或是集中存放在左侧,最多有$2^k-1$个结点，最少有$2^{k-1}$个结点；</p>
</li>
<li>
<p>满二叉树:满的完全二叉树，第k层有$2^{k-1}$个结点；</p>
</li>
<li>
<p>理想平衡树(丰满树):上面是满的，最后一层的结点散见于该层各处；</p>
</li>
</ul>
<h4 id="%E7%89%B9%E7%82%B9">特点</h4>
<ul>
<li>
<p>最多有两个子树，分别称为左子树和右子树，子树可以为空但不能说没有；</p>
</li>
<li>
<p>二叉树的定义是递归的；</p>
</li>
<li>
<p>二叉树可能有5种不同的形态，n叉树可能有$\sum_{i=0}^{n}C_n^i+1(空树)$;</p>
</li>
<li>
<p>关于树的术语二叉树都适用，但二叉树不是树(图论)(定义没有唯一的标准)；</p>
<ul>
<li>
<p>树在图论中被视为用n-1条边联结n个顶点的特殊的图，图的顶点集合非空，故树的顶点集合非空。图论中另外定义了N叉树，它可以是空树，二叉树属于N叉树；</p>
</li>
<li>
<p>非空二叉树有根，根结点的子树有左右之分，树可以没有根(自由树),子树也没有顺序区分；</p>
</li>
</ul>
</li>
</ul>
<h4 id="%E6%80%A7%E8%B4%A8">性质</h4>
<ul>
<li>
<p>第i层(i&gt;0)最多有$2^{i-1}$个结点；</p>
</li>
<li>
<p>深度为k(k&gt;=0)的二叉树最少有k个结点，最多有$2^k-1$个结点；</p>
</li>
<li>
<p>对于任意一棵非空二叉树，若其叶结点数为n0,度为2的结点数为n2,则$n_0=n_2+1,(n_0+n_1+n_2-1=n_1+2n_2)$，两者一奇一偶，和为奇数。</p>
</li>
<li>
<p>具有n个结点的完全二叉树或理想平衡树的深度为$\lceil\log_2(n+1)\rceil$或$\lfloor log_2n \rfloor+1$,区别来源于列式时是$2^{d-1}-1&lt;n\leq2^d-1$还是$2^{d-1}\leq n&lt;2^d$，后者不适用等于0的情况。</p>
</li>
<li>
<p>将完全二叉树自顶向下，同一层从左往右从1开始编号，则有以下关系:</p>
<ul>
<li>
<p>奇数结点在右兄弟位置(除根结点)，偶数在左兄弟位置</p>
</li>
<li>
<p>结点i的双亲为结点$\lfloor i/2 \rfloor ,i&gt;1$;</p>
</li>
<li>
<p>结点i的左子女为2i,2i&lt;=n,右子女为2i+1,2i+1&lt;=n;</p>
</li>
<li>
<p>结点i所在的层次为$\lfloor\log_2i\rfloor+1$;</p>
</li>
<li>
<p>编号最大的非叶结点为$\lfloor \frac{n-1}{2}\rfloor+1$</p>
</li>
<li>
<p>从0开始编号时双亲结点公式用i-1替换，其余用i+1替换，左右对应关系对调；</p>
</li>
</ul>
</li>
<li>
<p>完全二叉树度为1的结点只有0个或1个，当n为奇数时，因为n0+n2是奇数，所以n1=0,此时称为严格(正则)二叉树(结点最少为2h-1,最多为2^h-1),n为偶数时n1=1;$n_0=\lceil n/2\rceil,n_1=\lfloor n/2 \rfloor$，<strong>完全二叉树的叶结点数量大于等于非叶结点数量</strong>。</p>
</li>
<li>
<p>有n个结点，高度为n的二叉树的棵数为$2^{n-1}$,每个向下的子女都有两个可能的位置。</p>
</li>
<li>
<p>满二叉树某一行的结点数$2^{h-1}=\lceil \frac{n}{2} \rceil,n是该行及其以上结点的总数2^{h}-1$</p>
</li>
</ul>
<h4 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8">二叉树的存储</h4>
<p>顺序存储，将元素顺序排列在数组里，可用'#'表示空结点，只适合存储完全二叉树，存储空结点多的二叉树浪费空间，数组大小是$2^h-1$</p>
<p>链表存储</p>
<p>二叉链表链指针个数是2n,n+1个是空的，n-1个指向子女，等于边数。</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>
{</span>
<span class="hljs-keyword">public</span>:
    DataType data;
    TreeNode *lchild, *rchild;
    TreeNode() : data(<span class="hljs-number">0</span>), lchild(<span class="hljs-literal">nullptr</span>), rchild(<span class="hljs-literal">nullptr</span>) {}
    TreeNode(DataType val) : data(val), lchild(<span class="hljs-literal">nullptr</span>), rchild(<span class="hljs-literal">nullptr</span>) {}
    TreeNode(DataType val,TreeNode *rptr,TreeNode *lptr): data(val), lchild(lptr), rchild(rptr){}
};
<span class="hljs-keyword">typedef</span> TreeNode *BinTree;

<span class="hljs-comment">//加一个指向双亲的指针即为三叉链表表示</span>
</div></code></pre>
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</h3>
<h4 id="%E5%AE%9A%E4%B9%89">定义()</h4>
<p>所谓二叉树遍历(binarytree traversal)遵从某种次序，便访二叉树中的所有结点，使得每个结点被访问一次且只访问一次。</p>
<h4 id="%E5%88%86%E7%B1%BB">分类</h4>
<p>共有6种规则:VLR,LVR,LRV,VRL,RVL,RLV,规定先左后右后剩下3种规则，VLR(先序遍历)，LVR(中序遍历),LRV(后序遍历)，递归实现语句区别在于访问语句和递归遍历语句的相对顺序；</p>
<pre class="hljs"><code><div>
(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>*<span class="hljs-number">3</span>)+<span class="hljs-number">2</span>*<span class="hljs-number">3</span>*<span class="hljs-number">4</span>的先序，中序，后序遍历结果(前，中，后缀表达式)
+ * <span class="hljs-number">4</span> * <span class="hljs-number">3</span> <span class="hljs-number">2</span> + * <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> 
<span class="hljs-number">4</span> * <span class="hljs-number">3</span> * <span class="hljs-number">2</span> + <span class="hljs-number">3</span> * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> 
<span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> * * <span class="hljs-number">3</span> <span class="hljs-number">2</span> * <span class="hljs-number">1</span> + + 
</div></code></pre>
<p>特别的，<strong>中序遍历序列就是二叉树在底面的投影</strong>。</p>
<p>非递归实现语句较复杂但时间和空间复杂度会降低(不降低数量级),大体都是先从根结点开始沿着左分支下行，并在栈中记录当前结点位置，最后把控制权交给栈顶右子女将其作为新的根结点，区别在于<strong>访问结点语句的位置和转交控制权语句的位置</strong>，特别的，后序非递归实现时栈内保存的是<strong>某一结点和它任意祖先之间的路径</strong>。</p>
<p>设有n个结点，遍历算法的时间复杂度为O(n)(每个结点只访问一次)，空间复杂度最好为$O(log_2n)$,最差为O(n),递归工作栈最多存放的结点数等于树的高度(单支树等于n)，对于递归算法，每次递归就向下一层，也等于树的高度。</p>
<p>层次序遍历(广度优先)的时间复杂度为O(n),空间复杂度为树的宽度,队列最多存放$\lceil \frac{n}{2} \rceil$个结点</p>
<table>
<thead>
<tr>
<th></th>
<th>先序</th>
<th>中序</th>
<th>后序</th>
</tr>
</thead>
<tbody>
<tr>
<td>左单支树</td>
<td>正向</td>
<td>逆向</td>
<td>逆向</td>
</tr>
<tr>
<td>右单支树</td>
<td>正向</td>
<td>正向</td>
<td>逆向</td>
</tr>
</tbody>
</table>
<p>输出序列从上向下为正向。</p>
<p>若先序遍历时u在v之前且后序遍历时在u在v之后，则u是v的祖先。</p>
<h3 id="%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E6%9E%84%E5%92%8C%E8%AE%A1%E6%95%B0">二叉树的重构和计数</h3>
<p>二叉树的重构:通过二叉树的遍历序列忠实(唯一)地还原出二叉树的拓扑结构.</p>
<ul>
<li>
<p>(先序||后序)+中序；可以通过数学归纳法证明，重构算法是遍历前序(从前向后)或后序序列(从后往前)，并在中序序列中将遍历到的结点作为根结点将两个序列拆分开(根，左，右)，不断递归进行,中序决定左右子树序列的长度，先序+后序不行是因为归纳证明时若一个子女为空则通过(t,L/R)和(R/L,t)不能确定该子女是左还是右。</p>
</li>
<li>
<p>1，找到当前层序序列中 第一个 出现在当前中序序列的元素 作为根节点root，2，在当前中序序列中找出根节点root的下标k，把当前中序序列划分为[inL,k-1]，[k+1,inR]，分别是 当前根节点root的 左子树的中序序列，和右子树的中序序列。</p>
</li>
<li>
<p>由完全二叉树的任意一种遍历序列都可以实现二叉树的重构。</p>
</li>
<li>
<p>根据前序和后序可以重构一棵真(严格)二叉树，因为它不会出现根结点一个子女为空的情况，重构算法是用分治策略，具体是找到根结点和左右子女分界位置并递归地对左右子女进行重构。前序序列:(t,L(...),(R...)),后序序列:((...L),(...R),t)根结点就是前序序列的第一个结点和后序序列的最后一个结点，后序序列的分界点就是前序序列根结点的左子女在后序序列中的位置，对称的可以找到前序序列的分界点。</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function">TreeNode *<span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;inorder)</span> </span>{
    <span class="hljs-keyword">return</span> create(preorder, inorder, <span class="hljs-number">0</span>, preorder.size() - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, inorder.size() - <span class="hljs-number">1</span>);
}

<span class="hljs-function">TreeNode* <span class="hljs-title">create</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder, <span class="hljs-keyword">int</span> ps, <span class="hljs-keyword">int</span> pe, <span class="hljs-keyword">int</span> is, <span class="hljs-keyword">int</span> ie)</span></span>{
    <span class="hljs-keyword">if</span>(ps &gt; pe){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<span class="hljs-comment">//子树为空</span>
    }
    TreeNode* node = <span class="hljs-keyword">new</span> TreeNode(preorder[ps]);<span class="hljs-comment">//对于后序是pe</span>
    <span class="hljs-keyword">int</span> pos;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = is; i &lt;= ie; i++){
        <span class="hljs-keyword">if</span>(inorder[i] == node-&gt;val){<span class="hljs-comment">//在inorder里寻找子根作为分界点</span>
            pos = i;
            <span class="hljs-keyword">break</span>;
            }
    }
    node-&gt;left = create(preorder, inorder, ps + <span class="hljs-number">1</span>, ps + pos - is, is, pos - <span class="hljs-number">1</span>);<span class="hljs-comment">//左子树序列长度为pos-is</span>
    node-&gt;right = create(preorder, inorder, pe - ie + pos + <span class="hljs-number">1</span>, pe, pos + <span class="hljs-number">1</span>, ie);<span class="hljs-comment">//右子树序列长度为ie-pos</span>
     <span class="hljs-comment">/*利用中后序构造： node-&gt;left = create(inorder, postorder, is, pos - 1, ps, ps + pos - is - 1);  
        node-&gt;right = create(inorder, postorder, pos + 1, ie, pe - ie + pos, pe - 1); */</span>
    <span class="hljs-keyword">return</span> node;
}
<span class="hljs-function">BinTree <span class="hljs-title">CreateByInAndLevel</span><span class="hljs-params">(<span class="hljs-built_in">string</span> in, <span class="hljs-built_in">string</span> level, <span class="hljs-keyword">int</span> ie, <span class="hljs-keyword">int</span> is, <span class="hljs-keyword">int</span> ls)</span>
</span>{
    <span class="hljs-keyword">if</span> (is &gt; ie)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">while</span> (index == <span class="hljs-number">-1</span>)<span class="hljs-comment">//找出层次序列中第一个出现在当前中序序列的元素（越过另一子树的元素）</span>
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = is; i &lt;= ie; i++)
        {
            <span class="hljs-keyword">if</span> (in[i] == level[ls])
            {
                index = i;
                <span class="hljs-keyword">break</span>;
            }
        }
        ls++;
    }
    ls--; <span class="hljs-comment">//多加了一个</span>
    BinTree root = <span class="hljs-keyword">new</span> TreeNode(level[ls]);
    root-&gt;lchild = CreateByInAndLevel(in, level, index - <span class="hljs-number">1</span>,is, ++ls);
    root-&gt;rchild = CreateByInAndLevel(in, level, ie, index+<span class="hljs-number">1</span>, ++ls);
    <span class="hljs-keyword">return</span> root;
}
</div></code></pre>
<p>二叉树的计数:假设一个二叉树有n个结点，并对各个结点编号，先序遍历得到的叫先序排列，中序得到的叫中序排列，设先序排列是1到n，则中序排列数决定能确定多少棵二叉树。</p>
<p>递推公式为$\begin{cases}b_0=1,n=0\b_n=\sum_{i=0}^{n-1}(b_i\times b_{n-i-1}),i\geq1\\end{cases}$</p>
<p>结果为卡特兰数$\frac{1}{n+1}C_{2n}^n =\frac{1}{n+1}\times \frac{(2n)!}{n!\times n!}= \frac{2n(2n-1)\cdots(n+2)}{n!}$</p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{

<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;
    t[<span class="hljs-number">0</span>] = t[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">int</span> i, j;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; ++i)
    {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; ++j)<span class="hljs-comment">//结构是对称的，计算一半再乘二较为简便(奇数项的中间项只有一项，后面再加)</span>
        t[i] += t[j - <span class="hljs-number">1</span>] * t[i - j];
        t[i] *= <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>)<span class="hljs-comment">//加上奇数项的中间项</span>
        t[i] += t[i / <span class="hljs-number">2</span>] * t[i / <span class="hljs-number">2</span>];<span class="hljs-comment">//Plus the middle 'root' trees.(结点子女相同)</span>
        }
       <span class="hljs-keyword">return</span> t[n];
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode *&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
    </span>{
        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> {} ;<span class="hljs-comment">//return vector&lt;TreeNode *&gt;(0),a NULL vector;</span>
        <span class="hljs-keyword">return</span> helper(<span class="hljs-number">1</span>, n);
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;TreeNode *&gt; <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span>
    </span>{
        <span class="hljs-built_in">vector</span>&lt;TreeNode *&gt; res;
        <span class="hljs-keyword">if</span> (start &gt; end)
        {
           res.push_back(<span class="hljs-literal">NULL</span>);
            <span class="hljs-keyword">return</span> res;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = start; i &lt;= end; i++)
        {
            <span class="hljs-built_in">vector</span>&lt;TreeNode *&gt; left = helper(start, i - <span class="hljs-number">1</span>);<span class="hljs-comment">//分治</span>
            <span class="hljs-built_in">vector</span>&lt;TreeNode *&gt; right = helper(i + <span class="hljs-number">1</span>, end);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; left.size(); j++)<span class="hljs-comment">//遍历所有组合</span>
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; right.size(); k++)
                {
                    TreeNode *root = <span class="hljs-keyword">new</span> TreeNode(i);
                    root-&gt;left = left[j];
                    root-&gt;right = right[k];
                    res.push_back(root);
                }
        }
        <span class="hljs-keyword">return</span> res;
    }
</div></code></pre>
<p>线索二叉树</p>
<p>对一棵二叉树中所有节点的空指针域按照某种遍历方式加线索的过程叫作线索化，被线索化了的二叉树称为线索二叉树。</p>
<pre class="hljs"><code><div> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBNode</span>
{</span>
    <span class="hljs-keyword">char</span> data;
    <span class="hljs-keyword">int</span> ltag,rtag;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBNode</span> *<span class="hljs-title">lchild</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TBNode</span> *<span class="hljs-title">rchild</span>;</span>
};
</div></code></pre>
<p>对于中序遍历的二叉树，左子女为空时会丢失前置结点，右子女为空时会丢失后置结点，为这两种情况找到对应的结点就建立了中序线索二叉树。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InThreaded</span><span class="hljs-params">(TBNode *p,TBNode *&amp;pre)</span>
</span>{
    <span class="hljs-keyword">if</span>(p){
        InhTreaded(p-&gt;lchild,pre);<span class="hljs-comment">//递归线索化左子树</span>
        <span class="hljs-keyword">if</span>(p-&gt;lchild==<span class="hljs-literal">nullptr</span>){<span class="hljs-comment">//当前结点左子女为空则设置前置结点</span>
            p-&gt;lchild=pre;
            p-&gt;ltag=<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">if</span>(pre&amp;&amp;p-&gt;rchild=<span class="hljs-literal">nullptr</span>)<span class="hljs-comment">//将当前结点设置为非空的空右子女前置结点的后置结点</span>
        {
            pre-&gt;rchild=p;
            p-&gt;rtag=<span class="hljs-number">1</span>;
        }
        pre=p;<span class="hljs-comment">//当前结点是右子树的前置结点</span>
        InTheaded(p-&gt;rchild,pre);
    }
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    Create(T);
    TBNode *pre=<span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">if</span>(T)
    {
        InTheaded(T,pre);
        pre-&gt;rchild=<span class="hljs-literal">nullptr</span>;
        pre-&gt;rtag=<span class="hljs-number">1</span>;<span class="hljs-comment">//设置最后一个结点的后置结点为空</span>
    }
}
</div></code></pre>
<p>先序和后序线索化类似。</p>
<h3 id="%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97">树与森林</h3>
<p>子女—兄弟表示</p>
<p>寻找子女的复杂度是O(d),寻找双亲的复杂度是O(n);</p>
<p>树转化为二叉树，将树的根结点变为二叉树的根结点，再将树的左子女转化为二叉树并链接在二叉树的左子树上，最后将左子女的兄弟结点转换为二叉树并迭代链接在二叉树子女的右支上。转换得到的二叉树根没有右子女。</p>
<p>相当于将树右旋45度，向右平行的兄弟连支变为了向右下的右连支，向下的子女连支变为了向左下的左连支。</p>
<p>类似可得二叉树到树的转化。</p>
<p>去掉根结点的子女不唯一的树就是森林</p>
<p>树的遍历</p>
<p>先根遍历和中根遍历为深度优先遍历，层次序遍历为广度优先遍历。</p>
<h2 id="%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8">树的应用</h2>
<h3 id="%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91">哈夫曼树</h3>
<p>树的路径长度是根结点到每一个结点的路径长度(结点的深度减一)之和</p>
<p>n个二叉树的最小路径长度$PL=\sum_{i=0}^{n-1} \lfloor\log_2{i+1}\rfloor=(n+1);\lfloor\log_2n\rfloor-2^{\lfloor\log_2{n+1}\rfloor}+2$,此时二叉树为完全二叉树。</p>
<p>对于一颗已有的二叉树， 如果我们为它添加一系列新结点，使得它原有的所有结点的度都为2，那么我们就得到了一颗扩充二叉树</p>
<p>外结点数 = 内结点数 + 1<br>
总结点数 = 2 × 外结点数 -1</p>
<p>将权值{w1,w2,...,wn}(wi&gt;=0)分别赋给T的n个叶节点，称T为权值为{w1,w2,...,wn}的扩充二叉树，带有权值的叶节点叫做扩充二叉树的外结点，其余结点叫做内结点。</p>
<p>扩充二叉树的带权路径长度定义为$WPL=\sum_{i=1}^nw_il_i$,WPL最小时即为Huffman树。</p>
<p>带权路径长度最小的扩充二叉树不一定是完全二叉树，权值越大的离根结点越近的是。</p>
<p>Huffman算法(构造huffman树)</p>
<p>构造n个带有权值的结点组成的森林，将权值较小的两棵树合并，合并后的新根的权值为其子女结点权值之和，合并到只剩一棵树，所得的树就是huffman树。</p>
<p>限制外结点大小顺序可得唯一确定的树</p>
<pre class="hljs"><code><div><span class="hljs-comment">//静态三叉链实现</span>
<span class="hljs-keyword">using</span> DataType = <span class="hljs-keyword">char</span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HFNode</span>
{</span>
    DataType data;
    <span class="hljs-keyword">int</span> weight;
    <span class="hljs-keyword">int</span> parent, lchild, rchild;
    HFNode(<span class="hljs-keyword">int</span> w = <span class="hljs-number">-1</span>, DataType val = <span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> par = <span class="hljs-number">-1</span>, <span class="hljs-keyword">int</span> lc = <span class="hljs-number">-1</span>, <span class="hljs-keyword">int</span> rc = <span class="hljs-number">-1</span>) : weight(w), data(val), parent(par), lchild(lc), rchild(rc)
    {
    }
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HFTree</span>
{</span>
    HFNode *elem;
    <span class="hljs-keyword">int</span> leafNum, totalNum, root;
    ~HFTree() { <span class="hljs-keyword">delete</span> elem; }
};
</div></code></pre>
<p>数组中前n个是外结点，后n-1个是内结点，第2n-2个是根结点，构造的时间复杂度为o(n^2);</p>
<p>最优判定树</p>
<p>用Huffman树建立的成绩查询树的WPL不一定是最优判定树，因为有的内结点判定等同于两次判定，权值会比预期的大。</p>
<p>改进算法与Huffman算法的区别是轮流检查<strong>权值和最小的相邻两树</strong>并进行合并,并且排列时相对顺序不能变化(可以在数组中将合并后的根结点与原左子女的位置交换，将右子女移到交换后左子女的前一个位置，中间部分顺序前移，最终根结点在第一个元素处)，用链式表实现较为容易(静态表子女的位置改变后不能追踪)。</p>
<p>Huffman编码</p>
<p>将二叉树的左分支标记为0，右分支标记为1，从根结点到叶节点的路径唯一的表示了该叶节点的二进制编码。</p>
<p>设计变长编码，为出现概率较低的字符指定较长的码字，为出现概率较大的字符指定较短的码字，可以明显提高传输的平均性能。</p>
<p>前缀性质:任一字符编码都不是其它字符编码的前缀。用二叉树表示可以保证这个性质。</p>
<p>平均编码长度最小的前缀编码称为最优编码，可以通过构造huffman树解决，Huffman树的带权路径长度就是相应编码的平均编码长度，得到的编码称为Huffman编码。</p>
<pre class="hljs"><code><div> <span class="hljs-keyword">double</span> weight[LEAF_NUM] = {<span class="hljs-number">0.05</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">0.05</span>};
DataType val[LEAF_NUM * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>] = {<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'g'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'j'</span>};
a:<span class="hljs-number">0110</span>
b:<span class="hljs-number">1110</span>
c:<span class="hljs-number">1111</span>
d:<span class="hljs-number">0111</span>
e:<span class="hljs-number">10</span>
f:<span class="hljs-number">000</span>
g:<span class="hljs-number">001</span>
h:<span class="hljs-number">010</span>
i:<span class="hljs-number">1100</span>
j:<span class="hljs-number">1101</span>
averageCodingLength is:<span class="hljs-number">3.1</span>
</div></code></pre>
<h3 id="%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</h3>
<p>性质：</p>
<ul>
<li>
<p>每个结点都有作为查找依据的关键码(key)，所有结点的关键码互不相同(简化)；</p>
</li>
<li>
<p>非空左子树上所有结点的关键码都小于根结点的关键码；</p>
</li>
<li>
<p>非空右子树上所有结点的关键码都大于根结点的关键码；</p>
</li>
<li>
<p>左子树和右子树也是二叉搜索树；</p>
</li>
<li>
<p>中序遍历时各结点的关键码按从小到大的顺序排列。</p>
<ul>
<li>
<p>微观上处处满足顺序性</p>
</li>
<li>
<p>整体上满足单调性</p>
</li>
</ul>
</li>
</ul>
<p>为提高算法可读性一般不设关键码项，直接用数据值进行比较，相当于有限制的二叉树；</p>
<pre class="hljs"><code><div><span class="hljs-comment">//验证二叉搜索树</span>
<span class="hljs-comment">//算法1</span>
    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> pre = LLONG_MIN;<span class="hljs-comment">//要比所有int小，保证第一次的比较恒成立</span>
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode *root)</span>
    </span>{ <span class="hljs-comment">//中序遍历</span>
        <span class="hljs-keyword">if</span> (!root)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

        <span class="hljs-keyword">if</span> (!isValidBST(root-&gt;left))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

        <span class="hljs-keyword">if</span> (root-&gt;val &lt;= pre) <span class="hljs-comment">//二叉搜索树「中序遍历」得到的值构成的序列一定是升序的</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        pre = root-&gt;val;
        <span class="hljs-keyword">if</span> (!isValidBST(root-&gt;right))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
    <span class="hljs-comment">//算法2</span>
 <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode *root)</span>
    </span>{
        <span class="hljs-keyword">return</span> isValid(root, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//使用指针可以避免边界值的影响，NULL替代绝对的最值，保证最初的比较</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(TreeNode *root, <span class="hljs-keyword">int</span> *lower, <span class="hljs-keyword">int</span> *upper)</span><span class="hljs-comment">//lower和upper都是来源于父节点，只能用来判假，不能判真</span>
    </span>{
        <span class="hljs-keyword">if</span> (!root)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">if</span> (upper &amp;&amp; root-&gt;val &gt;= *upper)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (lower &amp;&amp; root-&gt;val &lt;= *lower)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">return</span> isValid(root-&gt;left, lower, &amp;(root-&gt;val)) &amp;&amp; isValid(root-&gt;right, &amp;(root-&gt;val), upper);
    }
</div></code></pre>
<p>查找的行为类似与二分查找，查找的比较次数不超过高度h，最好logn,最坏n;</p>
<p>查找算法决定了能否进行插入删除操作并提供了进行插入删除时所需的目标位置的位置信息(父节点)。</p>
<p>删除操作在目标结点有左右子女的情况下复杂度最高，但也是O(h);</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">deleteBSNode</span><span class="hljs-params">(BSTree root, BSTDataType x)</span>
</span>{
    BSTree father, cur, p;
    <span class="hljs-keyword">if</span> (!(cur = search(root, x, father)))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (cur-&gt;lchild &amp;&amp; cur-&gt;rchild) <span class="hljs-comment">//寻找中序直接后继(右子树里的最左端)，并对调数据，使情况归于travial,father记录父结点</span>
    {
        p = cur-&gt;rchild;
        father = cur;
        <span class="hljs-keyword">while</span> (p-&gt;lchild)
        {
            father = p;
            p = p-&gt;lchild;
        }
       cur-&gt;data=p-&gt;data;<span class="hljs-comment">//更换被删节点原位置的值为其后继的值，注意不能改变p的值，因为最后要判别方向</span>
        cur = p;<span class="hljs-comment">//将cur移到待删处</span>
    }
    p = cur-&gt;lchild ? cur-&gt;lchild : cur-&gt;rchild; <span class="hljs-comment">//p为将要被链接的结点，cur至多有一个子树</span>
    <span class="hljs-keyword">if</span> (!father)                                 <span class="hljs-comment">//被删的为根结点</span>
        root = p;
    <span class="hljs-keyword">else</span> <span class="hljs-comment">//p是否存在都要链接，不存在时父节点要置空</span>
        cur-&gt;data &lt; father-&gt;data ? father-&gt;lchild = p : father-&gt;rchild = p;
    <span class="hljs-keyword">delete</span> cur;
    cur=<span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p>二叉搜索树的性能分析</p>
<p>固定中序序列可构成的不同二叉搜索树的个数为卡特兰数，可以用树的平均查找长度来衡量它们 。</p>
<p>中序序列相同而拓扑结构不同的二叉树为一个等价类</p>
<p>将原二叉搜索树的结点结点看做内结点，扩充得到扩充二叉树；</p>
<p>内结点树为n时，外结点树为n+1;用I表示所有内结点的路径长度之和，E表示所有外结点的路径长度之和，则有$E=I+2n$,<br>
每个内结点为外结点贡献两个单位路径长度(左子树一个，右子树一个)。</p>
<p>对扩充二叉树进行中序遍历的结果中内结点与外结点交替排列，每个内结点都在两个外结点之间。</p>
<p>定义查找成功的平均查找长度为$ASL_{成功}=\sum_{i=1}^np[i]l[i]$,L[i]是第i个内结点的层次号，等于找到该结点的关键码比较次数，p[i]为结点查找概率；</p>
<p>查找不成功的平均查找长度为$ASL_{不成功}=\sum_{i=0}^nq<a href="l'%5Bj%5D-1">j</a>$，$l'[j]$为外结点层次号，减一为关键码平均比较次数。</p>
<p>所有结点的概率之和为1，两个公式之和即为扩充二叉树的平均查找长度ASL</p>
<p>各结点概率不相等情形下类似Huffman树，区别是还要计算内结点概率</p>
<p>相等查找概率情形下高度最小的扩充二叉树的平均查找长度最短，称为最优二叉搜索树，其平均查找长度公式为</p>
<p>$$ASL_{成功}=\sum_{i=1}^n(\lfloor\log_2i\rfloor+1),ASL_{不成功}=\sum_{i=n+1}^{2n+1}\lfloor\log_2i\rfloor$$</p>
<p>随机情况下二叉搜索树的查插删操作的平均时间复杂度为$O(\log_2n)$</p>
<h3 id="avl%E6%A0%91">AVL树</h3>
<p>AVL树是一种高度平衡二叉树(BBST);</p>
<p>定义:所有结点的左子树和右子树的高度之差的绝对值不超过1</p>
<p>平衡因子(balence factor):左子树高度减去右子树高度</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AVLNode</span>
{</span>
    AVLDataType data;
    AVLNode *lchild, *rchild, *parent;
    <span class="hljs-keyword">int</span> height; <span class="hljs-comment">//此信息更为有用，替代需要通过高度计算的平衡因子,初高为1</span>
    AVLNode(AVLDataType _data = <span class="hljs-number">0</span>, AVLNode *_parent = <span class="hljs-literal">nullptr</span>, AVLNode *_lchild = <span class="hljs-literal">nullptr</span>, AVLNode *_rchild = <span class="hljs-literal">nullptr</span>, <span class="hljs-keyword">int</span> _height = <span class="hljs-number">1</span>) : data(_data), parent(_parent), lchild(_lchild), rchild(_rchild), height(_height) {}
};
<span class="hljs-keyword">using</span> AVLTree = AVLNode *;
</div></code></pre>
<p>插入操作：</p>
<p>插入一个结点，其所有祖先都有可能会失衡</p>
<p>平衡化旋转：从插入位置向上回溯直到发现不平衡的结点，从发生不平衡的结点起，沿回溯的路径取下两层的结点(<strong>沿高度更高的子树路径</strong>)，如果这3个结点位于同一条直线上，则采用单旋转进行平衡化，否则用双旋转；</p>
<p>单旋转分为左单旋转和右单旋转</p>
<p>左单旋转又称RR旋转(根据三个结点向下的路径,<strong>与其名称中的左相反</strong>)，用于在结点的右子树的右子树上插入新结点导致不平衡的情况，具体是回溯找到不平衡结点(此结点<strong>原本的平衡因子为-1</strong>，插入的结点使其变为-2，此子树称为<strong>最小不平衡子树</strong>)，<strong>考虑两个结点</strong>，以此结点的右子女为旋转轴<strong>逆时针</strong>旋转使此结点成为其右子女的左子女，并使原来右子女的左子女成为此结点的右子女,使子树的高度恢复插入前的状态；</p>
<p>对称可得右单旋转(LL旋转)的定义(最小不平衡子树的平衡因子因插入从1变为2，通过旋转使其恢复1)</p>
<p>双旋转分为先左后右旋转(LR)和先右后左(RL)旋转(<strong>与名称方向一致</strong>)；</p>
<p>先左后右旋转(不平衡结点的<strong>平衡因子为1</strong>，在其左子树的右子树上插入结点导致平衡因子变为2)，<strong>考虑三个结点</strong>，具体是以最下层的结点为旋转轴先进行一次左单旋转将其双亲结点(中间位置的结点)旋转下去，再进行一次右旋转将其新的双亲结点(最上层的结点)旋转下去；</p>
<p>对称可得先右后左旋转的定义；</p>
<p>插入具体算法:</p>
<ul>
<li>
<p>调用普通BST的插入函数获取父结点(插入函数较简单，且普通插入函数可能没有链接父结点的功能，故可以直接实现)<br>
为空即返回</p>
</li>
<li>
<p>从新插入结点的<strong>双亲开始</strong>向上回溯</p>
</li>
<li>
<p>bf=0/1/-1:依然平衡，不做额外操作,继续回溯；</p>
</li>
<li>
<p>bf=2/-2:</p>
<p>-- bf=2:若左子女的bf也为正进行LL旋转，否则进行LR旋转；</p>
<p>-- bf=-2;若右子女的bf也为负进行RR旋转，否则进行RL旋转。</p>
<p>-- 具体实现可以从此结点沿更高的子树向下行进两层，将该节点传入平衡操作函数，操作函数可根据此结点找到其父结点<br>
与祖父结点，进而根据它们的关系进行旋转</p>
</li>
<li>
<p>若不需要进行平衡操作则<strong>更新结点的高度</strong>并继续回溯</p>
</li>
<li>
<p>最小不平衡子树高度恢复，祖先状态自动恢复，无须继续回溯。</p>
</li>
</ul>
<p>3+4重构：将回溯所得的三个结点从上到下命名为g,p,v,以这三个结点为界将原先g对应的子树按中序遍历序列拆分得到四棵子树(T0,T1,T2,T2),再将四棵子树按照原顺序链接在中序序列中位于两侧的结点，再将这两个结点作为**最中间结点(单旋为p,双旋为v)**的子女，此结点作为新子树的根，这样不会改变中序遍历序列并且四棵子树的高度差不会超过1，组装所得的就是是AVL树，涵盖了所有的单旋和双旋情况。</p>
<p>只要按顺序传入三个结点及四个对应的子树就可用通用的算法重构得到平衡的AVL树。</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">insert</span><span class="hljs-params">(AVLTree &amp;root, AVLDataType x)</span>
</span>{
    AVLTree cur, father;
    <span class="hljs-keyword">if</span> (search(root, x, father))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    cur = <span class="hljs-keyword">new</span> AVLNode(x, father); <span class="hljs-comment">//注意与父结点链接</span>
    <span class="hljs-keyword">if</span> (isRoot(cur))              <span class="hljs-comment">//空树则将当前结点作为根</span>
        root = cur;
    <span class="hljs-keyword">else</span>
        x &lt; father-&gt;data ? father-&gt;lchild = cur : father-&gt;rchild = cur;
    <span class="hljs-keyword">for</span> (AVLTree p = father; p; p = p-&gt;parent) <span class="hljs-comment">//平衡化</span>
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(getHeight(p-&gt;lchild) - getHeight(p-&gt;rchild)) &gt;= <span class="hljs-number">2</span>)
        { <span class="hljs-comment">//p的父结点与旋转后的子树链接,根结点直接修改</span>
            <span class="hljs-keyword">if</span> (isRoot(p))
                root = rotate(tallerChild(tallerChild(p)));
            <span class="hljs-keyword">else</span>
            { <span class="hljs-comment">//旋转会修改p，需要保存其父结点</span>
                AVLTree par = p-&gt;parent;
                isLchild(p) ? par-&gt;lchild = rotate(tallerChild(tallerChild(p))) : par-&gt;rchild = rotate(tallerChild(tallerChild(p)));
            }
            <span class="hljs-keyword">break</span>; <span class="hljs-comment">//旋转后即可退出</span>
        }
        <span class="hljs-keyword">else</span>
            updateHeight(p); <span class="hljs-comment">//更新回溯路径上的高度</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}

<span class="hljs-function">AVLTree <span class="hljs-title">rotate</span><span class="hljs-params">(AVLTree v)</span>
</span>{
    <span class="hljs-keyword">if</span> (!v)
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    AVLTree p = v-&gt;parent, g = p-&gt;parent; <span class="hljs-comment">//父结点和祖父节点</span>
    <span class="hljs-comment">//判断类型,按中序序列传入参数</span>
    <span class="hljs-keyword">if</span> (isLchild(p))
    {
        <span class="hljs-keyword">if</span> (isLchild(v)) <span class="hljs-comment">//LL</span>
        {
            p-&gt;parent = g-&gt;parent; <span class="hljs-comment">//顶部交接</span>
            <span class="hljs-keyword">return</span> connect34(v, p, g, v-&gt;lchild, v-&gt;rchild, p-&gt;rchild, g-&gt;rchild);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//LR</span>
        {
            v-&gt;parent = g-&gt;parent;
            <span class="hljs-keyword">return</span> connect34(p, v, g, p-&gt;lchild, v-&gt;lchild, v-&gt;rchild, g-&gt;rchild);
        }
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-keyword">if</span> (isRchild(v)) <span class="hljs-comment">//RR</span>
        {
            p-&gt;parent = g-&gt;parent;
            <span class="hljs-keyword">return</span> connect34(g, p, v, g-&gt;lchild, p-&gt;lchild, v-&gt;lchild, v-&gt;rchild);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-comment">//RL</span>
        {
            v-&gt;parent = g-&gt;parent;
            <span class="hljs-keyword">return</span> connect34(g, v, p, g-&gt;lchild, v-&gt;lchild, v-&gt;rchild, p-&gt;rchild);
        }
    }
}
<span class="hljs-function">AVLTree <span class="hljs-title">connect34</span><span class="hljs-params">(AVLTree a, AVLTree b, AVLTree c, AVLTree T0, AVLTree T1, AVLTree T2, AVLTree T3)</span>
</span>{
    <span class="hljs-comment">//注意更新高度</span>
    a-&gt;lchild = T0;
    <span class="hljs-keyword">if</span> (T0)
        T0-&gt;parent = a;
    a-&gt;rchild = T1;
    <span class="hljs-keyword">if</span> (T1)
        T1-&gt;parent = a;
    updateHeight(a);
    c-&gt;lchild = T2;
    <span class="hljs-keyword">if</span> (T2)
        T2-&gt;parent = c;
    c-&gt;rchild = T3;
    <span class="hljs-keyword">if</span> (T3)
        T3-&gt;parent = c;
    updateHeight(c);
    b-&gt;lchild = a;
    a-&gt;parent = b;
    b-&gt;rchild = c;
    c-&gt;parent = b;
    updateHeight(b);
    <span class="hljs-keyword">return</span> b;
}
</div></code></pre>
<p>删除操作：</p>
<p>删除一个结点会可能导致一个子树失衡，但复衡的后子树高度如果降低可能会导致其祖先的失衡，开销较插入更大</p>
<p>具体算法:</p>
<ul>
<li>
<p>调用普通的BST删除，获取目标位置父结点，为空则返回</p>
</li>
<li>
<p>然后进行复衡与更新高度直到根结点</p>
</li>
<li>
<p>旋转类型类似插入时，使用3+4重构更为简洁</p>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">remove</span><span class="hljs-params">(AVLTree &amp;root, AVLDataType x)</span>
</span>{
    <span class="hljs-keyword">if</span> (!root)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    AVLTree p = deleteNode(root, x); <span class="hljs-comment">//获取被删结点的父结点</span>
    <span class="hljs-keyword">if</span> (!root)                       <span class="hljs-comment">//删除的为根结点</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">if</span> (!p) <span class="hljs-comment">//删除失败</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">while</span> (p)
    {
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(getHeight(p-&gt;lchild) - getHeight(p-&gt;rchild)) &gt;= <span class="hljs-number">2</span>)
        {
            <span class="hljs-keyword">if</span> (isRoot(p))
                p = root = rotate(tallerChild(tallerChild(p)));
            <span class="hljs-keyword">else</span>
            {
                AVLTree par;
                par = p-&gt;parent;
                p = isLchild(p) ? par-&gt;lchild = rotate(tallerChild(tallerChild(p))) : par-&gt;rchild = rotate(tallerChild(tallerChild(p)));
            }
        }
        updateHeight(p); <span class="hljs-comment">//需做O(logn)次调整,极端情况是每次上溯都要调整，无论是否做过调整，树高度均可能降低</span>
        p = p-&gt;parent;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}
</div></code></pre>
<p>性能分析</p>
<p>设$N_h$是高度为h的AVL树的最小结点树，根据平衡条件，在最差情况下，根的一棵子树的高度为h-1,另一棵的高度为h-2,这两个子树也是高度平衡的，因此有$N_0=0,N_1=1$,$N_h=N_{h-1}+N_{h-2}+1,h&gt;1$.</p>
<p>对于$h\geq1,有N_h=F_{n+2}-1$,经过推导可得，$h&lt;1.44\log_2(N_h+2)-0.327$</p>
<p>所以AVL树的最大高度相当于斐波那契树的情形，最小高度相当于完全二叉树的情形</p>
<p>优点:</p>
<p>各种操作的时间复杂度最坏是O(logn),空间复杂度为O(n);</p>
<p>缺点:</p>
<p>需借助高度或平衡因子，需要改造或额外封装数据元素</p>
<p>插删操作特别是删除操作成本不菲</p>
<p>单次动态调整后，全树拓扑结构的变化量可能高达O(logn);</p>
<h3 id="%E5%85%AB%E7%9A%87%E5%90%8E">八皇后</h3>
<pre class="hljs"><code><div><span class="hljs-comment">//利用递归实现回溯，类似通配符匹配</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; <span class="hljs-title">solveNQueens</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
    </span>{
        <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">chess</span><span class="hljs-params">(n, <span class="hljs-built_in">string</span>(n, <span class="hljs-string">'.'</span>))</span></span>;
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; ans;
        helper(chess, ans, <span class="hljs-number">0</span>, n);
        <span class="hljs-keyword">return</span> ans;
    }

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; chess, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt;&gt; &amp;ans, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> n)</span>
    </span>{
        <span class="hljs-keyword">bool</span> attack;
        <span class="hljs-keyword">if</span> (k &lt;= n)
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
            {
                chess[k][i] = <span class="hljs-string">'Q'</span>; <span class="hljs-comment">//放置皇后</span>
                attack = <span class="hljs-literal">false</span>;
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) <span class="hljs-comment">//与前k-1行比较判断是否被攻击</span>
                    <span class="hljs-keyword">if</span> (chess[k] == chess[j] || <span class="hljs-built_in">abs</span>(k - j) == <span class="hljs-built_in">abs</span>((<span class="hljs-keyword">int</span>)chess[j].find_first_of(<span class="hljs-string">'Q'</span>) - (<span class="hljs-keyword">int</span>)chess[k].find_first_of(<span class="hljs-string">'Q'</span>)))
                    {
                        attack = <span class="hljs-literal">true</span>;
                        <span class="hljs-keyword">break</span>;
                    }
                <span class="hljs-keyword">if</span> (attack == <span class="hljs-literal">false</span>)
                    <span class="hljs-keyword">if</span> (k == n<span class="hljs-number">-1</span>)<span class="hljs-comment">//!</span>
                        ans.emplace_back(chess);
                    <span class="hljs-keyword">else</span>
                    {
                        helper(chess, ans, k + <span class="hljs-number">1</span>, n);
                    }
                chess[k][i] = <span class="hljs-string">'.'</span>; <span class="hljs-comment">//复位本行棋盘,选择下一列</span>
            }
        }   
    }
};
输入：n = <span class="hljs-number">4</span>
输出：[[<span class="hljs-string">".Q.."</span>,<span class="hljs-string">"...Q"</span>,<span class="hljs-string">"Q..."</span>,<span class="hljs-string">"..Q."</span>],[<span class="hljs-string">"..Q."</span>,<span class="hljs-string">"Q..."</span>,<span class="hljs-string">"...Q"</span>,<span class="hljs-string">".Q.."</span>]]
</div></code></pre>
<h3 id="%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86">等价关系与并查集</h3>
<p>定义在集合A上的关系叫做等价关系，如果它是自反的，对称的和传递的。</p>
<p>设R是定义在集合A上的等价关系，与A中的一个元素a有关系的所有元素的集合叫做a的等价类。代表元为a的A上的关于R的等价类记作$[a]_R$,只考虑一个关系时可省去下标。</p>
<p>模m同余关系的等价类叫作模m同余类，整数a的模m同余类满足$[a]_m={\cdots,a-2m,a-m,a,a+m,a+2m,\cdots}$</p>
<p>设R是定义在集合A上的等价关系，下面的关于集合A中a,b两个元素的命题是等价的：</p>
<ul>
<li>
<p>aRb</p>
</li>
<li>
<p>$[a]=[b]$</p>
</li>
<li>
<p>$[a]\cap[b]=\varnothing$</p>
</li>
</ul>
<p>等价类构成一个划分(非空，无交，覆盖)</p>
<p>由等价类可以得到一个划分(将划分中的每一个子集作为一个等价类)，由一个划分也可以得到一个等价类(讲一个等价类(通常是一组有序对)中有关系的有序对中的元素作为划分子集)</p>
<p>A={1，2，3，4}，由等价关系R={(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,4)}得到的一个划分为P1={1,2,3},P2={4};因为R(1)=R(2)=R(3)={1,2,3},R(4)={4};</p>
<p>以余数相等作为等价关系可得到m个不同的模m同余类，它们构成了整数集合的划分</p>
<p>集合上的等价关系数等于划分数</p>
<p>含有n个元素的集合的划分数$S(n)=\sum_{i=1}^nS(n,k),S(n,k)$表示将集合划分为k个子集的划分数</p>
<p>$S(n,k)=S(n-1,k-1)+k*S(n-1,k),1\leq k \leq n$</p>
<p>不能把n个元素不放进任何一个集合中去，即k=0时，S（n，k）=0；也不可能在不允许空盒的情况下把n个元素放进多于n的k个集合中去，即k&gt;n时，S（n，k）=0；再者，把n个元素放进一个集合或把n个元素放进n个集合，方案数显然都是1。</p>
<p>对于任一个元素an，则必然出现以下两种情况：</p>
<p>1.{an}是k个子集中的一个，于是我们只要把a1，a2，......，an-1划分为k-1个子集，便解决了本题，这种情况下的划分数共有S（n-1,k-1）个；<br>
2.{an}不是k个子集中的一个，则an必与其他的元素构成一个子集。则问题相当于先把a1，a2，......，an-1划分成k个子集，这种情况下划分数共有S（n-1，k）；然后再把元素an加入到k个子集中的任一个中去，共有k中加入方式，这样对于an的每一种加入方式，都可以使集合划分为k个子集，因此根据乘法原理，划分数共有k*S（n-1，k）个。</p>
<p>并查集(UnionFindSet)</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UFSets</span>
{</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; fa;
    Timer timer;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> fa.size(); }
    UFSets(<span class="hljs-keyword">size_t</span> size = SIZE)
    {
        fa.assign(size, <span class="hljs-number">-1</span>); <span class="hljs-comment">//初始各成一派，都是集合(根)，fa[root]的相反数为其集合中元素个数</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">size_t</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x)</span> <span class="hljs-comment">//查找根(等价类代表元),同时实现路径压缩,将沿途结点指向根结点，减少重复查找所需时间</span>
    </span>{
        <span class="hljs-keyword">return</span> fa[x] &lt; <span class="hljs-number">0</span> ? x : (fa[x] = find(fa[x]));
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> x, <span class="hljs-keyword">size_t</span> y)</span> <span class="hljs-comment">//合并在元素较多集合上，防止树发生退化(高度过高)</span>
    </span>{
        <span class="hljs-keyword">if</span> (x != y)
        {
            <span class="hljs-keyword">int</span> setx = find(x), sety = find(y); <span class="hljs-comment">//找到所属集合</span>
            <span class="hljs-keyword">int</span> sum = fa[setx] + fa[sety];
            <span class="hljs-comment">//根结点fa为负值，越小元素数越多</span>
            fa[setx] &lt; fa[sety] ? (fa[sety] = setx, fa[setx] = sum) : (fa[setx] = sety, fa[sety] = sum);
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initByOrderedPair</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt; &amp;pairs)</span> <span class="hljs-comment">//通过有序关系对初始化</span>
    </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pairs.size(); i++)
            merge(pairs[i].first, pairs[i].second);
    }
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">divide</span><span class="hljs-params">()</span> <span class="hljs-comment">//划分获得等价类</span>
    </span>{
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; result;
        <span class="hljs-built_in">string</span> <span class="hljs-built_in">set</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; fa.size(); i++)
        {
            <span class="hljs-keyword">if</span> (fa[i] &lt; <span class="hljs-number">0</span>)
            {
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; fa.size(); j++)
                {
                    <span class="hljs-keyword">if</span> (find(j) == i) <span class="hljs-comment">//将满足等价关系的元素放进字符串(不是所有路径都压缩过，不能直接用父亲判断)</span>
                        <span class="hljs-built_in">set</span> += to_string(j) + <span class="hljs-string">","</span>;
                }
                <span class="hljs-built_in">set</span>.pop_back(); <span class="hljs-comment">//吐出最后一个逗号</span>
                result.emplace_back(<span class="hljs-built_in">set</span>);
                <span class="hljs-built_in">set</span>.clear();
            }
        }
        <span class="hljs-keyword">return</span> result;
    }
    <span class="hljs-comment">/*
    size_t find(size_t x)
    {
        while (fa[x] &gt;= 0)
            x = fa[x];
        return x;
    }
    void merge(size_t x, size_t y) //合并在x根上
    {
        if (x != y)
            fa[x] += fa[y];
        fa[y] = x; //y指向x
    }*/</span>
};
</div></code></pre>
<p>查找操作的复杂度不超过树高(logn)，合并复杂度取决于查找；在一定范围内查找次数越多被压缩的路径越多复杂度越低</p>
<h3 id="%E6%B1%82%E5%B9%82%E9%9B%86">求幂集</h3>
<p>1，递归，dfs，在某个路口分为取和舍两路</p>
<p>2，求(0,1)向量的n(元素个数)次笛卡尔积,所得的序列对应每个元素的取舍，可以循环，也可以用法1求笛卡尔积序列。</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getPower</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; &amp;loc, <span class="hljs-built_in">string</span> res, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">set</span>, <span class="hljs-keyword">size_t</span> index)</span>
</span>{
    <span class="hljs-keyword">if</span> (index == <span class="hljs-built_in">set</span>.size())
    {
        <span class="hljs-keyword">if</span> (res.back() == <span class="hljs-string">','</span>)
            res.pop_back();
        res += <span class="hljs-string">"]"</span>;
        loc.emplace_back(res);
        <span class="hljs-keyword">return</span>;
    }
    getPower(loc, res, <span class="hljs-built_in">set</span>, index + <span class="hljs-number">1</span>); <span class="hljs-comment">//不选</span>
    res += to_string(<span class="hljs-built_in">set</span>[index]) + <span class="hljs-string">','</span>; <span class="hljs-comment">//选</span>
    getPower(loc, res, <span class="hljs-built_in">set</span>, index + <span class="hljs-number">1</span>);
}
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">cartesianProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; setx, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; sety)</span> <span class="hljs-comment">//求两个集合的笛卡尔积，元素类型为string</span>
</span>{
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(setx.size() * sety.size())</span></span>;
    <span class="hljs-keyword">size_t</span> t = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : setx)
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> y : sety)
            ans[t++] += (x + y);
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">cartesianProduct</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-built_in">set</span>, <span class="hljs-keyword">int</span> n)</span> <span class="hljs-comment">//就一个集合的笛卡尔幂</span>
</span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; ans = <span class="hljs-built_in">set</span>;
    ans.reserve(<span class="hljs-built_in">pow</span>(<span class="hljs-built_in">set</span>.size(), n));
    n--;
    <span class="hljs-keyword">while</span> (n--) <span class="hljs-comment">//作n-1次笛卡尔积</span>
        ans = cartesianProduct(ans, <span class="hljs-built_in">set</span>);
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-built_in">set</span> = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; loc;
    loc.reserve(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">set</span>.size()));
    <span class="hljs-built_in">string</span> res{<span class="hljs-string">"["</span>};
    getPower(loc, res, <span class="hljs-built_in">set</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : loc)
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; Set = {<span class="hljs-string">"0"</span>, <span class="hljs-string">"1"</span>}, ans(<span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, <span class="hljs-built_in">set</span>.size()));
    ans = cartesianProduct(Set, <span class="hljs-built_in">set</span>.size());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : ans)
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : ans)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">set</span>.size(); j++)
            <span class="hljs-keyword">if</span> (i[j] - <span class="hljs-string">'0'</span>)
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">set</span>[j];
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}
运行结果:
[]
[<span class="hljs-number">3</span>]
[<span class="hljs-number">2</span>]
[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]
[<span class="hljs-number">1</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]

<span class="hljs-number">000</span>
<span class="hljs-number">001</span>
<span class="hljs-number">010</span>
<span class="hljs-number">011</span>
<span class="hljs-number">100</span>
<span class="hljs-number">101</span>
<span class="hljs-number">110</span>
<span class="hljs-number">111</span>


<span class="hljs-number">3</span>
<span class="hljs-number">2</span>
<span class="hljs-number">23</span>
<span class="hljs-number">1</span>
<span class="hljs-number">13</span>
<span class="hljs-number">12</span>
<span class="hljs-number">123</span>
</div></code></pre>
<h2 id="%E5%9B%BE">图</h2>
<h3 id="%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">基本定义</h3>
<p>G(V,E):G:图名，V:点集，G:边集</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>边</th>
<th>允许多重边</th>
<th>允许环</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单图</td>
<td>无向</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>多重图</td>
<td>无向</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>伪图(基本无向图)</td>
<td>无向</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>有向简单图</td>
<td>有向</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>有向多重图</td>
<td>有向</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>混合图</td>
<td>有向和无向</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<p>握手定理:</p>
<ul>
<li>
<p>无向图：$2m=\sum_{v\in V}deg(v)$</p>
</li>
<li>
<p>有向图：$\sum_{v\in V}deg^-(v)=\sum_{v\in V}deg^+(v)=|E|$</p>
</li>
</ul>
<p>无向图有偶数个度为奇数的结点，即奇顶点总是成对出现</p>
<p>几类简单图:完全图$K_n$,圈图$C_n(n\geq 3)$,轮图$W_n$:圈图添加一个顶点和若干边而成，n立方体图$Q_n$:用顶点表示$2^n$个长度为n的位串的图。</p>
<p>无向完全图有$\sum_{i=0}^{n-1}=\frac{n(n-1)}{2}$条边，乘二即为有向完全图的边数</p>
<p>二分图:图的顶点分为两个不相交的子集，每条边连接不同子集的顶点，一个简单图是二分图当且仅当能够对图中的每对顶点赋予不同的颜色并使得没有两个相邻的顶点被赋予同一种颜色，此时两种颜色的顶点对应两个集合，任意两个不同子集的顶点都邻接时为完全二分图$K_{m,n}$</p>
<p>匹配：在简单集G(V,E)中的一个匹配M就是边集E的子集，且该子集中没有两条边关联了相同的顶点；包含最多边数的匹配称为最大匹配</p>
<p>在二分图中，若|M|=|V1|,则称M(边集合)是从V1到V2的完全匹配，此时必然有|V1|&lt;=|N(V1)|=|V2|,V1的任意子集A也满足，即|N(A)|&gt;=|A|(N(A)表示A的<strong>邻接顶点</strong>集合),即为<strong>霍尔婚姻定理</strong>,是存在完全匹配的充要条件</p>
<p>导出子图:包含子图顶点在原图中的所有对应边的子图</p>
<p>并图，补图类似并集补集</p>
<h3 id="%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA">图的表示</h3>
<p>邻接矩阵表示，类似于关系矩阵，简单图的邻接矩阵是对称的(无向)，并且主对角线上元素都为0(没有环),当为带权图时则将没有关系的位置设为一个max值(也可以规定权值大于0，将没有关系设为0)，有邻接的顶点对应位置即为权值，邻接矩阵也可以表示带环和多重边的图的有向图，元素表示对应顶点间的边数</p>
<p>本质是边组成的矩阵，可以用元素为边对象指针的矩阵实现，指针为空即为没有关系</p>
<p>对于无向图，第i行或第i列元素之和为顶点i的deg</p>
<p>对于有向图，第i行元素之和是顶点i的indeg，第j列元素之和为顶点j的outdeg.</p>
<p>当含有的边数少于超过所有可能的边数的一半时适合用邻接矩阵，否则过于稀疏时适合用邻接表，前者判断边的存在只需一次比较，而后者需要O(|V|)次比较</p>
<p>关联矩阵:横坐标为边，纵坐标为顶点，便于表示多重边和环的无向图</p>
<h3 id="%E8%BF%9E%E9%80%9A%E6%80%A7">连通性</h3>
<p>连通关系是一个顶点集合上的<strong>等价关系</strong>，将顶点划分为等价类，称为连通分支(连通子图)</p>
<p>两个顶点间有路径则称两个顶点是连通的，如果图中任意一对顶点都是连通的则称此图是连通图，连通无向图的每一对顶点之间都有<strong>简单通路(无重复边)</strong>，非连通图的极大连通子图叫做连通分量，连通图只有它本身一个连通分支。</p>
<p><strong>没有重复点的通路为初级通路</strong>，初级通路一定是简单通路 。</p>
<p>不连通的图有两个或两个以上不相交的连通子图</p>
<p>有向图中若每对顶点间都有<strong>互相到达的路径</strong>，则称此图为强连通图，其极大连通子图为强连通分量,去掉有向性后如果是连通图则为弱连通图</p>
<p>删除割点(关节点)或割边(桥)就会产生更多的连通子图(改变连通性)，在计算机网络的图中它们分别表示最重要的路由器和最重要的链路</p>
<p>删除任意一个结点依然连通的图不含割点，称为不可分割图，比有割点的连通图具有更好的连通性</p>
<p>非完全图的点连通度为点割即中最小的顶点数(使图不连通所需的最少顶点数)，记作k(G),连通图的点连通度定义为n-1,即使连通图变为只含有一个顶点。k(G)越大，连通性越好，不连通图的k(G)为0</p>
<p>类似可得边连通度的定义</p>
<p>点连通度小于等于边连通度小于等于图中最小的度</p>
<p>max(min[u,v])叫做图的直径，就是最长的距离，不存在通路时距离定义为无穷</p>
<p>生成树:一个无向连通图的生成树是它的包含每个顶点的极小连通子图</p>
<p>一个无向连通图至少有n-1条边，若刚好有n-1条边时即为生成树</p>
<p>图的同构:设G1=(V1,E1)和G2=(V2,E2)是简单图，若存在双射f使得a和b在G1中相邻当且仅当f(a)和f(b)在图G2中相邻。</p>
<p><strong>顶点数，边数和顶点的度还有特定长度简单回路</strong>都是在同构下的不变量(必要条件)，但没有已知的用来判断简单图是否同构的不变量集,度为3的顶点和连接它们的边所构成的子图一定是同构的</p>
<p>若$A_G=A_H$,其中前者是G的邻接矩阵，后者是H上由G的对应顶点的像标记行和列的矩阵，则f是保持边的，由此得出f是同构，但不能通过f不是同构得到两个图不同构，因为两个图的顶点的另一个对应关系可能同构</p>
<p>沿着经过所有结点并且使得两个图的对应顶点的度都相同的通路前进，可以构造可能的同构，这个过程可以保证它们的邻接矩阵是相同的</p>
<p>根据邻接矩阵计算通路数:</p>
<p>从$v_i$到$v_j$的长度为r的通路数等于$A^r$的第(i,j)项</p>
<p>可以用来求两点间的最短通路数(对应位置第一次非零时的值)</p>
<p>可达矩阵<br>
<img src="https://img-blog.csdnimg.cn/20210520195151792.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl81MjM2NTczMQ==,size_16,color_FFFFFF,t_70" alt="a"></p>
<p>可达矩阵M=$(A+I)^n=I+A+A^[2]+A^[3]+\dots+A^[n]$<br>
是0次幂(I:添加自反性)到n次幂(长度为n的路径)的并，由于自反性已经添加，故到n-1次即可，可以用布尔幂，也可以用普通幂然后将结果中的非零元素归1，即为图中邻接关系(A+I)的传递闭包。将Warshall算法的结构与单位阵进行布尔或即为所得</p>
<h3 id="%E9%81%8D%E5%8E%86">遍历</h3>
<p>访问数据域是访问的一部分</p>
<p>BFS</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::bfs(<span class="hljs-keyword">int</span> s)
{
    reset();
    <span class="hljs-keyword">int</span> v = s;
    <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">do</span><span class="hljs-comment">//遍历每个不重复的连通域</span>
    {
        <span class="hljs-keyword">if</span> (status(v) == UNDISCOVERED)
            BFS(v, clock);
    } <span class="hljs-keyword">while</span> (s != (v = (++v % n)));
}

<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::BFS(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> &amp;clock, <span class="hljs-built_in">vector</span>&lt;Tv&gt; &amp;path)
{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; Q;
    status(v) = DISCOVERED;
    dTime(v)=++clock;
    Q.push(v);
    <span class="hljs-keyword">while</span> (!Q.empty())
    {
        <span class="hljs-keyword">int</span> v = Q.front();
        Q.pop();
        path.emplace_back(vertex(v));<span class="hljs-comment">//访问数据域</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = firstNbr(v); u &gt; <span class="hljs-number">-1</span>; u = nextNbr(v, u))
        {
            <span class="hljs-keyword">if</span> (status(u) == UNDISCOVERED)
            {
                status(u) = DISCOVERED;
                dTime(v) = ++clock; <span class="hljs-comment">//标记每个顶点被探测的时间(顺序)</span>
                Q.push(u);
                type(v, u) = TREE; <span class="hljs-comment">//引入树边支撑拓展树</span>
                parent(u) = v;
            }
            <span class="hljs-keyword">else</span>
                type(v, u) = CROSS; <span class="hljs-comment">//归于跨边(v已被访问或发现)</span>
        }
        status(v) = VISITED; <span class="hljs-comment">//v被访问完毕</span>
        <span class="hljs-comment">//访问结束时间fTime与Dtime等价</span>
    }
}
</div></code></pre>
<p>连通的无向图一次搜索就可以覆盖全图，有向图查找次数与顶点选取有关</p>
<p>复杂度:邻接表:O(n+e),邻接矩阵O(n^2),考虑到结点数组大概率存储在高速缓存区，实际与邻接表存储的复杂度一致</p>
<p>是树的层序遍历的拓展，所生成的支撑树中的顶点到初始顶点的路径即为两顶点之间的最短路径</p>
<p>DFS</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::dfs(<span class="hljs-keyword">int</span> s, <span class="hljs-built_in">vector</span>&lt;Tv&gt; &amp;path)
{
    reset();
    <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> v = s;
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-keyword">if</span> (status(v) == UNDISCOVERED)
            DFS(v, clock, path);
    } <span class="hljs-keyword">while</span> (s != (v = (++v % n)));
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::DFS(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> &amp;clock, <span class="hljs-built_in">vector</span>&lt;Tv&gt; &amp;path)
{
    dTime(v) = ++clock;
    status(v) = DISCOVERED;
    path.emplace_back(vertex(v));<span class="hljs-comment">//访问数据域</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = firstNbr(v); u &gt; <span class="hljs-number">-1</span>; u = nextNbr(v, u))
    {
        <span class="hljs-keyword">switch</span> (status(u))
        {
        <span class="hljs-keyword">case</span> UNDISCOVERED: <span class="hljs-comment">//u尚未发现，意味着支撑树可在此拓展</span>
            type(v, u) = TREE;
            parent(u) = v;
            DFS(u, clock, path);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> DISCOVERED: <span class="hljs-comment">//u已被发现但尚未访问完毕，应属被后代指向的祖先</span>
            type(v, u) = BACKWARD;<span class="hljs-comment">//每一条BACKWARD的边都代表着一个环(loop)的存在</span>
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:  <span class="hljs-comment">//u已访问完毕（VISITED，有向图），则视承袭关系分为前向边(在当前顶点之后是非子女的后代)</span>
                        <span class="hljs-comment">//或跨边(在当前顶点之前是表亲)</span>
            type(v, u) = (dTime(v) &lt; dTime(u)) ? FORWARD : CROSS;
        }
    }
    status(v) = VISITED;<span class="hljs-comment">//至此，当前顶点v方告访问完毕</span>
    fTime(v) = ++clock;<span class="hljs-comment">//访问完毕时间</span>
}
</div></code></pre>
<p>是树的先序遍历的拓展</p>
<p>括号引理</p>
<p>Parenthesis Lemma:给定有向图G(V,E)及其任意DFS森林，则</p>
<p>$\begin{cases} u是v的祖先-&gt;active[u]\supseteq active[v]\ u是v的子女-&gt;active[u]\subseteq active[v]\ u和v没有直系亲属关系-&gt; active[u]\cap active[v]=\varnothing \end{cases} $</p>
<p>通过这样可以用O(1)的复杂度判断两个顶底是否有直系亲属关系，通过parent域判断需要O(n)的复杂度</p>
<h2 id="%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8">图的应用</h2>
<h3 id="%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8Ftopological-sorting">拓扑排序(Topological sorting)</h3>
<p>构造一个相容的偏序，某个顶点(除最小元)被访问当且仅当小于它的顶点都已被访问</p>
<p>零入度算法:每一步选择极小元(零入度，根)加入结果并删除此顶点,缺点是需要大量的比较和删除操作，复杂度较高,当然实际上可以通过<strong>维护一个入度数组和极小元栈实现</strong></p>
<p>零出度算法:进行<strong>全图的DFS遍历</strong>，当<strong>顶点是极大元(零出度，叶)或后序顶点都已被访问时(如果删除被访问的顶点，就相当于极大元)<strong>顶点进入排序序列(入栈),出栈的结果即为拓扑排序的序列，即为各顶点回溯顺序的倒序，亦位DFS算法退出递归时输出当前顶点的值所得到的序列</strong>用后序顶点都已被访问作为特征可知fTime越靠后，在拓扑排序中越靠前，fTime从大到小的排列即为结果</strong>，这样可以不用修改或重写原DFS(实际做题需要重写改进,可<strong>依据backtrack的出现(探测但未访问)证明有环</strong>,并在遍历过程中记录回溯顶点)，易知如果遍历起始点为最小元则只须遍历一次</p>
<p>拓扑排序不能排序带环的图(格),而用DFS可以得到结果，但结果不合理，与选取的顶点有关，需要在探测到环时退出排序</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">TopologicalSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;Tv&gt; &amp;order)</span> <span class="hljs-comment">//传入DAG图dfs排序后的序列(或是任意的顶点标签值序列，都要确保先进行dfs），不能辨别带环的图</span>
    </span>{
        <span class="hljs-built_in">std</span>::sort(order.begin(), order.end(), [&amp;](Tv a, Tv b)
                  { <span class="hljs-keyword">return</span> fTime(loc(a)) &gt; fTime(loc(b)); }); <span class="hljs-comment">//按fTime逆序排列</span>
    }
</div></code></pre>
<p>判断是否有环</p>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; &amp;prerequisites)</span>
    </span>{
        neighbors.resize(numCourses);
        visited.resize(numCourses);
        visited.assign(numCourses, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prerequisites.size(); i++)
            neighbors[prerequisites[i][<span class="hljs-number">1</span>]].emplace_back(prerequisites[i][<span class="hljs-number">0</span>]);
        flag = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; flag &amp;&amp; v &lt; numCourses; v++)
            <span class="hljs-keyword">if</span> (!visited[v])
                dfs(v);
        <span class="hljs-keyword">return</span> flag;
    }
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; neighbors;
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; visited;
    <span class="hljs-keyword">bool</span> flag;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span>
    </span>{
        <span class="hljs-keyword">if</span> (!flag) <span class="hljs-comment">//终止</span>
            <span class="hljs-keyword">return</span>;
        visited[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">//探测</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = neighbors[v].begin(); i != neighbors[v].end(); i++)
        {
            <span class="hljs-keyword">if</span> (!visited[*i])
                dfs(*i);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visited[*i] == <span class="hljs-number">1</span>) <span class="hljs-comment">//探测到但未访问完毕是一个回边，代表一个有向环的存在</span>
                flag = <span class="hljs-literal">false</span>;
        }
        visited[v] = <span class="hljs-number">2</span>; <span class="hljs-comment">//访问完毕</span>
    }
};
</div></code></pre>
<h3 id="%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F">连通分量</h3>
<p>当无向图为连通图时，从某一顶点出发进行DFS所能访问到的所有顶点构成一个连通分量，从所有未被访问顶点出发进行DFS即可得到无向图的所有连通分量<br>
，连通分量构成一组等价类，所以也可以利用并查集进行计算</p>
<p>去除任一顶点后图任能保持连通的无向图称为双连通图(双向连通图)，任意两个顶点之间存在到达对方的不重合的路径，非双连通图包含多个双连通分量(Biconnected Components)</p>
<p>双连通分量之间通过关节点连接</p>
<p>判断关节点的准则</p>
<ul>
<li>
<p>根结点若至少有两个子女则一定是关节点(无向图不会有跨边)</p>
</li>
<li>
<p>叶节点不是关节点(去除不会影响连通状态)</p>
</li>
<li>
<p><strong>内部顶点不是关节点当且仅当它的任一子孙都可以绕过它到达u的某一祖先</strong>，而且u不属于这条路径</p>
</li>
</ul>
<p>有向图的强连通分量类似无向图的双连通分量，可以依据上述的第三条准则为原理的tarjana算法得到强连通分量(strongly connected component (SCC))，也可以得到无向图的双连通分量</p>
<p>tarjan算法计算bcc</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::bcc()
{
    <span class="hljs-keyword">if</span> (direct == DIRECTED)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"please try scc or scc2"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span>;
    }
    reset();
    <span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; S;
    <span class="hljs-keyword">while</span> (v != n - <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span> (status(v) == UNDISCOVERED)
        {
            BCC(v, clock, S);
            S.pop(); <span class="hljs-comment">//*遍历返回后，弹出栈中最后一个顶点——当前连通域的起点</span>
        }
        v++;
    }
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> hca(x) (fTime(x))           <span class="hljs-comment">//利用闲置的fTime()充当hca(),highest connnected ancestor</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//顶点类型、边类型</span>
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::BCC(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> &amp;clock, <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;S)
{
    hca(v) = dTime(v) = ++clock; <span class="hljs-comment">//初始的hca是探测时间</span>
    status(v) = DISCOVERED;
    S.push(v);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = firstNbr(v); - <span class="hljs-number">1</span> &lt; u; u = nextNbr(v, u))
        <span class="hljs-keyword">switch</span> (status(u))
        { <span class="hljs-comment">//视u的状态分别处理</span>
        <span class="hljs-keyword">case</span> UNDISCOVERED:
            parent(u) = v;
            type(v, u) = TREE;
            BCC(u, clock, S); <span class="hljs-comment">//从顶点u处深入</span>
            <span class="hljs-keyword">if</span> (hca(v) &gt; hca(u))
                hca(v) = <span class="hljs-built_in">std</span>::min(hca(v), hca(u)); <span class="hljs-comment">//更新hca[v]</span>
            <span class="hljs-keyword">else</span> <span class="hljs-comment">//子女的hca不可能大于祖先</span>
            { <span class="hljs-comment">//*弹出当前BCC中（除关节点v外）的所有节点,v可能是其它连通域的成员，不能退栈</span>
                <span class="hljs-built_in">cout</span> &lt;&lt; vertex(v);<span class="hljs-comment">//输出关节点</span>
                <span class="hljs-keyword">while</span> (S.top() != u)<span class="hljs-comment">//*v,u在栈中不一定连续，要用u作为终止条件</span>
                {
                    <span class="hljs-built_in">cout</span> &lt;&lt; vertex(S.top());
                    S.pop();
                }
                <span class="hljs-built_in">cout</span> &lt;&lt; vertex(S.top()) &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
                S.pop();
            }
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> DISCOVERED: 
            type(v, u) = BACKWARD;
            hca(v) = <span class="hljs-built_in">std</span>::min(hca(v), dTime(u)); <span class="hljs-comment">//更新hca[v]</span>
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>: <span class="hljs-comment">//VISITED (有向图),与本算法无关</span>
            type(v, u) = (dTime(v) &lt; dTime(u)) ? FORWARD : CROSS;
            <span class="hljs-keyword">break</span>;
        }
    status(v) = VISITED;
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> hca</span>

</div></code></pre>
<p>tarjan算法计算scc</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::scc()
{
    <span class="hljs-keyword">if</span> (direct == UNDIRECTED)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"please try dcc"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span>;
    }
    reset();
    <span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> clock = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; S;
    <span class="hljs-keyword">while</span> (v != n - <span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span> (status(v) == UNDISCOVERED)
            SCC(v, clock, S);
        v++;
    }
}

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> hca(x) (fTime(x))           <span class="hljs-comment">//利用闲置的fTime()充当hca(),highest connnected ancestor</span></span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt; <span class="hljs-comment">//顶点类型、边类型</span>
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::SCC(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> &amp;clock, <span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;S)
{
    hca(v) = dTime(v) = ++clock; <span class="hljs-comment">//初始的hca是探测时间</span>
    status(v) = DISCOVERED;
    S.push(v);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> u = firstNbr(v); - <span class="hljs-number">1</span> &lt; u; u = nextNbr(v, u))
        <span class="hljs-keyword">switch</span> (status(u))
        { <span class="hljs-comment">//视u的状态分别处理</span>
        <span class="hljs-keyword">case</span> UNDISCOVERED:
            parent(u) = v;
            type(v, u) = TREE;
            SCC(u, clock, S);                  <span class="hljs-comment">//从顶点u处深入</span>
            hca(v) = <span class="hljs-built_in">std</span>::min(hca(v), hca(u)); <span class="hljs-comment">//更新hca[v]</span>
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> DISCOVERED: <span class="hljs-comment">//在栈中</span>
            type(v, u) = BACKWARD;
            hca(v) = <span class="hljs-built_in">std</span>::min(hca(v), dTime(u)); <span class="hljs-comment">//更新hca[v]</span>
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>: <span class="hljs-comment">//VISITED (有向图),与本算法无关</span>
            type(v, u) = (dTime(v) &lt; dTime(u)) ? FORWARD : CROSS;
            <span class="hljs-keyword">break</span>;
        }

    <span class="hljs-keyword">if</span> (hca(v) == dTime(v))
    { <span class="hljs-comment">//输出一个SCC</span>
        <span class="hljs-comment">//*弹出当前SCC中（包括桥结点v）的所有节点</span>

        <span class="hljs-keyword">while</span> (v != S.top())
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; vertex(S.top());
            status(S.top()) = VISITED; <span class="hljs-comment">//出栈输出宣告访问结束</span>
            S.pop();
        }
        <span class="hljs-keyword">if</span> (direct == DIRECTED) <span class="hljs-comment">//v是桥的顶点，归于本强连通域，需要出栈</span>
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; vertex(S.top()); <span class="hljs-comment">//输出v</span>
            status(S.top()) = VISITED;
            S.pop();
        }
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
    }
}
<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> hca</span>

</div></code></pre>
<p>Kosaraju算法计算scc</p>
<p>按顶点回溯顺序的逆序对原图的反向图进行BFS</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::scc2()
{
    <span class="hljs-keyword">if</span> (direct == UNDIRECTED)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"please try dcc"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-built_in">vector</span>&lt;Tv&gt; path;
    path.reserve(n);
    dfs(<span class="hljs-number">0</span>, path);
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">order</span><span class="hljs-params">(n)</span></span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
        order[i] = i;
    <span class="hljs-built_in">std</span>::sort(order.begin(), order.end(), [&amp;](<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j) <span class="hljs-comment">//获得回溯序列的逆序</span>
              { <span class="hljs-keyword">return</span> fTime(i) &gt; fTime(j); });

    T *G = getRevese&lt;T&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, clock = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;n; i++)
    {
        <span class="hljs-keyword">if</span> (G-&gt;status(i) == UNDISCOVERED)
        {
            path.clear();
            G-&gt;DFS(order[i], clock, path);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : path)
                <span class="hljs-built_in">cout</span> &lt;&lt; i;
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
        }
    }
    <span class="hljs-keyword">delete</span> G;
}

</div></code></pre>
<h3 id="%E4%BC%98%E5%85%88%E7%BA%A7%E6%90%9C%E7%B4%A2pfs">优先级搜索(PFS)</h3>
<p>框架</p>
<p><a href="/home/fengsc/Desktop/cpp/DataStructure/Quene/PrioQueen.h">优先级队列,基于二叉堆</a></p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PU&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::pfs(<span class="hljs-keyword">int</span> s, PU prioUpdater)
{
    reset();
    <span class="hljs-keyword">int</span> v = s;
    <span class="hljs-keyword">do</span>
    {
        <span class="hljs-keyword">if</span> (UNDISCOVERED == status(v))
            PFS(v, prioUpdater);
    } <span class="hljs-keyword">while</span> (s != (v = (++v % n)));
}
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PU&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::PFS(<span class="hljs-keyword">int</span> v, PU prioUpdater, Graph&lt;Tv, Te&gt; &amp;SPTree)
{
    <span class="hljs-comment">//图中顶点初始优先级为INT_MAX</span>
    priority(v) = <span class="hljs-number">0</span>; <span class="hljs-comment">//初始化源顶点</span>
    parent(v) = <span class="hljs-number">-1</span>;
    <span class="hljs-function">IndexMinPQ <span class="hljs-title">Q</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//创建容量为n的下标优先队列</span>
    Q.enqueue(v, priority(v));
    <span class="hljs-keyword">while</span> (!Q.empty())
    {
        v = Q.dequeue();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w = firstNbr(v); w &gt; <span class="hljs-number">-1</span>; w = nextNbr(v, w)) <span class="hljs-comment">//更新在剩余集合中当前顶点邻居的优先级</span>
            <span class="hljs-keyword">if</span> (status(w) == UNDISCOVERED)
            {
                prioUpdater(<span class="hljs-keyword">this</span>, v, w);
                <span class="hljs-keyword">if</span> (Q.exists(w)) <span class="hljs-comment">//更新队列</span>
                    Q.change(w, priority(w));
                <span class="hljs-keyword">else</span>
                    Q.enqueue(w, priority(w));
            }
        status(v) = VISITED; <span class="hljs-comment">//更新选中的新的顶点和相关的边</span>
        <span class="hljs-keyword">int</span> prt = parent(v);
        <span class="hljs-keyword">if</span> (prt != <span class="hljs-number">-1</span>) <span class="hljs-comment">//排除源点</span>
        {
            type(prt, v) = TREE;                          <span class="hljs-comment">//标记原树在生成树对应的边</span>
            SPTree.insert(prt, v, weight(prt, v), (Te)<span class="hljs-number">1</span>); <span class="hljs-comment">//生成树和原图顶点的下标相同</span>
            SPTree.parent(v) = prt;
        }
    }
}
</div></code></pre>
<p>前一个循环对于邻接矩阵复杂度是n^2,对于邻接表是n+e,后一层对于两者都是n^2,用优先级队列以上两项将可达到elogn和nlogn,合计为(n+e)logn,</p>
<p>最小生成树算法</p>
<p>Prim：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::prim(<span class="hljs-keyword">int</span> s, Graph&lt;Tv, Te&gt; &amp;SPTree)
{
    reset();
    <span class="hljs-keyword">auto</span> primPU = [](Graph&lt;Tv, Te&gt; *g, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)
    {
        <span class="hljs-keyword">if</span> (g-&gt;priority(w) &gt; g-&gt;weight(v, w))
        {
            g-&gt;priority(w) = g-&gt;weight(v, w);
            g-&gt;parent(w) = v;
        }
    };
    SPTree.direct = <span class="hljs-keyword">this</span>-&gt;direct;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>-&gt;n; i++) <span class="hljs-comment">//初始化顶点</span>
        SPTree.insert(i);
    PFS(s, primPU, SPTree);
}
</div></code></pre>
<p>复杂度</p>
<p>普通优先队列:时间：ElogE,空间:E</p>
<p>下标优先队列:时间：ElogV,空间:V(主要优势)</p>
<p>区别在于队列的状态，前者无效边会保留在队列，而后者会进行筛选，且判断是否已经存在与队列(堆)的语句复杂度为1</p>
<p>Dilkstra算法，所得路径是最短路径</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Tv, <span class="hljs-keyword">typename</span> Te&gt;
<span class="hljs-keyword">void</span> Graph&lt;Tv, Te&gt;::dijkstra(<span class="hljs-keyword">int</span> s)
{
    reset();
    <span class="hljs-keyword">auto</span> DijkPU = [](Graph&lt;Tv, Te&gt; *g, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w) <span class="hljs-comment">//优先级比较函数</span>
    {
        <span class="hljs-keyword">if</span> (g-&gt;priority(w) &gt; g-&gt;priority(v) + g-&gt;weight(v, w))
        {
            g-&gt;priority(w) = g-&gt;priority(v) + g-&gt;weight(v, w);
            g-&gt;parent(w) = v;
        }
    };
    PFS(s, DijkPU);
}
</div></code></pre>
<p>复杂度同基于下标优先队列的prim算法，但前者不能保证得到最短路径，而后者求最短路径时不能解决带负权边的情况，如果已知最小负权值可以通过将所有权值加至正来解决。</p>
<p>prim算法每次添加的都是离生成树最近的，dilkstra每次添加的是离起点最近的</p>
<h2 id="%E6%9F%A5%E6%89%BE">查找</h2>
<h3 id="hashtable">HashTable</h3>
<p>若关键字为$k$，则其值存放在$f(k)$的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系$f$为散列函数，按这个思想建立的表为散列表<br>
对不同的关键字可能得到同一散列地址，即$k_{1}\neq k_{2}$，而$f(k_{1})=f(k_{2})$，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数$f(k)$和<strong>处理冲突</strong>的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称<strong>散列地址</strong>。<br>
若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为<strong>均匀散列函数（Uniform Hash function）</strong>，这就使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</p>
<p>$装填因子:{\displaystyle {\text{load factor}}\ (\alpha )={\frac {n}{k}}}$</p>
<ul>
<li>n is the number of entries occupied in the hash table.</li>
<li>k is the number of buckets.</li>
</ul>
<h4 id="%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0">散列函数</h4>
<p>散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快定位。</p>
<p>好的散列函数具有的特征:确定，高效，满射(非严格意义，<strong>装填因子越大越好</strong>)，均匀。<br>
**<br>
直接定址法：取关键字或关键字的某个线性函数值为散列地址。即$hash(k)=k或hash(k)=a\cdot k+b，其中{\displaystyle a,b}a,b$为常数（这种散列函数叫做自身函数）</p>
<p>除留余数法：<strong>取关键字被某个不大于散列表表长m的数(<em>可用位与运算取特定位</em>)p除后所得的余数为散列地址</strong>。即 $hash(k)=k,{\bmod ,}p, p\leq m$。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，<strong>一般取素数或m</strong>(合数容易使两个数据的差值和p有非1的最小公倍数时发生冲突），若p选择不好，容易产生冲突，<strong>模p同余等价类的数量越大越好，每个等价类内部的元素越少越好</strong>。</p>
<p>利用秦九韶算法可实现针对字符串的除留余数法，R如果比所有字符都大，<strong>就相当于将字符串看做一个R进制数</strong>，R只要足够小是结果不溢出即可，迭代算法中相对于普通的多项式计算多了对p取余的运算(每一步取余不易溢出)，java用的基数是31，并且JVM会将“31 * i”优化成“（i&lt;&lt;5）- i”</p>
<p>除余法的缺陷：</p>
<ul>
<li>
<p>不动点:H(0)=0;</p>
</li>
<li>
<p>零阶均匀:相邻关键码的散列地址也相邻</p>
</li>
</ul>
<p>改进：MAD法</p>
<p>一阶均匀(不再满足零阶均匀)，消除不动点。</p>
<p>$Hash(key)=(a*key+b)\bmod M,a&gt;0,b&gt;0,M为质数$</p>
<p>考虑高阶还是低阶的均匀性视情况而定。</p>
<p>数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。<br>
平方取中法：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，<strong>而一个数平方后的中间几位数和数的每一位都相关</strong>(分解为一系列左移的和)，由此<strong>使随机分布的关键字得到的哈希地址也是随机的</strong>。取的位数由表长决定。<br>
折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。可以按自右向左的策略加，也可以按往复折返的策略加。对于二进制的key，可以用异或代替加。<br>
(伪)随机数法:C库产生的随机数满足哈希表的要求(某一特定种子产生)，但由于系统之间和编译器不同版本之间具体实现的差异使得可移植性差。$rand(x+1)=[a+rand(x)]\bmod M,a=7^5,M=INT_MAX\hash(key)=rand(key)=[rand(0)\times a^{key}]\bmod m$</p>
<h3 id="%E6%8E%92%E8%A7%A3%E5%86%B2%E7%AA%81">排解冲突</h3>
<h4 id="%E5%A4%9A%E6%A7%BD%E4%BD%8D%E6%B3%95">多槽位法</h4>
<p>每个桶本身再细分为若干槽位，用于存放彼此冲突的词条。每个桶槽位的词典结构为向量，因此整体物理存储结构类似于二维数组。<br>
如：put操作，首先通过hash(key)定位到对应的桶单元，并在该桶内部槽位中进一步查找key，若没找到，则创建新词条插入到该桶的空闲槽位中。</p>
<p>缺点<br>
绝大多数的槽位都处于空闲状态，造成空间浪费。若桶被细分为k个槽位，则装填因子将直接降低为原来的1/k.<br>
很难实现确定应该细分为多少个槽位，才能保证够用。</p>
<h4 id="%E7%8B%AC%E7%AB%8B%E9%93%BE%E6%B3%95%E6%8B%89%E9%93%BE%E6%B3%95">独立链法(拉链法)</h4>
<p>将冲突的元素都放在对应位置的一条链表上。</p>
<p><strong>装填因子是键数与链表数的比值即平均链表长度，大于1</strong>.</p>
<p>优点:</p>
<ul>
<li>
<p>无需为每个桶预留槽位</p>
</li>
<li>
<p>任意次的冲突都可解决</p>
</li>
<li>
<p>删除操作实现简单</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li>
<p>指针需要额外空间</p>
</li>
<li>
<p>节点需要动态申请</p>
</li>
<li>
<p>空间上不连续，不能利用系统缓存加速</p>
</li>
</ul>
<p>一条链表的键数为k的概率在随机情况下(散列函数能将所有的键均匀的散布于各个链表中)满足二项分布，$\alpha$足够小时近似为泊松分布$\frac{\alpha^ke^{-\alpha}}{k!}$，查找长度对$\alpha$的偏离不会太大，条件很难满足，一般使用生成的伪随机数，但在不完全满足均匀的假设下也基本成立。</p>
<h4 id="%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80">开放定址</h4>
<p>装填因子是键数与桶数的比值，小于1</p>
<p>为每个桶预先设立备用桶，构成一个查找链</p>
<h5 id="%E7%BA%BF%E6%80%A7%E8%AF%95%E6%8E%A2">线性试探</h5>
<p>查找时沿查找链逐个转向相邻的下一个桶单元，直到找到或遇到第一个空桶查找失败</p>
<p>缺点是以往的冲突会导致后面的冲突，并且不能装满，当$\alpha=1$时前面的冲突会导致无限循环。</p>
<p>懒惰删除(逻辑删除)</p>
<p>由于直接删除会切断查找链，所以删除时只标记，不实际删除，查找时越过，插入时看做空桶插入并修改标记</p>
<p>也是一个缺点，所以开放定制不适合</p>
<h4 id="%E5%B9%B3%E6%96%B9%E8%AF%95%E6%8E%A2">平方试探</h4>
<p>查找链中递增的gap变为平方,$[hash(key)+i^2]\bmod m$，各桶间间距线性递增，聚集线性缓解，前面的冲突对后面的影响大大降低；</p>
<p>缺点：</p>
<ul>
<li>
<p>一旦涉及外存(容量较大)，会破坏数据访问的局部性，缓存功能一定程度失效，I/O将激增，一般情况不会发生(对于一块1Kb的缓存，连续查找失败$\sqrt{1024/4}=16$次才会发生I/0交换，之后的探测需要其它地方存储的数据)</p>
</li>
<li>
<p>部分空桶不会被探测到，浪费空间</p>
</li>
</ul>
<p>$n^2\bmod M$的可能取值的上界是$\lceil \frac{M}{2} \rceil$，即必须满足$\alpha \leq0.5$</p>
<p>当M为素数时达到这个上界，且都集中在查找链的前端。</p>
<p>证明：反证法，假设存在$ 0&lt;a&lt;b&lt;\lceil \frac{M}{2} \rceil$,使得沿着查找链，第a项与第b项彼此冲突，于是$a^2$与$b^2$同属M的某一同余类，即$a^2\equiv b^2;\bmod M \Rightarrow b^2-a^2=(b+a)(b-a)\equiv 0;\bmod M，然而，由假设知0&lt;b-a&lt;b+a&lt;M$,b+a至少为2,是M的非平凡的因子，它与b-a之积不可能整除一个素数，假设不成立，故查找链的前半部分互异。</p>
<h4 id="%E5%8F%8C%E5%90%91%E5%B9%B3%E6%96%B9%E8%AF%95%E6%8E%A2%E4%BA%8C%E6%AC%A1%E6%8E%A2%E6%B5%8B%E6%B3%95">双向平方试探(二次探测法)</h4>
<p>按$[hash(key)+i^2]\bmod m，[hash(key)-i^2]\bmod m$的方式双向试探</p>
<p>费马平方和定理</p>
<p>一个素数可以被分解为两个整数的平方之和，当且仅当它们是模4余1的。</p>
<p>由$(u^2+v^2)(s^2+t^2)=(us+vt)^2+(ut-vs)^2$可知一个整数可以表示为两个整数的平方和的形式，当且仅当它的素分解(质因数分解定理,$45=3*5^2$)中的模4余3类的素数的幂次为偶数(令$v^2=0,此项等于u^2$即可与其它平方和项合并)，素数分解式迭代调用上式即可得到最终的分解式</p>
<p>当表长M为$4k+3$形式的素数，即素数的模4余3类时，双向平方试探的前M步不会发生冲突</p>
<p>证明:反证法，取M=4k+1，则查找链中的a,b两项满足$1\leq b&lt;a\leq \lfloor\frac{M}{2}\rfloor$(初始是第0项)，假设a,b的位置发生了冲突，则有$-b^2\equiv a^2;\bmod M\Rightarrow n=a^2+b^2\equiv 0;\bmod M$,则M是n的一个素因子，又M是模4余3的，所以它的平方(必然存在的一个偶幂次)也是n的因子，故$a^2+b^2\geq M$,这与条件是矛盾的，故假设不成立。</p>

</body>
</html><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });</script>
