# cpp

## from c to cpp

### 类（Class）和对象（Object）

类（Class）可以看做C语言中结构体（Struct）的升级版。C++ 中的类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象”。可以将类比喻成图纸，对象比喻成零件，图纸说明了零件的参数（成员变量）及其承担的任务（成员函数）；一张图纸可以生产出多个具有相同性质的零件，不同图纸可以生产不同类型的零件。在 C++ 中，通过类名就可以创建对象，即将图纸生产成零件，这个过程叫做类的**实例化**，因此也称**对象是类的一个实例（Instance）**。有些资料也将**类的成员变量称为属性（Property）**，将**类的成员函数称为方法（Method）**。

因为 C++、Java、C#、PHP 等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言。

在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，将拥有相关功能的多个函数放在一个源文件，再提供一个对应的头文件，这就是一个模块。使用模块时，引入对应的头文件就可以。

而在 C++ 中，多了一层封装，就是类（Class）。**类由一组相关联的函数、变量组成**，可以将一个类或多个类放在一个源文件，使用时引入对应的类就可以。下面是C和C++项目组织方式的对比：

![a](http://c.biancheng.net/uploads/allimg/190212/100PJ491-0.png)

![](http://c.biancheng.net/uploads/allimg/190212/100PK0J-1.png)

---

面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。

### 命名空间（Namespace）和头文件

namespace 是C++中的关键字，用来定义一个命名空间，语法格式为：

~~~cpp
namespace name{
//variables, functions, classes
}
~~~

name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。

使用变量、函数时要指明它们所在的命名空间。以上面的 fp 变量为例，可以这样来使用：
Li::fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
**::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。**

~~~cpp
using Li::fp;//using 声明以后的程序中如果出现了未指明命名空间的 fp，就使用 Li::fp；
using namespace Li;//声明整个命名空间,在 using 声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间 Li 中的变量。
~~~

站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（Symbol）。有的符号可以指代一个**内存位置**，例如变量名、函数名；有的符号仅仅是一个**新的名称**，例如 typedef 定义的类型别名。

using namespace std;，它声明了命名空间 std，后续如果有未指定命名空间的符号，那么默认使用 std，代码中的 string、cin、cout 都位于命名空间 std。

将 std 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，推荐在函数内部声明 std,**但一般为了方便放在函数外部。**

新版 C++ 库中C语言的stdio.h变成了cstdio，stdlib.h变成了cstdlib

使用新C库函数前必须加上std::，但不加可能能通过；用C++的新库即可（功能更全更强大），或者用不带开头c的旧C库

### 输入输出cin，cout

使用 cout 进行输出时需要紧跟<<运算符，使用 cin 进行输入时需要紧跟>>运算符，这两个运算符可以自行分析所处理的数据类型，因此无需像使用 scanf 和 printf 那样给出格式控制字符串。

```cpp
cin>>a>>b;
    cout<<a<<b<<endl;//count<<x<<'\n';//count<<"a is :\n"<<a;
```

### bool and const

C++ 新增了 bool 类型（布尔类型），它一般占用 1个字节长度。bool 类型只有两个取值，true 和 false：true 表示“真”，false 表示“假”

**bool flag;  //定义布尔变量**   flag = a > b;

C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

如果使用的是 GCC，那么可以通过添加 extern 关键字来增大 C++ 全局 const 变量的可见范围，如下所示：

extern const int n = 10;

这样 n 的可见范围就变成了整个程序，在其他文件中使用 extern 声明后就可以使用了。不过这种方式只适用于 GCC，不适用于 VS/VC。

#define 定义的常量仅仅是字符串的替换，不会进行类型检查，而 const 定义的常量是有类型的，编译器会进行类型检查，相对来说比 #define 更安全，所以鼓励使用 const 代#define。

const int n = 10;

在C++中，printf("%d\n", n);语句在编译时就将 n 的值替换成了 10，效果和printf("%d\n", 10);一样，**不管 n 所在的内存如何变化，都不会影响输出结果**。

### new和delete简介

在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。

用 new 和 delete 分配内存更加简单：

~~~cpp
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存
~~~

**new 操作符会根据后面的数据类型来推断所需空间的大小**。

如果希望分配一组连续的数据，可以使用 new[]：

~~~cpp
int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
~~~

用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。

和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。

### inline内联函数

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。

指定内联函数的方法很简单，只需要在函数定义处增加 inline 关键字。注意，要在函数**定义处添加 inline 关键字**，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。

当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

由于内联函数比较短小，我们通常的做法是**省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方**。

~~~cpp
#include <iostream>
using namespace std;
//内联函数，交换两个数的值
inline void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main(){
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;
    return 0;
}
~~~

使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。

对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。

#define SQ(y) ( (y)*(y) )

发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，所以在编写C++代码时推荐**使用内联函数来替换带参数的宏**。

和宏一样，**内联函数可以定义在头文件中（不用加 static 关键字）**，并且头文件被多次#include后也不会引发重复定义错误。这一点和非内联函数不同，非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include后会引发重复定义错误。

内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。

在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举）。

### 函数的默认参数

在C++中，定义函数时可以给形参指定一个默认的值，这样调用函数时如果没有给这个形参赋值（没有对应的实参），那么就使用这个默认的值。也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。

~~~cpp
#include<iostream>
using namespace std;
//带默认参数的函数
void func(int n, float b=1.2, char c='@'){
    cout<<n<<", "<<b<<", "<<c<<endl;
}
int main(){
    //为所有参数传值
    func(10, 3.5, '#');
    //为n、b传值，相当于调用func(20, 9.8, '@')
    func(20, 9.8);
    //只为n传值，相当于调用func(30, 1.2, '@')
    func(30);
    return 0;
}
~~~

C++规定，默认参数只能放在形参列表的最后，而且**一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值**。实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。

**不能在函数定义和函数声明中同时指定默认参数,在给定的作用域中一个形参只能被赋予一次默认参数。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。**

### 函数重载和其二义性

C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（**Function Overloading**）。借助重载，一个函数名可以有多种用途。

**参数列表又叫参数签名**，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。

~~~cpp
void Swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}
//交换 float 变量的值
void Swap(float *a, float *b){
    float temp = *a;
    *a = *b;
    *b = temp;
}
//交换 char 变量的值
void Swap(char *a, char *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}

~~~

C++代码在编译时会根据参数列表对函数进行重命名，例如void Swap(int a, int b)会被重命名为_Swap_int_int，void Swap(float x, float y)会被重命名为_Swap_float_float。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做**重载决议（Overload Resolution**）。

函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

1. 参数数目引发的歧义

   ~~~cpp
   1 int get(){
   2     return 5;
   3 }
   4 int get(int a = 5){
   5     return a;
   6 }
   7 //调用get()
   //不给参数和有默认参数会造成歧义。
   ~~~
2. 参数隐式转换引发的歧义

   ~~~cpp
   1 int get(int m){
   2     return m;
   3 }
   4  
   5 long get(long m){
   6     return m;
   7 }
   //double d = 1.234;
   //调用get(d);double既可以隐式转换未long，也可以是int,或者说一般的数值类型之间都可以进行隐式类型转换，故无法确定那一个更加匹配。
   ~~~

3.类型型相关歧义（较深内容，先放下）

### C和C++混合编程

直接混合会出问题

~~~cpp
/myfun.h
void display();
//myfun.c
#include <stdio.h>
#include "myfun.h"
void display(){
   printf("C++：http://c.biancheng/net/cplus/");
}
//main.cpp
#include <iostream>
#include "myfun.h"
using namespace std;
int main(){
   display();
   return 0;
}
~~~

因为 C++ 和 C 编译程序的方式存在差异。C 语言是不支持函数重载的，它不会在编译阶段对函数的名称做较大的改动.

C++程序中的非标准C头文件需要前面用extern “C“{}包起来;

~~~cpp
extern "C" #include lalala.h //一个不用大括号
~~~

或者直接更改非标准的头文件（c和c++程序都能直接引用）

~~~cpp
#ifdef __cplusplus//（函数声明出现两次)
extern "C" void display();
#else
void display();
#endif
~~~

实际开发中，使用这种方式

~~~cpp
#ifdef __cplusplus//（函数声明出现一次）
extern "C" {//前面加这些
#endif
void display();
#ifdef __cplusplus//后面加这些
}
#endif
~~~

## 类和对象

### 类的定义和对象的创建
