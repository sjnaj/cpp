- [cpp](#cpp)
  - [from c to cpp](#from-c-to-cpp)
    - [类（Class）和对象（Object）](#类class和对象object)
    - [命名空间（Namespace）和头文件](#命名空间namespace和头文件)
    - [命名规范](#命名规范)
    - [输入输出cin，cout](#输入输出cincout)
    - [bool and const](#bool-and-const)
    - [堆和栈](#堆和栈)
    - [new和delete](#new和delete)
    - [C和C++结构体的差异](#c和c结构体的差异)
    - [inline内联函数](#inline内联函数)
    - [函数的默认参数](#函数的默认参数)
    - [函数重载和其二义性](#函数重载和其二义性)
    - [C和C++混合编程](#c和c混合编程)
  - [类和对象](#类和对象)
    - [类的定义和对象的创建](#类的定义和对象的创建)
    - [类成员访问权限](#类成员访问权限)
    - [全局函数](#全局函数)
    - [类型成员(typedef和using)](#类型成员typedef和using)
    - [类的作用域](#类的作用域)
    - [C++程序编译原理和man和exec](#c程序编译原理和man和exec)
    - [内存四区](#内存四区)
    - [构造函数及其初始化列表和对象数组](#构造函数及其初始化列表和对象数组)
    - [复制构造函数](#复制构造函数)
    - [析构函数](#析构函数)
    - [default和delete](#default和delete)
    - [this指针](#this指针)
    - [静态成员变量和静态成员函数](#静态成员变量和静态成员函数)
    - [const成员变量和成员函数（常成员函数）](#const成员变量和成员函数常成员函数)
    - [static const](#static-const)
    - [const](#const)
    - [C++成员对象和封闭类和封闭类](#c成员对象和封闭类和封闭类)
    - [友元函数和友元类](#友元函数和友元类)
    - [结构体和对象的异同](#结构体和对象的异同)
    - [C++string](#cstring)
    - [操作string中的字符](#操作string中的字符)
    - [字符串字面量(String literal)](#字符串字面量string-literal)
      - [getline and stringstream](#getline-and-stringstream)
  - [C++引用](#c引用)
    - [基本](#基本)
    - [返回引用](#返回引用)
    - [指针与引用](#指针与引用)
    - [临时变量、引用参数和const引用](#临时变量引用参数和const引用)
    - [右值引用和移动构造函数](#右值引用和移动构造函数)
    - [移动构造函数](#移动构造函数)
  - [继承和派生](#继承和派生)
    - [基本](#基本-1)
    - [基类和派生类构造和析构函数](#基类和派生类构造和析构函数)
    - [多继承](#多继承)
    - [借助指针访问非public变量](#借助指针访问非public变量)
    - [虚继承](#虚继承)
    - [虚继承的构造函数](#虚继承的构造函数)
    - [向上转型](#向上转型)
  - [多态和虚函数](#多态和虚函数)
    - [基本](#基本-2)
    - [虚析构函数的必要性](#虚析构函数的必要性)
    - [纯虚函数和抽象类](#纯虚函数和抽象类)
    - [虚函数表](#虚函数表)
    - [typeid运算符：获取类型信息](#typeid运算符获取类型信息)
    - [RTTI](#rtti)
  - [运算符重载](#运算符重载)
  
# cpp

## from c to cpp

### 类（Class）和对象（Object）

类（Class）可以看做C语言中结构体（Struct）的升级版。C++ 中的类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象”。可以将类比喻成图纸，对象比喻成零件，图纸说明了零件的参数（成员变量）及其承担的任务（成员函数）；一张图纸可以生产出多个具有相同性质的零件，不同图纸可以生产不同类型的零件。在 C++ 中，通过类名就可以创建对象，即将图纸生产成零件，这个过程叫做类的**实例化**，因此也称**对象是类的一个实例（Instance）**。有些资料也将**类的成员变量称为属性（Property）**，将**类的成员函数称为方法（Method）**。

因为 C++、Java、C#、PHP 等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言。

在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，将拥有相关功能的多个函数放在一个源文件，再提供一个对应的头文件，这就是一个模块。使用模块时，引入对应的头文件就可以。

而在 C++ 中，多了一层封装，就是类（Class）。**类由一组相关联的函数、变量组成**，可以将一个类或多个类放在一个源文件，使用时引入对应的类就可以。下面是C和C++项目组织方式的对比：

![a](http://c.biancheng.net/uploads/allimg/190212/100PJ491-0.png)

![](http://c.biancheng.net/uploads/allimg/190212/100PK0J-1.png)

---

面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。

### 命名空间（Namespace）和头文件

namespace 是C++中的关键字，用来定义一个命名空间，语法格式为：

```cpp
namespace name{
//variables, functions, classes
}
```

name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。

使用变量、函数时要指明它们所在的命名空间。以上面的 fp 变量为例，可以这样来使用：
Li::fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
**::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。**

```cpp
using Li::fp;//using 声明以后的程序中如果出现了未指明命名空间的 fp，就使用 Li::fp；
using namespace Li;//声明整个命名空间,在 using 声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间 Li 中的变量。
```

站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（Symbol）。有的符号可以指代一个**内存位置**，例如变量名、函数名；有的符号仅仅是一个**新的名称**，例如 typedef 定义的类型别名。

using namespace std;，它声明了命名空间 std，后续如果有未指定命名空间的符号，那么默认使用 std，代码中的 string、cin、cout 都位于命名空间 std。

将 std 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，推荐在函数内部声明 std,**但一般为了方便放在函数外部。**

新版 C++ 库中C语言的stdio.h变成了cstdio，stdlib.h变成了cstdlib

使用新C库函数前必须加上std::，但不加可能能通过；用C++的新库即可（功能更全更强大），或者用不带开头c的旧C库


### 命名规范

标识符为复合长单词一般都用驼峰(单词交界后一个单词首字母大写)

变量adj+n;函数v+n

简单变量用小写单词，类名和全局函数名首字母大写，成员函数和复杂变量名首字母小写，常量（define,const）全大写（MAXN），静态变量前加s_,全局变量前加g_,类的数据成员加前缀m_
### 输入输出cin，cout

使用 cout 进行输出时需要紧跟<<运算符，使用 cin 进行输入时需要紧跟>>运算符，这两个运算符可以自行分析所处理的数据类型.

```cpp
cin>>a>>b;
    cout<<a<<b<<endl;//count<<x<<'\n';//count<<"a is :\n"<<a;
```
控制符是在头文件**iomanip**中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream 中定义的


控制符示例：

```cpp
#include <iostream>
#include <iomanip>//不要忘记包含此头文件
using namespace std;
int main()
{
   int a;
   cout<<"input a:";
   cin>>a;
   cout<<"dec:"<<dec<<a<<endl;  //以十进制形式输出整数
   cout<<"hex:"<<hex<<a<<endl;  //以十六进制形式输出整数a
   cout<<"oct:"<<setbase(8)<<a<<endl;  //以八进制形式输出整数a
   char *pt="China";  //pt指向字符串"China"
   cout<<setw(10)<<pt<<endl;  //指定域宽为,输出字符串
   cout<<setfill('*')<<setw(10)<<pt<<endl;  //指定域宽,输出字符串,空白处以'*'填充
   double pi=22.0/7.0;  //计算pi值
   //按指数形式输出,8位小数
   cout<<setiosflags(ios::scientific)<<setprecision(8);
   cout<<"pi="<<pi<<endl;  //输出pi值
   cout<<"pi="<<setprecision(4)<<pi<<endl;  //改为位小数
   cout<<"pi="<<setiosflags(ios::fixed)<<pi<<endl;  //改为小数形式输出
   return 0;
}
```


| 流成员函数 |	与之作用相同的控制符 |	作用 |    
|----------|--------------|--------------------------|
| precision(n) |	setprecision(n)| 	设置实数的精度为n位 | 
| width(n)	|setw(n)	 | 设置字段宽度为n位，**右对齐** | 
| fill(c)	|setfill(c)	| 设置填充宇符c | 
| setf() |	setiosflags() |	设置输出格式状态，括号中应给出**格式状态**，内容与控制符setiosflags括号中的内容相同  |
| unsetf() |	resetioflags()	 |终止已设置的输出格式状态，在括号中应指定内容 |


**设置字段宽度和填充字符的函数或控制符只对其后的第一个输出项有效**

流成员函数setf和控制符setiosflags括号中的参数表示格式状态，它是通过格式标志来指定的。格式标志在类ios中被定义为枚举值。因此在引用这些格式标志时要在前面加上**类名ios和域运算符“::”**

流成员函数示例：

```cpp
#include <iostream>
using namespace std;
int main( )
{
   int a=21
   cout.setf(ios::showbase);//显示基数符号(0x或)
   cout<<"dec:"<<a<<endl;         //默认以十进制形式输出a
   cout.unsetf(ios::dec);         //终止十进制的格式设置
   cout.setf(ios::hex);           //设置以十六进制输出的状态
   cout<<"hex:"<<a<<endl;         //以十六进制形式输出a
   cout.unsetf(ios::hex);         //终止十六进制的格式设置
   cout.setf(ios::oct);           //设置以八进制输出的状态
   cout<<"oct:"<<a<<endl;         //以八进制形式输出a
   cout.unseft(ios::oct);
   char *pt="China";              //pt指向字符串"China"
   cout.width(10);                //指定域宽为
   cout<<pt<<endl;                //输出字符串
   cout.width(10);                //指定域宽为
   cout.fill('*');                //指定空白处以'*'填充
   cout<<pt<<endl;                //输出字符串
   double pi=22.0/7.0;            //输出pi值
   cout.setf(ios::scientific);    //指定用科学记数法输出
   cout<<"pi=";                   //输出"pi="
   cout.width(14);                //指定域宽为
   cout<<pi<<endl;                //输出pi值
   cout.unsetf(ios::scientific); //终止科学记数法状态
   cout.setf(ios::fixed);        //指定用定点形式输出
   cout.width(12);               //指定域宽为
   cout.setf(ios::showpos);      //正数输出“+”号
   cout.setf(ios::internal);     //数符出现在左侧
   cout.precision(6);            //保留位小数
   cout<<pi<<endl;               //输出pi,注意数符“+”的位置
   return 0;
}
```
系统默认指定为dec，因此要改变为hex或oct，也应当先用unsetf 函数终止原来设置。

如果两个相互矛盾的标志同时被设置，如先设置 setiosflags(ios::fixed)，然后又设置 setiosflags(ios::scientific)，那么结果可能就是两个标志都不起作用。因此，在设置了某标志，又要设置其他与之矛盾的标志时，就应该用 **reset或unsetf**清除原先的标志。

用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替：
    cout.setf(ios::internal I ios::showpos);  //包含两个状态标志，用"|"组合；

 控制格式组合： cout<<setiosflags(ios::fixed)<<setiosflags(ios::right)<<setprecision(2);

 cout>>setw(12)>>setprecision(6)==cout.width(12);cout.precision(6);

 **组合控制各个控制符或函数的顺序不特定**


| 格式标志 |	作用|
|------------|-------------------------------------|
| ios::left	| 输出数据在本域宽范围内向左对齐 |
| ios::right |	输出数据在本域宽范围内向右对齐 |
| ios::internal|	数值的符号位在域宽内左对齐，数值右对齐，中间由填充字符填充 |
| ios::dec	|设置整数的基数为10 |
| ios::oct|	设置整数的基数为8 |
| ios::hex |	设置整数的基数为16 |
| ios::showbase	| 强制输出整数的基数(八进制数以0打头，十六进制数以0x打头) |
| ios::showpoint|	强制输出浮点数的小点和尾数0 |
| ios::uppercase |	在以科学记数法格式E和以**十六进制**输出字母时以大写表示 |
| ios::showpos |	对正数显示“+”号 |
| ios::scientific |	浮点数以科学记数法格式输出 |
| ios::fixed |	浮点数以定点格式(小数形式)输出 |
| ios::unitbuf |	每次输出之后刷新所有的流 |
| ios::stdio |	每次输出之后清除stdout, stderr |



### bool and const

C++ 新增了 bool 类型（布尔类型），它一般占用 1个字节长度。bool 类型只有两个取值，true 和 false：true 表示“真”，false 表示“假”

**bool flag;  //定义布尔变量**   flag = a > b;

C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：**C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。**

如果使用的是 GCC，那么可以通过添加 extern 关键字来增大 C++ 全局 const 变量的可见范围，如下所示：

extern const int n = 10;

这样 n 的可见范围就变成了整个程序，在其他文件中使用 extern 声明后就可以使用了。不过这种方式只适用于 GCC，不适用于 VS/VC。

#define 定义的常量仅仅是字符串的替换，不会进行类型检查，而 const 定义的常量是有类型的，编译器会进行类型检查，相对来说比 #define 更安全，所以鼓励使用 const 代#define。

const int n = 10;

在C++中，printf("%d\n", n);语句在编译时就将 n 的值替换成了 10，效果和printf("%d\n", 10);一样，**不管 n 所在的内存如何变化，都不会影响输出结果**。

### 堆和栈

栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，例如，分配专门的寄存器存放栈的地址，压栈出栈都有专门的执行指令，这就决定了栈的效率比较高。一般而言，只要栈的剩余空间大于所申请空间，系统就将为程序提供内存，否则将报异常提示栈溢出。

而堆则不同，它是由 C/C++ 函数库提供的，它的机制也相当复杂。例如，为了分配一块堆内存，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。而对于大多数系统，会在这块内存空间的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确释放本内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中。很显然，堆的分配效率比栈要低得多。

### new和delete

在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。

**new和delete是关键字，malloc和free是函数。**

用 new 和 delete 分配内存更加简单：

```cpp
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存
```

**new 操作符会根据后面的数据类型来推断所需空间的大小**。

如果希望分配一组连续的数据，可以使用 new[]：

```cpp
int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
```

用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。

和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，**通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现**，并且不要和C语言中 malloc()、free() 一起混用。

malloc 申请完空间之后不会对内存进行必要的初始化，而 new 可以。

string *ps = new string("hello world");

new int()是创建一个int型数，并且用()括号中的数据进行初始化,例如：
int *p = new int(10); // p指向一个值为10的int数。

```cpp
void *operator new(size_t);     //allocate an object
void *operator delete(void *);    //free an object

void *operator new[](size_t);     //allocate an array
void *operator delete[](void *);    //free an array
```

如果想定制自己的在堆对象被建立时的内存分配过程，可以自定义operator new函数。然后使用new操作符，new操作符会调用定制的operator new。

operator new分配内存并返回指针，相当于malloc.

new在调用operator new后还会调用（默认）构造函数（如果有的话，内置类型没有）；

new [] 一个对象数组时，需要保存数组的维度，C++ 的做法是在分配数组空间时多分配了 4 个字节的大小，专门保存数组的大小，在 delete [] 时就可以取出这个保存的数，**就知道了需要调用析构函数多少次了。**

申请时在数组对象的上面还**多分配了 4 个字节用来保存数组的大小**，但是最终返回的是对象数组的指针，而不是所有分配空间的起始地址。

调用析构函数的次数是从数组对象指针前面的 4 个字节中取出；
传入 operator delete[] 函数的参数不是数组对象的指针 pAa，而是 pAa 的值减 4。

如果不调用析构函数呢（如内置类型， int 数组）？在 new [] 时就没必要多分配那 4 个字节， delete [] 时直接到第二步释放为 int 数组分配的空间。如果这里使用 delete pia;那么将会调用 operator delete 函数，传入的参数是分配给数组的起始地址，所做的事情就是释放掉这块内存空间。不存在问题的。

```cpp
class A *pAa = new class A[3];
delete pAa;
```

调用一次 pAa 指向的对象的析构函数；
调用 operator delete(pAa); 释放内存。
显然，这里只对数组的第一个类对象调用了析构函数，后面的两个对象均没调用析构函数，如果类对象中申请了大量的内存需要在析构函数中释放，而你却在销毁数组对象时少调用了析构函数，这会造成内存泄漏。

```cpp
typedef struct _CrtMemBlockHeader
{
    struct _CrtMemBlockHeader *pBlockHeaderNext;//下一个结构体指针
    struct _CrtMemBlockHeader *pBlockHeaderPrev;//上一个结构体指针
    char    *szFileName;//szFileName是存储的发起分配操作的那行代码所在的文件的路径和名称
    int       nLine;//代码行号
    size_t  nDataSize;//请求分配的大小(字节)
    int        nBlockUse;//块类型。其中，1是自己调用、2为库函数调用、0为未调用。
    long     lRequest;   //堆申请次数
    unsigned char gap[nNoMansLandSize]; //溢出标志。其中，nNoMansLandSize = 4
} _CrtMemBlockHeader;
```

\<your data\>前后各4个字节的 gap[],前后的gap都为 0xFD. （前一个在_CrtMemBlockHeader里），如果你在自己的Data里写, 不小心越了界(前面或者后面), 系统在delete的时候通过检查 gap 的数据是否还为0xFD，就知道你有没有越界. 当然了, 如果恰好写的都是0xFD, 那就没法知道了.

```cpp
+--------------------------------------------------------------------------+
|   +--------------------------+              +--------------------------+ |
+-> | pHead = pBlockHeaderNext | -----------> | pBlockHeaderNext = NULL  | |
    |--------------------------|              |--------------------------| |
    | pBlockHeaderPrev = NULL  |              | pBlockHeaderPrev      ->-|-+
    |--------------------------|              |--------------------------|
    |          ......          |              |          ......          |
    |--------------------------|              |--------------------------|
    |gap: FDFDFDFD             |              |gap: FDFDFDFD             |
    |--------------------------|              |--------------------------|
    |pA: CDCDCDCD              |              |pB: CDCDCDCD              |
    |--------------------------|              |--------------------------|
    |anotherGap: FDFDFDFD      |              |anotherGap: FDFDFDFD      |
    +--------------------------+              +--------------------------+
```

**这个head结构体也是free不用传入大小的原因**。

对于没有构造函数的内置类型的分配形式

**_CrtMemBlockHeader + \<Your Data\>+gap[nNoMansLandSize]**;这类数据用delete和delete[]都一样！

而对于有构造函数的类型数组则是：

**_CrtMemBlockHeader +数组元素个数+ \<Your Data\> +gap[nNoMansLandSize];**

delete PaA会先执行PaA（+0）的析构函数后直接将指针前的八个字节当作phead(加[]就会先向前退4个字节再确认phead)，**溢出标志gap发生变化**，可能会出现Assert fail即段错误。operator delete产生错误。

运行时不会出错，只调用了一个析构函数然后释放内存。debug模式时会出错；

**在release模式（本编译器）使用默认析构函数时不会报错且不会储存数组元素个数，自定义析构函数就会储存数组元素个数并报错。** ***可能是默认析构函数以和为贵***

```cpp

有~A(){}
0x55555556aea8:	0x21	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aeb0:	！0x04	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aeb8:	0x01	0x00	0x00	0x00	0x02	0x00	0x00	0x00
0x55555556aec0:	0x03	0x00	0x00	0x00	0x04	0x00	0x00	0x00
0x55555556aec8:	0x41	0xf1	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aed0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aed8:	0x00	0x00
没有：
0x55555556aea0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aea8:	！0x21	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aeb0:	0x01	0x00	0x00	0x00	0x02	0x00	0x00	0x00
0x55555556aeb8:	0x03	0x00	0x00	0x00	0x04	0x00	0x00	0x00
0x55555556aec0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aec8:	0x41	0xf1	0x00	0x00	0x00	0x00	0x00	0x00
0x55555556aed0:	0x00	0x00




```

总的来说，记住一点即可：**new/delete、new[]/delete[] 要配套使用总是没错的**！

**-exec x/50xb p-4:50个，16进制，一字节，从p前4*4（int）处开始；**

### C和C++结构体的差异

C的结构体内不允许有函数存在，C++允许有内部成员函数，且允许该函数是虚函数。所以C的结构体是没有构造函数、析构函数、和this指针的。

C的结构体对内部成员变量的访问权限只能是public，而C++允许public,protected,private三种。

C语言的结构体是不可以继承的，C++的结构体是可以从其他的结构体或者类继承过来的。

C++的结构体定义时不用写struct，也就**不用别名**

### inline内联函数

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。

指定内联函数的方法很简单，只需要在函数定义处增加 inline 关键字。注意，要在函数**定义处添加 inline 关键字**，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。

当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

由于内联函数比较短小，我们通常的做法是**省略函数原型，将整个函数定义（包括函数头和函数体）放在本应该提供函数原型的地方**。

```cpp
#include <iostream>
using namespace std;
//内联函数，交换两个数的值
inline void swap(int *a, int *b){
    int temp;
    temp = *a;
    *a = *b;
    *b = temp;
}
int main(){
    int m, n;
    cin>>m>>n;
    cout<<m<<", "<<n<<endl;
    swap(&m, &n);
    cout<<m<<", "<<n<<endl;
    return 0;
}
```

使用内联函数的缺点也是非常明显的，编译后的程序会存在多份相同的函数拷贝，如果被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。

对函数作 inline 声明只是程序员对编译器提出的一个建议，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。

#define SQ(y) ( (y)*(y) )

发生函数调用时，编译器会先对实参进行计算，再将计算的结果传递给形参，并且函数执行完毕后会得到一个值，而不是得到一个表达式，这和简单的字符串替换相比省去了很多麻烦，所以在编写C++代码时推荐**使用内联函数来替换带参数的宏**。

和宏一样，**内联函数可以定义在头文件中（不用加 static 关键字）**，并且头文件被多次#include后也不会引发重复定义错误。这一点和非内联函数不同，**非内联函数是禁止定义在头文件中的，它所在的头文件被多次#include后会引发重复定义错误。**

内联函数虽然叫做函数，在定义和声明的语法上也和普通函数一样，但它已经失去了函数的本质。函数是一段可以重复使用的代码，它位于虚拟地址空间中的代码区，也占用可执行文件的体积，而内联函数的代码在编译后就被消除了，不存在于虚拟地址空间中，没法重复使用。

在多文件编程时，我建议将内联函数的定义直接放在头文件中，并且禁用内联函数的声明（声明是多此一举）。

### 函数的默认参数

在C++中，定义函数时可以给形参指定一个默认的值，这样调用函数时如果没有给这个形参赋值（没有对应的实参），那么就使用这个默认的值。也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值，否则使用参数的默认值。

```cpp
#include<iostream>
using namespace std;
//带默认参数的函数
void func(int n, float b=1.2, char c='@'){
    cout<<n<<", "<<b<<", "<<c<<endl;
}
int main(){
    //为所有参数传值
    func(10, 3.5, '#');
    //为n、b传值，相当于调用func(20, 9.8, '@')
    func(20, 9.8);
    //只为n传值，相当于调用func(30, 1.2, '@')
    func(30);
    return 0;
}
```

C++规定，默认参数只能放在形参列表的最后，而且**一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值**。实参和形参的传值是从左到右依次匹配的，默认参数的连续性是保证正确传参的前提。

**不能在函数定义和函数声明中同时指定默认参数,在给定的作用域中一个形参只能被赋予一次默认参数。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认值，而且该形参右侧的所有形参必须都有默认值。**

### 函数重载和其二义性

C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（**Function Overloading**）。借助重载，一个函数名可以有多种用途。

**参数列表又叫参数签名**，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。

```cpp
void Swap(int *a, int *b){
    int temp = *a;
    *a = *b;
    *b = temp;
}
//交换 float 变量的值
void Swap(float *a, float *b){
    float temp = *a;
    *a = *b;
    *b = temp;
}
//交换 char 变量的值
void Swap(char *a, char *b){
    char temp = *a;
    *a = *b;
    *b = temp;
}

```

C++代码在编译时会根据参数列表对函数进行重命名，例如void Swap(int a, int b)会被重命名为_Swap_int_int，void Swap(float x, float y)会被重命名为_Swap_float_float。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做**重载决议（Overload Resolution**）。

函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

1. 参数数目引发的歧义

   ```cpp
   1 int get(){
   2     return 5;
   3 }
   4 int get(int a = 5){
   5     return a;
   6 }
   7 //调用get()
   //不给参数和有默认参数会造成歧义。
   ```

2. 参数隐式转换引发的歧义

   ```cpp
   1 int get(int m){
   2     return m;
   3 }
   4  
   5 long get(long m){
   6     return m;
   7 }
   //double d = 1.234;
   //调用get(d);double既可以隐式转换为long，也可以是int,或者说一般的数值类型之间都可以进行隐式类型转换，故无法确定哪一个更加匹配。
   ```

3.类型型相关歧义（较深内容，先放下）

### C和C++混合编程

直接混合会出问题

```cpp
/myfun.h
void display();
//myfun.c
#include <stdio.h>
#include "myfun.h"
void display(){
   printf("C++：http://c.biancheng/net/cplus/");
}
//main.cpp
#include <iostream>
#include "myfun.h"
using namespace std;
int main(){
   display();
   return 0;
}
```

因为 C++ 和 C 编译程序的方式存在差异。C 语言是不支持函数重载的，它不会在编译阶段对函数的名称做较大的改动.

C++程序中的非标准C头文件需要前面用extern “C“{}包起来;

C程序不能识别extern

```cpp
extern "C" #include "lalala.h" //一个不用大括号
```

或者直接更改非标准的头文件（c和c++程序都能直接引用）

```cpp
#ifdef __cplusplus//（函数声明出现两次)
extern "C" void display();
#else
void display();
#endif
```

实际开发中，使用这种方式,函数只需写一遍

```cpp
#ifdef __cplusplus//（函数声明出现一次）
extern "C" {
#endif//前面加这些

void display();//对外接口
Func1...;
Func2...;

#ifdef __cplusplus//后面加这些
}
#endif 
//
```

C中的某些库在C++中被改编。并去掉.h加上c:stdlib.h->cstdlib

## 类和对象


### 类的定义和对象的创建

类的**成员变量**称为**类的属性（Property）**，将 类的**成员函数**称为**类的方法（Method）**。在面向对象的编程语言中，经常把**函数（Function）称为方法（Method**）。

class是 C++ 中新增的关键字，专门用来定义类。Student是类的名称；类名的首字母一般大写，以和其他的标识符区分开。{ }内部是类所包含的成员变量和成员函数，它们统称为类的成员（Member）；由{ }包围起来的部分有时也称为类体，和函数体的概念类似。public也是 C++ 的新增关键字，它只能用在类的定义中，表示类的成员变量或成员函数具有“公开”的访问权限。

在C++中，**struct 类似于 class，既可以包含成员变量，又可以包含成员函数。**

C++中的 struct 和 class 基本是通用的，唯有几个细节不同：
使用 class 时，类中的成员默认都是**private**属性的；而使用 struct 时，结构体中的成员默认都是 **public**属性的。

class 继承默认是 **private 继承**，而 struct 继承默认是 **public 继承**。

**class 可以使用模板，而 struct 不能**.

```cpp
class Student{
public:
    //成员变量
    char *name;
    int age;
    float score;
    //成员函数
    void say(){
        cout<<name<<"的年龄是"<<age<<"，成绩是"<<score<<endl;
    }//*在这里也可以创建对象
};
class Student LiLei;  继承于c语言
Student LiLei;  //class省略，用类名直接指向类类型
```


类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了。

实例化不同对象时，**只给数据分配空间**，各个对象**调用函数时都都跳转到(内联函数例外)找到函数在代码区的入口执行**，可以节省拷贝多份代码的空间

*对象指针*.

```cpp
Student stu;
Student *pStu = &stu;//栈上创建

Student *pStu = new Student;//堆上创建

```

**访问对象的成员变量和成员函数的方法与访问结构体成员的方法一致。**类用.类指针用->;

**栈内存是程序自动管理的**，不能使用 delete 删除在栈上创建的对象；**堆内存由程序员管理**，对象使用完毕后可以通过 delete 删除。在实际开发中，new 和 delete 往往成对出现，以保证及时删除不再使用的对象，防止无用内存堆积。

类的成员变量和普通变量一样，也有数据类型和名称，占用固定长度的内存。但是，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。

类的成员函数也和普通函数一样，都有返回值和参数列表，它与一般函数的区别是：成员函数是一个类的成员，出现在类体中，它的作用范围由类来决定；而普通函数是独立的，作用范围是全局的，或位于某个命名空间内。

当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。**::被称为域解析符（也称作用域运算符或作用域限定符）**，用来**连接类名和函数名**，指明当前函数属于哪个类。**成员函数必须先在类体中作原型声明，然后在类外定义**，也就是说类体的位置应在函数定义之前。

**在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会**。 内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义。比较短小的函数可以直接在类体内定义，免去声明。

### 类成员访问权限


c++通过 **public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，它们分别表示公有的、受保护的、私有的，被称为成员访问限定符**。所谓访问权限，就是你能不能使用该类中的成员

在**类的内部（定义类的代码内部）**，无论成员被声明为 public、protected 还是 private，**都是可以互相访问的**，**没有访问权限的限制**。

在类的外部（定义类的代码之外），只能通过对象访问成员，并且**通过对象只能访问 public 属性的成员**，不能访问 private、protected 属性的成员。

**类的声明和成员函数的定义都是类定义的一部分**，在实际开发中，我们通常将类的声明放在头文件中，而将成员函数的定义放在源文件中。

类中的成员变量 m_name、m_age 和m_ score 被设置成 private 属性，在类的外部不能通过对象访问。也就是说，**私有成员变量和成员函数只能在类内部使用，在类外都是无效的**。

**成员变量大都以m_开头**，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。

给成员变量赋值的函数通常称为**set 函数**，它们的名字通常以set开头，后跟成员变量的名字；读取成员变量的值的函数通常称为 **get 函数**，它们的名字通常以get开头，后跟成员变量的名字。**用public的函数可以改变private变量的值**。

声明为 private 的成员和声明为 public 的成员的次序任意，既可以先出现 private 部分，也可以先出现 public 部分。**如果既不写 private 也不写 public，就默认为 private**。

在一个类体中，private 和 public 可以分别出现多次。每个部分的有效范围到出现另一个访问限定符或类体结束时（最后一个右花括号）为止。但是为了使程序清晰，应该养成这样的习惯，使每一种成员访问限定符在类定义体中只出现一次。

```cpp
class func
{
public:
    void hanoi(int, char, char, char);
    void move(int, char, char);
   static int m_m;//只算是声明
   int m_n;
};
int func::m_m=1;//静态变量还要在类外定义；
```

### 全局函数

当初学者刚开始学习编写具有多个函数的程序时，可能会想要将所有变量全局化，这样它们就可以被程序中的任何函数访问，而不作为实参传递。虽然这种方法可能使程序创建更容易，但通常会在后期导致很多问题，比如：
全局变量使调试变得困难。**程序中的任何语句都可以更改全局变量的值**。如果发现在全局变量中存储了错误的值，则必须跟踪访问它的每个语句，以确定错误值来自哪里。在具有成千上万行代码的程序中，这是非常困难的。
使用全局变量的函数通常要依赖这些变量。如果想在不同的程序中使用这样一个函数，则很可能必须重新设计它，使它不再依赖于全局变量。
全局变量使程序难以理解。由于全局变量可以通过程序中的任何语句进行修改，因此，要了解任何使用了全局变量的那一部分程序，则必须了解访问该全局变量的所有程序其他部分。

因此，最好不要使用全局变量来存储、操作和检索数据。相反，在大多数情况下，应该使用局部变量，并将其作为实参传递给需要访问它们的函数

**类和全局函数可以直接互相访问，前提是对方已声明**；

### 类型成员(typedef和using)

  比如string::size_type就是string类中的某一个类型成员，是类自定义的某种类型在类中的别名。

```cpp
class Screen {
public:
    typedef std::string::size_type pos;    //使用typedef 进行定义
    using   pos = std::string::size_type;  //使用using
 
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```
### 类的作用域

类类型（类或结构体）用作用域运算符访问，其它用成员访问运算符。

在类的外部 ， 成员的名字被隐藏起来了 。一旦遇到了类名 ，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体 。结果就是， 我们可以直接使用类的其他成员而无须再次授权了 。

**返回值是类成员时也要额外用：：指定其作用域**.

### C++程序编译原理和man和exec

C++中的函数在编译时会根据它所在的命名空间、它所属的类、以及它的参数列表（也叫参数签名）等信息进行重新命名，形成一个新的函数名。这个新的函数名只有编译器知道，对用户是不可见的。对函数重命名的过程叫做名字编码（Name Mangling），是通过一种特殊的算法来实现的。

Name Mangling 的算法是可逆的，既可以通过现有函数名计算出新函数名，也可以通过新函数名逆向推演出原有函数名。Name Mangling 可以确保新函数名的唯一性，只要函数所在的命名空间、所属的类、包含的参数列表等有一个不同，最后产生的新函数名也不同。

可以只声明而不定义函数，这样调用函数时就会产生链接错误，从报错信息中就可以看到新函数名。

![a](https://img-blog.csdnimg.cn/20190329211614387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxODI2MzY0NDEw,size_16,color_FFFFFF,t_70)

小括号中就是经 Name Mangling 产生的新函数名，它们都以?开始，以区别C语言中的_。

__cdecl，__thiscall是函数调用约定，也就是告诉编译器用于建栈，参数压栈以及获得返回值的规则。

成员变量：C++会将class中的成员变量提取出来放在栈区的一个同名的struct里面，与struct有相同的内存布局和字节对齐方式。

成员函数：将成员函数提取出来放在代码区，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，通过指针来访问成员变量。

静态成员函数：将静态成员函数放在全局静态区。

*成员函数最终被编译成与对象无关的全局函数*。C++规定，编译成员函数时要额外添加一个参数，把当前对象的指针传递进去，**通过指针来访问成员变量**。

```cpp
void Demo::display() {//编译前
    cout << a << endl;
    cout << b << endl;
}

void new_function_name(Demo * const p) {//编译后类似于这样
    //通过指针p来访问a、b
    cout << p->a << endl;
    cout << p->b << endl;
}
```

这样通过传递对象指针就完成了成员函数和成员变量的关联。这与我们从表明上看到的刚好相反，通过对象调用成员函数时，**不是通过对象找函数，而是通过函数找对象**。

编译器通过指针来访问成员变量，指针指向哪个对象就使用哪个对象的数据；编译器通过指针的类型来访问成员函数，指针属于哪个类的类型就使用哪个类的函数。

C++：man std::XX;

C:man 3 XX;

反汇编命令disas/disass/disassemble起始地址（函数名）[,结束地址]

-exec disas/main(m)

disass 0x4726e0，显示

```cpp
x  /<n/f/u> <addr>
```

n、f、u 都是可选的参数，其中，n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容；f 表示显示的格式；u 表示将多少个字节作为一个值取出来，如果不指定的话，GDB默认是4个bytes

参数 f 的可选值：
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。
 
参数 u 的可选值：
b 表示单字节
h 表示双字节
w 表示四字节
g 表示八字节

### 内存四区

1，代码区

存放 CPU 执行的机器指令。通常代码区是可共享的（即另外的执行程序可以调用它），使其可共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。

2，全局区

全局区中主要存放的数据有：**全局变量、静态变量、常量（如字符串常量）**

全局区的叫法有很多：全局区、静态区、数据区、全局静态区、静态全局区

这部分可以细分为data区和bss区
data区里主要存放的是已经初始化的全局变量、静态变量和常量。
bss区主要存放的是未初始化的全局变量、静态变量，这些未初始化的数据在程序执行前会自动被系统初始化为0或者NULL
常量区是全局区中划分的一个小区域，里面存放的是常量，如const修饰的全局变量、字符串常量等。

总结：全局区存放的是全局变量、静态变量和常量
3，栈区（stack）
栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，**局部变量的生存周期为申请到释放该段栈空间。**

4，堆区（heap）

堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。**一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。**
总结

申请大小的限制：**栈是1或者2M，可以自己改，但是最大不超过8M**；堆，看主机是多少位的，**如果是32位，就是4G。**

申请效率：**栈由系统自动分配，速度较快**，程序员无法控制；堆是由new分配的内存，一般速度较慢，而且容易导致内存碎片，但是用起来方便！

)存储内容：栈，函数调用（返回值，各个参数，局部变量（**静态变量不入栈）**）；堆，一般在堆的头部用一个字节存放堆的大小，堆中的具体内容由程序员安排。

存取效率的比较：栈比堆快，Eg :char c[] = /"1234567890/";char *p =/"1234567890/";读取c[1]和p[1],c[1]读取时直接吧字符串中的元素读到寄存器cl中，而p[1]先把指针值读到edx中，再根据edx读取字符，多一次操作。

管理方式不同：栈，数据结构中的栈；**堆，链表**。

生长方向：**栈，高到低；堆，低到高**

**函数执行前只有代码区和全局区。栈区函数结束后释放，堆区用delete或free等释放，全局区（静态区）和代码区程序结束后释放。**

栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，例如，分配专门的寄存器存放栈的地址，压栈出栈都有专门的执行指令，这就决定了栈的效率比较高。一般而言，只要栈的剩余空间大于所申请空间，系统就将为程序提供内存，否则将报异常提示栈溢出。

而堆则不同，它是由 C/C++ 函数库提供的，它的机制也相当复杂。例如，为了分配一块堆内存，首先应该知道**操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。而对于大多数系统，**会在这块内存空间的首地址处记录本次分配的大小（结构体）**，这样，代码中的 delete 语句才能正确释放本内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中。很显然，堆的分配效率比栈要低得多。

对栈而言，一般用于存放函数的参数与局部变量等。例如，在函数调用时，**第一个进栈的是（主函数中的）调用处的下一条指令（即函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数 C 编译器中，参数是由右往左入栈**的，最后是函数中的局部变量（注意 static 变量是不入栈的）。

```cpp
int main()
{
    int a = 1;
    int b = 2;
    printf("%d,%d",a, a=a+b );
}
```

### 构造函数及其初始化列表和对象数组

**它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是构造函数（Constructor）**。

在栈上创建对象时，实参位于对象名后面，例如**Student stu("小明", 15, 92.5f)**；在堆上创建对象时，实参位于类名后面，例如**Student *pstu=new Student("李华", 16, 96)**。

不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许；
函数体中不能有 return 语句。

构造函数的调用是强制性的，**一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的**。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，**创建对象时只有一个构造函数会被调用**。

如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的**函数体是空的，也没有形参，也不执行任何操作**。比如上面的 Student 类，默认生成的构造函数如下：
**Student(){}**

一个类必须有构造函数，**要么用户自己定义，要么编译器自动生成**。一旦用户自己定义了构造函数，不管有几个，也不管形参如何(**可以重载构造函数从而选择初始化方式,例如定义一个无参一个有参**），编译器都不再自动生成.


Student stu()或Student stu，在堆上创建对象可以写作Student *pstu = new Student()或Student *pstu = new Student，它们都会调用构造函数 Student()。**创建对象时都没有写括号，其实是调用了默认的构造函数。**

```cpp
class Student{
private:
    char *m_name;
    int m_age;
    float m_score;
public:
    Student(char *name, int age, float score);
    void show();
};
//采用初始化列表
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){
    //TODO:
m_elem(new xxx)//分配内存语句也可以
}
```

定义构造函数时并没有在函数体中对成员变量一一赋值，**其函数体为空（当然也可以有其他语句）**，而是**在函数首部与函数体之间添加了一个冒号:**，后面紧跟 **m_name(name), m_age(age), m_score(score)** 语句，这个语句的意思相当于函数体内部的m_name = name; m_age = age; m_score = score;语句，也是赋值的意思。

**同名也没有问题，但不直观，括号内的始终是传进来的参数**；

初始化列表可以用于全部成员变量，也可以只用于部分成员变量。**成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关**.

**在类内定义和在类外定义构造函数一般是等价的**，在类内定义比较简洁。

class func{
public:
char m_A, m_B, m_C;
func(char C) : m_C(C), m_B(m_C) {m_A='A';}//在类外的话前面要加类名func::
}
func *p = new func('C');
B是乱码，初始化顺序是m_A,m_B,m_C;

**const成员变量只能用构造函数的初始化列表来初始化**。

模拟变长数组

```cpp
class VLA{
private:
    const int m_len;
    int *m_arr;
public:
    VLA(int len);
};
//必须使用初始化列表来初始化 m_len
VLA::VLA(int len): m_len(len){//！不能写成m_len=len写在函数体内
    m_arr = new int[len];
}
```

对象数组

```cpp
Student Stud[3]={ //定义对象数组
    Student(1001,18,87),  //调用第1个元素的构造函数，为它提供3个实参
    Student(1002,19,76),  //调用第2个元素的构造函数，为它提供3个实参
    Student(1003,18,72)  //调用第3个元素的构造函数，为它提供3个实参
};
等价于
Student *stud=new Student[3]{Student(1001,18,87),Student(1002,19,76),Student(1003,18,72)};
delete []stud;
```

### 复制构造函数

复制构造函数是构造函数的一种，也称拷贝构造函数，它**只有一个参数，参数类型是本类的引用**。

复制构造函数的参数可以是 const 引用，也可以是非 const 引用。 **一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象**。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。

如果类的设计者不写复制构造函数，编译器就会自动生成复制构造函数。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等（**浅拷贝**）。编译器自动生成的复制构造函数称为“默认复制构造函数”。

```cpp
#include<iostream >
using namespace std;
class Complex
{
public:
    double real, imag;
    Complex(double r, double i) {
        real= r; imag = i;
    }
};
int main(){
    Complex cl(1, 2);
    Complex c2 (cl);  //用复制构造函数初始化c2
    cout<<c2.real<<","<<c2.imag;  //输出 1,2
    return 0;
}
```

第 13 行给出了初始化 c2 的参数，即 c1。只有编译器自动生成的那个默认复制构造函数的参数才能和 c1 匹配，因此，c2 就是以 c1 为参数，调用默认复制构造函数进行初始化的。初始化的结果是 c2 成为 c1 的复制品，即 c2 和 c1 每个成员变量的值都相等。

如果编写了复制构造函数，则默认复制构造函数就不存在了.

如果只做复制工作，那么使用编译器自动生成的默认复制构造函数就行了.需要其它功能时再自己编写。

**构造函数不能以本类的对象作为唯一参数，以免和复制构造函数相混淆**。例如，不能写如下构造函数：
Complex (Complex c) {...}

**默认构造函数（即无参构造函数）不一定存在，但是复制构造函数总是会存在。**

1) 当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。例如，下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。
   Complex c2(c1);
   Complex c2 = c1;
   这两条语句是等价的。
   注意，第二条语句是**初始化语句**，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，**赋值语句不会引发复制构造函数的调用。**
   Complex c1, c2; c1 = c2 ;c1=c2;
   这条语句不会引发复制构造函数的调用，因为 c1 早已生成，已经初始化过了。
2) 如果函数 F 的参数含有类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。

   ```cpp

   class A{
   public:
       A(){};//防止初始化时将复制构造函数当作构造函数而报错。
       A(A & a){
           cout<<"Copy constructor called"<<endl;
       }
   };
   void Func(A a,int b){ cout<<b<<endl;}
   int main(){
       A a;
       Func(a,1);
       return 0;
   }
   Copy constructor called
   1
   ```

   函数的形参的值等于函数调用时对应的实参，现在可以知道这不一定是正确的。**如果形参是一个对象，那么形参的值是否等于实参，取决于该对象所属的类的复制构造函数是如何实现的**。例如上面的例子，Func 函数的形参 a 的值在进入函数时是随机的，未必等于实参，因为复制构造函数没有做复制的工作。

   以对象作为函数的形参，在函数被调用时，生成的形参要用复制构造函数初始化，这会带来时间上的开销。如果用对象的引用而不是对象作为形参，就没有这个问题了。**但是以引用作为形参有一定的风险，因为这种情况下如果形参的值发生改变，实参的值也会跟着改变。**

   **如果要确保实参的值不会改变，又希望避免复制构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用。**
   以const Complex & c形式作为函数形参；不可改变c的成员的值
3) 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。

### 析构函数

析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），**而是在销毁对象时自动执行**。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。

**析构函数是对撤销对象占用的内存之前完成的一些清理工作，而不是删除对象。**

析构函数销毁类类型时执行它们自己的析构函数，内置类型（没有析构函数，包括指针）什么也不做，智能指针是类类型，会被销毁

析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。

如果没有自行定义析构函数，编译器**会自动添加析构函数的声明。注意是声明而不是定义**。只有满足ODR(One Definition Rule)原则的情况下才会自动产生空体的析构函数定义。 如果一个class，程序员没有定义也没有声明它的默认构造函数时，编译器只会添加它的声明，而不是定义。除非有成员变量也是类对象，并且这个对象所属类有明确定义的构造函数；或者当前这个类的父类有明确的构造函数；这两种情况下编译器才为之产生默认构造函数的定义，一般情况下默认的空的析构函数就满足需求了，**自定义的析构函数一般用来输出内容或执行必需的手动销毁**。

隐式销毁一个内置指针成员并不会销毁它指向的内存，所以需要手动销毁。

析构函数体自身并不直接销毁成员，**成员是在析构函数体执行完之后隐含的析构阶段被销毁的**，所以自定义只有输出的析构函数并不影响析构过程

C++ 中的 new 和 delete 分别用来分配和释放内存，它们与C语言中 malloc()、free() 最大的一个不同之处在于：**用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。构造函数和析构函数对于类来说是不可或缺的**.

在**所有函数之外创建的对象是全局对象**，它和全局变量类似，**位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数**。

在**函数内部创建的对象是局部对象**，它和局部变量类似，**位于栈区，函数执行结束时会调用这些对象的析构函数。**

**new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数**；如果没有 delete，析构函数就不会被执行。

```cpp
#include <iostream>
#include <string>
using namespace std;
class Demo{
public:
    Demo(string s);
    ~Demo();
private:
    string m_s;
};
Demo::Demo(string s): m_s(s){ }
Demo::~Demo(){ cout<<m_s<<endl; }
void func(){
    //局部对象
    Demo obj1("1");
}
//全局对象
Demo obj2("2");
int main(){
    //局部对象
    Demo obj3("3");
    //new创建的对象
    Demo *pobj4 = new Demo("4");
    func();
    cout<<"main"<<endl;
  
    return 0;
}
运行结果：
1
main
3
2
```

可以看出对象销毁的次序。

1、调用父类的构造过程；
2、调用成员变量的构造函数（调用顺序与声明顺序相同）；
3、调用类自身的构造函数
**析构函数与对应构造函数的调用顺序相反**。

类似于入栈与出栈的顺序，最后构造的对象被最先析构。

非静态成员变量并不能决定自身的存储空间位置。**决定存储位置的是对象的创建方式**。

### default和delete

(1) defaulted 函数特性仅用于类的*特殊成员函数*，且该特殊成员函数没有默认参数;

(2) 既可以在类体里定义(inline),也可以在类体外(out-of-line)定义。

“=default”说明符到函数声明的末尾，以将该函数声明为显示默认构造函数。这就使得编译器为显示默认函数生成了默认实现，它**比手动编程函数更加有效**。


(1) 必须在函数第一次声明的时候将其声明为 deleted 函数

(2) 不同于default，*delete没有限制为特殊成员函数*才能使用delete

删除特殊成员函数提供了一种更简洁的方法来防止编译器生成我们不想要的特殊成员函数。（如“禁用拷贝构造函数”示例中所示）。
删除正常成员函数或非成员函数可防止有问题的类型导致调用非预期函数（如“禁用不需要的参数转换”示例中所示）。

### this指针

this 是 C++ 中的一个**关键字**，也是一个 **const 指针**，它指向当前对象，通过**它可以访问当前对象的所有成员。**

所谓当前对象，是指正在使用的对象。例如对于stu.show();，stu 就是当前对象，this 就指向 stu。

this **只能用在类的内部**，通过 this **可以访问类的所有成员**，包括 private、protected、public 属性的。

以成员函数setname(char *name)为例，它的形参是name，和成员变量name重名，如果写作name = name;这样的语句，就是给形参name赋值，而不是给成员变量name赋值。而写作this -> name = name;后，=左边的name就是成员变量，右边的name就是形参，一目了然。**用this就不用刻意避免重名了,同样的，标识符不冲突也就不用用this指定了**

this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
**this 只能在成员函数（声明在类体内，定义在类体外时要使用范围解析运算符::）内部使用，用在其他地方没有意义，也是非法的。**
**只有当对象被创建后 this 才有意义，因此*不能在 static 成员函数*中使用。**

this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。

this 作为*隐式形参*，**本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。**

成员函数最终被编译成与对象无关的普通函数，**除了成员变量，会丢失所有信息**，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，**它是成员函数和成员变量关联的桥梁**。

### 静态成员变量和静态成员函数

在C++中，我们可以**使用静态成员变量来实现多个对象共享数据的目标**。静态成员变量是一种特殊的成员变量，它被关键字static修饰。

static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。**当某个对象修改了 m_total，也会影响到其他对象**。

static 成员变量必须在类声明的外部初始化，具体形式为：
**type class::name = value;**

type 是变量的类型，class 是类名，name 是变量名，value 是初始值。将上面的 m_total 初始化：
int Student::m_total = 0;

type类似于函数的返回值

静态成员变量在**初始化时不能再加 static**，但必须要有数据类型。**被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化**。

注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，**没有在类外初始化的 static 成员变量不能使用。**

static 成员变量既可以通过对象来访问，也**可以通过类来访问**。非静态函数一般都要this指针，需要**实体调用**。

类的静态成员函数没有 this 指针，这导致：

1、不能直接存取类的非静态成员变量，调用非静态成员函数。
2、不能被声明为 virtual。

```cpp
//通过类类访问 static 成员变量
Student::m_total = 10;
//通过对象来访问 static 成员变量
Student stu("小明", 15, 92.5f);
stu.m_total = 20;
//通过对象指针来访问 static 成员变量
Student *pstu = new Student("李华", 16, 96);
pstu -> m_total = 20;
```

static 成员变量**不占用对象的内存，而是在所有对象之外开辟内存**，**即使不创建对象也可以访问**,具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存,初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而**静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。**

在C++中，静态成员函数的**主要目的是访问静态成员**。当然**也可以声明为普通成员函数，但是它们都只对静态成员进行操作，加上 static 语义更加明确**。

和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static（与非静态函数一样）。**静态成员函数可以通过类来调用**（一般都是这样做），也可以通过对象来调用.

### const成员变量和成员函数（常成员函数）

const 成员变量的用法和普通 const 变量的用法相似，只需要在声明时加上 const 关键字。初始化 const 成员变量只有一种方法，**就是通过构造函数的初始化列表.**

const 成员函数**可以使用类中的所有成员变量，但是不能修改它们的值，** 这种措施主要还是为了保护数据而设置的。const 成员函数也称为**常成员函数**。

我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称为 get 函数。

常成员函数需要在声明和定义的时候**在函数头部的结尾加上 const 关键字，注意在*参数列表之后***

```cpp
class Student{
public:
    Student(char *name, int age, float score);
    void show();
    //声明常成员函数
    char *getname() const;
    int getage() const;
    float getscore() const;
private:
    char *m_name;
    int m_age;
    float m_score;
};
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<"的年龄是"<<m_age<<"，成绩是"<<m_score<<endl;
}
//定义常成员函数
char * Student::getname() const{//记住get函数形式
    return m_name;
}
int Student::getage() const{
    return m_age;
}
float Student::getscore() const{
    return m_score;
}
```

需要强调的是，必须在成员函数的声明和定义处同时加上 const 关键字。char \*getname() const和char \*getname()是两个不同的函数原型，如果只在一个地方加 const 会导致声明和定义处的函数原型冲突。

最后再来区分一下 const 的位置：
**函数开头的 const 用来修饰函数的返回值**，表示返回值是 const 类型，也就是不能被修改，例如const char \* getname()。

**函数头部的结尾加上 const 表示常成员函数**，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char \* getname() const。

**常成员函数可以修改被mutable修饰的变量**。

**对于不需要修改对象成员变量的成员函数（一般是getVal类型的），应该将其声明和定义为常成员函数**，因为这种情况下向某个需要读取对象的函数传递参数时一般用常引用形式(不用复制，并确保不会被修改)，在该函数中调用非常成员函数是不允许的.

### static const

```cpp
static int si; // 静态成员变量
    //static int si2 = 100; // error: 只有静态常量成员变量，才可以这样初始化
    static const int csi; // 静态常量成员变量
    static const int csi2 = 100; // 静态常量成员变量的初始化(Integral type) (1)
    static const double csd; // 静态常量成员变量(non-Integral type)
    //staticconst double csd2 = 99.9; // error: 只有静态常量整型数据成员才可以在类中初始化
```

### const

const int *p1;
int const *p2;

int * const p3;
在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。

当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点：

```cpp
const int * const p4;
int const * const p5;

修饰const后面的所有部分；

const  class  object(params);

class const object(params);

const 指针：
const class *p = new class(params);

class const *p = new class(params);

```

用指针可以修改const变量，但const全局变量存储在全局存储空间，而且是只读的，因此试图修改会出现段错误。一般的const变量只是在编译期的常量。它类似于一种承诺，但可以不遵守。

不建议修改const变量的值，即使修改也要熟悉当前使用的编译器对于该未定义行为 是如何解释的。(其实只有devc++不行，加了volatile还要多管闲事)

```cpp
const volatile int x=1;//volatile告诉编译器不要优化（C++中的常量折叠：指const变量（即常量）值放在编译器的符号表中，计算时编译器直接从表中取值，省去了访问内存的时间，从而达到了优化。）
  int *p=(int*)&x;//必须强制类型转换
  *p=10;
  std::cout <<x<<std::endl;

```

一旦将对象定义为常对象之后，不管是哪种形式，**该对象就只能访问被 const 修饰的成员函数了，因为非 const 成员函数可能会修改对象的数据（编译器也会这样假设），可以访问没被const修饰的public变量，但不能修改**。

### C++成员对象和封闭类和封闭类

一个类的成员变量如果是另一个类（**平行关系**）的对象，就称之为“成员对象”。包含成员对象的类叫封闭类（enclosed class）。


类名::构造函数名(参数表): 成员变量1(参数表), 成员变量2(参数表), ...
{
...
}

。对于成员对象，初始化列表的“参数表”中存放的是构造函数的参数（它指明了该成员对象如何初始化）。对于基本类型成员变量，“参数表”中就是一个初始值。

```cpp
#include <iostream>
using namespace std;
class CTyre  //轮胎类
{
private:
    int radius;  //半径
    int width;  //宽度
public:
    CTyre(int r, int w) : radius(r), width(w) { }
};
class CEngine  //引擎类
{
};
class CCar {  //汽车类
private:
    int price;  //价格
    CTyre tyre;
    CEngine engine;
public:
    CCar(int p, int tr, int tw);
};
CCar::CCar(int p, int tr, int tw) : price(p), tyre(tr, tw)//！关键
{
};
int main()
{
    CCar car(20000, 17, 225);
    return 0;
}
```

没有说明 engine 该如何处理。在这种情况下，编译器就认为 engine 应该用 CEngine 类的无参构造函数初始化。而 CEngine 类确实有一个编译器自动生成的默认无参构造函数，因此，整个 car 对象的初始化问题就都解决了。

封闭类对象生成时，先执行所有成员对象的构造函数，然后才执行封闭类自己的构造函数。**成员对象构造函数的执行次序和成员对象在类定义中的次序一致，与它们在构造函数初始化列表中出现的次序无关。**

对象消亡时也遵循析构函数的一般规律

```cpp
#include<iostream>
using namespace std;
class CTyre {
public:
    CTyre() { cout << "CTyre constructor" << endl; }
    ~CTyre() { cout << "CTyre destructor" << endl; }
};
class CEngine {
public:
    CEngine() { cout << "CEngine constructor" << endl; }
    ~CEngine() { cout << "CEngine destructor" << endl; }
};
class CCar {
private:
    CEngine engine;
    CTyre tyre;
public:
    CCar() { cout << "CCar constructor" << endl; }
    ~CCar() { cout << "CCar destructor" << endl; }
};
int main() {
    CCar car;
    return 0;
}
CEngine constructor
CTyre constructor
CCar constructor
CCar destructor
CTyre destructor
CEngine destructor

```

```cpp
#include <iostream>
using namespace std;
class A
{
public:
    A() { cout << "default" << endl; }
    A(A &a) { cout << "copy" << endl; }
};
class B
{
    A a;
};
int main()
{
    B b1, b2(b1);
    return 0;
}
程序的输出结果是：
default
copy
```

说明 b2.a 是用类 A 的复制构造函数初始化的，而且调用复制构造函数时的实参就是 b1.a。

**默认构造b1->无参构造b1.a->默认复制构造b2->调用A的复制构造函数**，（普通变量直接拷贝过去即可）

**嵌套类或结构体用::访问**.

### 友元函数和友元类

借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。

在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。**友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。**

友元函数可以访问当前类中的**所有成员**，包括 public、protected、private 属性的。

友元函数不同于类的成员函数，在友元函数中**不能直接访问类的成员，必须要借助对象**。

成员函数在调用时会隐式地增加 this 指针，指向调用它的对象，从而使用该对象的成员；而 show() 是非成员函数，没有 this 指针，编译器不知道使用哪个对象的成员，要想明确这一点，就**必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象**。

friend void Student::show(Address *addr);

**需要提前声明函数，再宣布它是另一个类的朋友**。

```cpp
class Address;  //前向声明Address类。
//声明Student类
class Student{
public:
Student(char *name, int age, float score);
public:
void show(Address *addr);//要提前声明类形参
private:
char *m_name;
int m_age;
float m_score;
};
//定义Address类
class Address{
private:
char *m_province;  //省份
char *m_city;  //城市
char *m_district;  //区（市区）
public:
Address(char *province, char *city, char *district);//最后定义函数
//将Student类中的成员函数show()声明为友元函数，函数要先声明
friend void Student::show(Address *addr);
};
```

顺序大概是，**提前声明A类**，在B类定义中声明将要作为A类友元函数的函数（**形参必须有A类**），正式定义A类，并声明友元函数。

因为创建对象时要为对象分配内存，在正式声明类之前，编译器无法确定应该为对象分配多大的内存。编译器只有在“见到”类的正式声明后（其实是见到成员变量），才能确定应该为对象预留多大的内存。在对一个类作了提前声明(**前向声明**)（**类名出现**）后，可以用该类的名字去定义指向该类型对象的**指针变量**（所以类和结构体可以定义**指向自身的指针**）（本例就定义了 Address 类的指针变量）或**引用变量**,都能直接访问另一个类的成员，一般用**引用，省空间**，因为指针变量和引用变量本身的**大小是固定的**，与它所指向的数据的大小无关。

前向声明得到**不完全类型**，只能在非常有限的情景下使用：可以定义指向这种类型的指针和或引用，也可以声明（但不是定义）以不完全类型作为参数或者返回类型的函数。

**友元声明的的作用是影响访问权限，而非一般意义上的声明**.

**类和非成员函数的声明不是必须在友元声明之前**.

在创建类的对象之前，必须完整地定义该类。必须定义类，而不只是声明类，这样，编译器就会给类的对象预定相应的存储空间。同样地，在使用引用或指针访问类的成员之前，必须已经定义类。

不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。**友元类中的所有成员函数都是另外一个类的友元函数**。

例如将类 B 声明为类 A 的友元类，那么类 B 中的所有成员函数都是类 A 的友元函数，可以访问类 A 的所有成员，包括 public、protected、private 属性的。**破坏了面向对象的封装特性**。

关于友元，有两点需要说明：
友元的关系**是单向的而不是双向的**。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。**只能被朋友访问，不能访问朋友**
友元的关系**不能传递**。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。

```cpp
#include <iostream>
using namespace std;
class Address;  //提前声明Address类
//声明Student类
class Student{
public:
    Student(char *name, int age, float score);
public:
    void show(Address &addr);
private:
    char *m_name;
    int m_age;
    float m_score;
};
//声明Address类
class Address{
public:
    Address(char *province, char *city, char *district);
public:
    //将Student类声明为Address类的友元类
    friend class Student;
private:
    char *m_province;  //省份
    char *m_city;  //城市
    char *m_district;  //区（市区）
};
//实现Student类
Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(Address &addr){
    cout<<m_name<<"的年龄是 "<<m_age<<"，成绩是 "<<m_score<<endl;
    cout<<"家庭住址："<<addr->m_province<<"省"<<addr->m_city<<"市"<<addr->m_district<<"区"<<endl;
}
//实现Address类
Address::Address(char *province, char *city, char *district){
    m_province = province;
    m_city = city;
    m_district = district;
}
int main(){
    Student stu("小明", 16, 95.5f);
    Address addr("陕西", "西安", "雁塔");
    stu.show(&addr);
   
    Student *pstu = new Student("李磊", 16, 80.5);
    Address *paddr = new Address("河北", "衡水", "桃城");
    pstu -> show(paddr);
    return 0;
}
```

### 结构体和对象的异同

同：

1，定义和使用非常相似，例子如下：
public struct Student
{
string Name;
int Age;
}
public class Question
{
int Number;
string Content;
}
使用：
Student s=new Student();
Question q=new Question();
2，两者都是container类型，这表示它们可以包含其他数据类型作为成员。

3，两者都拥有成员，包括：构造函数、方法、属性、字段、常量、枚举类型、事件、以及事件处理函数。

4，两者的成员都有其各自的存取范围。例如，可以将某一个成员声明为Public，而将另一个成员声明为Private。

5，两者都可以实现接口。

6，两者都可以公开一个默认属性，然而前提是这个属性至少要取得一个自变量。

7，两者都可以声明和触发事件，而且两者都可以声明委托（Delegate）。

异：

1，结构是**实值类型**（Value Types），而类则是**引用类型**（Reference Types）。

3，所有结构成员默认都是**Public**，而类的**变量和常量数**则默认位**Private**，不过**其他类成员默认都是Public**。

4，结构成员不能被声明位Protected，而类成员可以。

5，结构变量声明不能指定初始值、使用New关键字货对数组进行初始化，但是类变量声明可以。

6，结构**不能声明默认的构造函数，也就是不拥有参数的非共享构造函数**，但是类则无此限制。

7，二者都可以拥有共享构造函数，**结构的共享构造函数不能带有参数**，但是类的共享构造函数则可以带或者不带参数。

8，**结构不允许声明析构函数**（Destructor），类则无此限制。

9，结构的实例（Instance）声明，**不允许对包含的变量进行初始化设定**，类则可以在声明类的实例时，同时进行变量初始化。

10，结构是隐式继承自ValueType类，而且不能继承任何其他类型，类则可以继续自ValueType以外的任何类。

11，结构是无法被继承的，类则可以。

12，结构永远不会终止，因此CLR不会在任何结构上调用Finalize方法。类则是由内存回收进程加以终止，当内存回收进程检测到没有任何作用的类时，它就会调用类的Finalize方法。

13，结构不需要构造函数，类则需要构造函数。

14，结构只能在一种情况下使用非共享构造函数，那就是非共享构造函数会接受参数。但是类则无此限制，它可以使用带参数或不带参数的非共享构造函数。

14，每一个结构都具有无参数的隐含公共构造函数，此构造函数会将结构的所有成员初始化为其默认值。不需要重新定义这个行为。

在“实例和变量”层面上，由于结构是数值类型的，因此每一个结构变量会永远的绑定到结构实例上。然而类是引用类型的，而且对象变量可引用不同的类实例，在此方面的区别，会对使用将结构和类造成如下的影响：

15，**结构变量会隐式的使用结构的无参数构造函数来初始化成员，这就意味语句 Struct S = new Struct（）**。

16，当您将一个结构变量赋值给另一个，或者将结构实例传递到程序变量时，**所有变量成员的值会复制到新的结构中(*浅拷贝*）**。当您将一个对象变量赋值给另一个，或者将对象变量传递给程序时，则**只是复制指针**。

17，您可以将Null值赋值给结构变量，但是该实例会一直与该变量保持关联。虽然变量成员会因此赋值而重新初始化，但是您还是可以调用变量的方法并访问其数据成员。相反的，如果您将对象变量设定为Null，您就会中断它与任何类型实例的关联，而且除非您再将另一个实例赋值给它，否则无法通过变量访问任何成员。

18，您可以在不同时间将不同的类的实例赋值给同一个对象变量，而且在同一时间可有好几个对象变量引用相同的类实例，如果您对类成员值做了改变，则其他指向相同实例的对象变量也会发生改变。然而，结构成员则会封装在他们自己的实例中，变更结构成员值并不会对其他任何结构变量的成员造成影响，甚至也不会影响相同结构声明的其他实例。

19，两个结构必须以成员对成员的比较方式来执行相等比较。两个对象变量可以使用Equals方法来加以比较。**Equals会判断两个变量是否指向相同的实例**

### C++string

C++ 大大增强了对字符串的支持，除了可以使用C风格的字符串，还可以使用内置的 string 类。string 类处理起字符串来会方便很多，完全可以代替C语言中的字符数组或字符串指针。

使用 string 类需要包含头文件 `<string>`，下面的例子介绍了几种定义 string 变量（对象）的方法：

```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string s1;
    string s2 = "c plus plus";
    string s3 = s2;
    string s4 (5, 's');
    return 0;
}
```

变量 s1 只是定义但没有初始化，编译器会将默认值赋给 s1，默认值是""，也即空字符串。

变量 s2 在定义的同时被初始化为"c plus plus"。与C风格的字符串不同，**string 的结尾没有结束标志'\0'**。

变量 s3 在定义的时候直接用 s2 进行初始化，因此 s3 的内容也是"c plus plus"。

变量 s4 被初始化为由 5 个's'字符组成的字符串，也就是"sssss"。

与C风格的字符串不同，当我们需要知道字符串长度时，可以调用 string 类提供的 length() 函数。

strlen(s)->s.length();

虽然 C++ 提供了 string 类来替代C语言中的字符串，但是在实际编程中，有时候必须要使用C风格的字符串（例如打开文件时的路径），为此，string 类为我们提供了一个转换函数 c_str()，该函数能够将 string 字符串转换为C风格的字符串，并返回该字符串的 const 指针（const char*）。

**C ++的string对象实质上就是一个容器,其内部有一个c_str方法能够返回一个指向的实质存储字符串副本的数据成员。即通过string::c_str()配合printf函数可以获取的字符串副本的内存地址。**

```cpp
string path = "D:\\demo.txt";
FILE *fp = fopen(path.c_str(), "rt");

```

string 类重载了输入输出运算符，可以像对待普通变量那样对待 string 变量，也就是用>>进行输入，用<<进行输出.

输入运算符 **>>默认会忽略空格，遇到空格就认为输入结束** .

有了 string 类，我们可以使用+或+=运算符来直接拼接字符串，非常方便，再也不需要使用C语言中的 strcat()、strcpy()、malloc() 等函数来拼接字符串了，再也不用担心空间不够会溢出了。

用+来拼接字符串时，运算符的两边可以都是 string 字符串，也可以是一个 string 字符串和一个C风格的字符串，还可以是一个 string 字符串和一个字符数组，或者是一个 string 字符串和一个单独的字符。

在比较两个string对象时是可以**利用“==”的，相等的话，则表达式的返回值为1，不等为0** 。

**通过 "+="可以连接两个字符串（在一个string对象后追加）**，特别的string s="Hello"+"world"是错误的，因为两个字符串字面量都是const char*类型,不能被修改。可以写作string s="Hello";s+="world".或string s= string("Hello")+"world";采用给string追加的方式追加。

insert() 函数可以在 string 字符串中指定的位置插入另一个字符串，它的一种原型为：
string& insert (size_t pos, const string& str);

pos 表示要插入的位置，也就是下标；str 表示要插入的字符串，它可以是 string 字符串，也可以是C风格的字符串。

**push_back()和pop_back():在尾部添删元素**.

```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string s1, s2, s3;
    s1 = s2 = "1234567890";
    s3 = "aaa";
    s1.insert(5, s3);
    cout<< s1 <<endl;
    s2.insert(5, "bbb");
    cout<< s2 <<endl;
    return 0;
}
运行结果：
12345aaa67890
12345bbb67890
```

insert() 函数的第一个参数有越界的可能，如果越界，则会产生运行时异常.

erase() 函数可以删除 string 中的一个子字符串。它的一种原型为：

string& erase (size_t pos = 0, size_t len = npos);

pos 表示要删除的子字符串的起始下标，len 表示要删除子字符串的长度。如果不指明 len 的话，那么直接删除从 pos 到字符串结束处的所有字符（此时 len = str.length - pos）。

```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string s1, s2, s3;
    s1 = s2 = s3 = "1234567890";
    s2.erase(5);
    s3.erase(5, 3);
    cout<< s1 <<endl;
    cout<< s2 <<endl;
    cout<< s3 <<endl;
    return 0;
}
运行结果：
1234567890
12345
1234590
```

在 pos 参数没有越界的情况下， len 参数也可能会导致要删除的子字符串越界。但实际上这种情况不会发生，erase() 函数会从以下两个值中取出最小的一个作为待删除子字符串的长度：
len 的值；
字符串长度减去 pos 的值。

**待删除字符串最多只能删除到字符串结尾。**

substr() 函数用于从 string 字符串中提取子字符串，它的原型为：

string substr (size_t pos = 0, size_t len = npos) const;

pos 为要提取的子字符串的起始下标，len 为要提取的子字符串的长度。

```cpp
#include <iostream>
#include <string>
using namespace std;
int main(){
    string s1 = "first second third";
    string s2;
    s2 = s1.substr(6, 6);
    cout<< s1 <<endl;
    cout<< s2 <<endl;
    return 0;
}
运行结果：
first second third
second
```

系统对 substr() 参数的处理和 erase() 类似：
如果 pos 越界，会抛出异常；
如果 len 越界，会提取从 pos 到字符串结尾处的所有字符。

find() 函数

find() 函数用于在 string 字符串中查找子字符串出现的位置，它其中的两种原型为：
size_t find (const string& str, size_t pos = 0) const;
size_t find (const char* s, size_t pos = 0) const;

第一个参数为待查找的子字符串，它可以是 string 字符串，也可以是C风格的字符串。第二个参数为开始查找的位置（下标）；如果不指明，则从第0个字符开始查找。**pos越界返回npos。**

find() 函数最终返回的是子字符串第一次出现在字符串中的起始下标。本例最终是在下标6处找到了 s2 字符串。**如果没有查找到子字符串，那么会返回npos。**

rfind() 和 find() 很类似，同样是在字符串中查找子字符串，不同的是 find() 函数从第二个参数开始往后查找，而 **rfind() 函数则最多查找到第二个参数处** ，如果到了第二个参数所指定的下标还没有找到子字符串，则返回npos。

**find_first_of() 函数用于查找子字符串和字符串共同具有的字符在字符串中首次出现的位置。**

**find()必须全部相等，find_first_of()只需要一个字符相等。**

与find_first_of()相对的还有**find_last_of()**，返回被搜索串中最后一个相等字符的位置。

字符查找函数查找成功都会返回目标位置的下标，失败都会返回**npos=-1,类型是unsign long int** ，是size_t的最大值=

$$
2^{64}-1
$$

表示不存在的位置，可以与-1比较是否相等；

\<string\>中不包含判断contain的函数，可以自定义一个bool变量或函数

```cpp
bool contain = s.find("xxx")!=string::npos
```

string作为参数传递时最好用引用传递，因为复制一个字符串很慢，一般情况下传进去的字符串不需要被修改，所以一般用*const std::string& s*作为参数

string 在内部封装了与内存和容量有关的信息。具体地说，**C++ string 对象知道自己在内存中的开始位置、包含的字符序列以及字符序列长度；当内存空间不足时，string 还会自动调整，让内存空间增长到足以容纳下所有字符序列的大小。**

string的定义在isotream里，但各种操作符的重载和成员函数在\<string\>里

本编译器中\<isotream\>已经包含了\<string\>,不include它也没有问题

C++ string 的这种做法，极大地减少了C语言编程中三种最常见且最具破坏性的错误：

数组越界；
通过未被初始化或者被赋以错误值的指针来访问数组元紊；
释放了数组所占内存，但是仍然保留了“悬空”指针。
C++ 标准没有定义 string 类的内存布局，各个编译器厂商可以提供不同的实现，但必须保证 string 的行为一致。采用这种做法是为了获得足够的灵活性。

只有当字符串被修改的时候才创建各自的拷贝，这种实现方式称为**写时复制（copy-on-write）策略**。当字符串只是作为值参数（value parameter）或在其他只读情形下使用，这种方法能够节省时间和空间。

### 操作string中的字符



### 字符串字面量(String literal)

```cpp
#include <iostream>
 
char array1[] = "Foo" "bar";
// same as
char array2[] = { 'F', 'o', 'o', 'b', 'a', 'r', '\0' };
 
const char* s1 = R"foo(
Hello
  World
)foo";//R标识后可以使用源格式输入字符串
// same as
const char* s2 = "\nHello\n  World\n";
// same as
const char* s3 = "\n"
                 "Hello\n"
                 "  World\n";
const wchar_t* s4 = L"ABC" L"DEF"; // ok, same as
const wchar_t* s5 = L"ABCDEF";
const char32_t* s6 = U"GHI" "JKL"; // ok, same as
const char32_t* s7 = U"GHIJKL";
const char16_t* s9 = "MN" u"OP" "QR"; // ok, same as
const char16_t* sA = u"MNOPQR";
const char * sB = u8"lalala""hehe";//ok, same as
const char * sC ="lalalahehe"
 
 //wchar_t:宽字符，在windows平台相当于char16_t,在linux平台相当于char32_t
// const auto* sB = u"Mixed" U"Types";
        // before C++23 may or may not be supported by
        // the implementation; ill-formed since C++23//本编译器在C++23之后，也不支持
        //指定了字面值的类型就可以用auto或auto*代替变量类型,不指定类型默认是char(u8)
 
const wchar_t* sC = LR"--(STUV)--"; // ok, raw string literal
 
int main()
{
    std::cout << array1 << ' ' << array2 << '\n'
              << s1 << s2 << s3 << std::endl;
    std::wcout << s4 << ' ' << s5 << ' ' << sC
               << std::endl;
}
//char16_t和char32_t是对应unicode字符的,通常unicode字符是不会拿来直接做输入输出的，需要转换后才能做输入输出。
using namespace std::string_literals;
  std::string s="lalala"s+"lala""leilei";// s返回一个string，可以进行连接

//宽字符输出中文
  const auto *chinese=L"啦啦啦";
std::ios::sync_with_stdio(false);    // Linux gcc.
    std::locale::global(std::locale(""));//这句可选
    std::wcout.imbue(std::locale("")); 
     std::wcout <<chinese<<std::endl;
      printf("%ls\n",chinese);
    
```

#### getline and stringstream

```cpp
istream& getline (istream&  is, string& str, char delim);
/*Extracts characters from is and stores them into str until the delimitation character delim is found (or the newline character, '\n';

The extraction also stops if the *end of file* is reached in is or if some other *error* occurs during the input operation.

If the delimiter is found, it is *extracted and discarded* (i.e. it is not stored and the next input operation will begin after it).

Note that any content in str before the call is *replaced* by the newly extracted sequence.
*/
/*delim的缺省值是'\n',istream一般用cin，但当需要重复提取一个输入时，串结束时getline不会返回0使得循环结束，只能ctrl+d结束流使得读取结束(读取结束时最后的部分没有delim符也会被读取)，解决方法就是用<sstream>里的stringstream函数将string变成流,这样就可以顺利读取并返回0退出循环，stringstream ss(s);*/


```

## C++引用

### 基本

在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是引用（Reference）。

在 C/C++ 中，我们将 char、int、float 等由语言本身支持的类型称为基本类型，将数组、结构体、类（对象）等由基本类型组合而成的类型称为聚合类型

引用（Reference）是 C++ 相对于C语言的又一个扩充。引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。

引用的定义方式类似于指针，只是用&取代了*，语法格式为：

type &name = data;

type 是被引用的数据的类型，name 是引用的名称，data 是被引用的数据。引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据，这有点类似于常量（const 变量）。

**注意，引用在定义时需要添加&，在使用时不能添加&，使用时添加&表示取地址**.

如果不希望通过引用来修改原始的数据，那么可以在定义时添加 const 限制，形式为：

const type &name = value;

也可以是：
type const &name = value;

这种引用方式为**常引用**

作为函数参数

```cpp
void creatGlist(Glist&);
Glist C=creatGlist(C);//等价于Glist C；C=creatGlist;
Glist creatGlist(Glist &C){}
```

在将引用作为函数返回值时应该注意一个小问题，就是不能返回局部数据（例如局部变量、局部对象、局部数组等）的引用，因为当函数调用完成后局部数据就会被销毁，有可能在下次使用时数据就不存在了，C++ 编译器检测到该行为时也会给出警告。

### 返回引用

1、返回非引用类型：

函数的返回值用于初始化在调用函数时创建的临时对象(temporary object)，如果返回类型不是引用，在调用函数的地方会将函数返回值复制给临时对象。
在求解表达式的时候，如果需要一个地方存储其运算结果，编译器会创建一个没命名的对象，这就是临时对象。C++程序员通常用temporary这个术语来代替temporary object。
用函数返回值初始化临时对象与用实参初始化形参的方法是一样的。
当函数返回非引用类型时，其返回值既可以是局部对象，也可以是求解表达式的结果。
2、返回引用类型：

**当函数返回引用类型时，没有复制返回值，相反，返回的是对象本身**。
**千万不要返回局部对象的引用！千万不要返回指向局部对象的指针！**
当函数执行完毕时，将释放分配给局部对象的存储空间。此时对局部对象的引用就会指向不确定的内存！返回指向局部对象的指针也是一样的，当函数结束时，局部对象被释放，返回的指针就变成了不再存在的对象的悬垂指针。

```cpp

#include <iostream>
using namespace std;
int &plus10(int &r) {
    int m = r + 10;
    return m;  //返回局部数据的引用
}
int main() {
    int num1 = 10;
    int num2 = plus10(num1);
    cout << num2 << endl;
    int &num3 = plus10(num1);num3和num4是局部变量m的引用，值会被下一次引用破坏
    int &num4 = plus10(num3);
    cout << num3 << " " << num4 << endl;
    return 0;
}
```

本编译器不允许，会报段错误
### 指针与引用

**指针传递参数本质上是值传递的方式，它所传递的是一个地址值**。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，即在栈中开辟了内存空间以存放由主调函数放进来的实参的值，从而成为了实参的一个副本。值传递的特点是被调函数对形式参数的任何操作都是作为局部变量进行，不会影响主调函数的实参变量的值。

而在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈中开辟了内存空间，但是这时**存放的是由主调函数放进来的实参变量的地址**。被调函数对形参的任何操作都被处理成**间接寻址**，即通过栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量。

★相同点：

●都是地址的概念；

指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的**别名**。

★不同点：

●指针是一个实体，而引用仅是个别名；

●引用只能在定义时被初始化一次，之后不可变；指针可变；**引用“从一而终”**，指针可以 **“见异思迁”**；

●**引用不能为空，指针可以为空**；

●“sizeof 引用”得到的是所指向的**变量(对象)的大小**，而“sizeof 指针”得到的是指针本身的大小；

●指针和引用的自增(++)运算意义不一样；

●引用是类型安全的，而指针不是 (引用比指针多了类型检查

### 临时变量、引用参数和const引用

如果**实参与引用参数不匹配，C++将生成临时变量**。如果引用参数是const,则编译器在下面两种情况下生成临时变量：

**实参类型是正确的，但不是左值,实参类型不正确，但可以转换为正确的类型**.

**左值参数是可被引用的数据对象**，例如，变量、数组元素、结构成员、引用和被解除引用的指针都是左值，**非左值包括字面常量(100)和包含多项式的表达式(a+100)**;

如果声明将引用指定为const，C++将在必要时生成临时变量、实际上，对于形参为const引用的C++函数，**如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量来存储值**

函数形参应尽可能使用const

使用const可以避免无意中修改数据的编程错误

使用const使函数**能够处理const和非const实参，否则将只能接受非const数据**

使用const引用使函数能够正确生成并使用临时变量

### 右值引用和移动构造函数

左值引用&;右值引用&&；

右值引用只能绑定到将要销毁的对象，实现对右值资源的移动，不能绑定左值,使用右值引用的对象可以自由接管所引用对象的资源。

返回左值引用的函数，连同赋值 、下标 、解引用和**前置递增 ，递减运算符** ，都是返回左值的表达式的例子 。 我们可以将一个左值引用绑定到这类表达式的结果上 。
返回非引用类型的函数，连同算术 、关系 、位以及**后置递增 ，递减运算符**（表达式的值是暂时的，递增，递减后会改变）， 都生成右值 。我们不能将一个左值引用绑定到这类表达式上 ， 但我们可以将一个**const 的左值引用或者一个右值**引用绑定到这类表达式上 。

```cpp
const int &r1=i*20;//正确
int &&r2=i*20;//正确
int &r3=i*20;//错误 
std::move()：返回对象的右值引用//重名可能性大，最好带上std::
int &&r4=std::move(i)//i将不能再使用，可以销毁或赋值
```

### 移动构造函数

```cpp
class movedemo{
public:
    movedemo():num(new int(0)){
        cout<<"construct!"<<endl;
    }
    //拷贝构造函数(深拷贝)
    movedemo(const movedemo &d):num(new int(*d.num)){
        cout<<"copy construct!"<<endl;
    }
    //移动构造函数
    movedemo(movedemo &&d):num(d.num){
        d.num = nullptr;//销毁右值时会运行析构函数，需要保证销毁它是无害的
        cout<<"move construct!"<<endl;
    }
public:     //这里应该是 private，使用 public 是为了更方便说明问题
    int *num;
};
int main(){
    movedemo demo;
    cout << "demo2:\n";
    movedemo demo2 = demo;
    //cout << *demo2.num << endl;   //可以执行
    cout << "demo3:\n";
    movedemo demo3 = std::move(demo);//过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。
    //此时 demo.num = nullptr，因此下面代码会报运行时错误
    //cout << *demo.num << endl;
    return 0;
}
```

## 继承和派生

### 基本

继承（Inheritance）可以理解为一个类从另一个类获取成员变量和成员函数的过程。例如类 B 继承于类 A，那么 B 就拥有 A 的成员变量和成员函数。

在C++中，派生（Derive）和继承是一个概念，只是站的角度不同。继承是儿子接收父亲的产业，派生是父亲把产业传承给儿子。

被继承的类称为父类或基类，继承的类称为子类或派生类。“子类”和“父类”通常放在一起称呼，“基类”和“派生类”通常放在一起称呼。

派生类除了拥有基类的成员，还可以定义自己的新成员，以增强类的功能。

以下是两种典型的使用继承的场景：

1) 当你创建的新类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承，这样不但会减少代码量，而且新类会拥有基类的所有功能。

2) 当你需要创建多个类，它们拥有很多相似的成员变量或成员函数时，也可以使用继承。可以将这些类的共同成员提取出来，定义为基类，然后从基类继承，既可以节省代码，也方便后续修改成员。

class Student: public People

这就是声明派生类的语法。class 后面的“Student”是新声明的派生类，冒号后面的“People”是已经存在的基类。在“People”之前有一关键宇 public，用来表示是公有继承。

由此总结出继承的一般语法为：
class 派生类名:［继承方式］ 基类名{
    派生类新增加的成员
};

三种继承

1) 基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为 protected 时，那么基类成员在派生类中的访问权限最高也为 protected，高于 protected 的会降级为 protected，但低于 protected 不会升级。再如，当继承方式为 public 时，那么基类成员在派生类中的访问权限将保持不变。
也就是说，**继承方式中的 public、protected、private 是用来指明基类成员在派生类中的最高访问权限的。**

2) 不管继承方式如何，**基类中的 private 成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。**

3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为 public 或 protected；只有那些不希望在派生类中使用的成员才声明为 private。

4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。

注意，我们这里说的是基类的 private 成员不能在派生类中使用，并没有说基类的 private 成员不能被继承。实际上，基类的 private 成员是能够被继承的，并且（成员变量）会占用派生类对象的内存，它**只是在派生类中不可见，导致无法使用**罢了。private 成员的这种特性，能够很好的对派生类隐藏基类的实现，以体现面向对象的封装性。

由于 private 和 protected 继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以实际开发中我们一般使用 public。

在**派生类中访问基类 private 成员的唯一方法就是借助基类的非 private 成员函数**，如果基类没有非 private 成员函数，那么该成员在派生类中将无法访问。

```cpp
//基类People
class People{
public:
    void setname(char *name);
    void setage(int age);
    void sethobby(char *hobby);
    char *gethobby();
protected:
    char *m_name;
    int m_age;
private:
    char *m_hobby;
};
//派生类Student
class Student : public People {
public:
    void learning();
public:
    using People::m_name;  //将protected改为public
    using People::m_age;  //将protected改为public
    float m_score;
private:
    using People::show;  //将public改为private
};
```

**using 只能改变基类中 public 和 protected 成员的访问权限，不能改变 private 成员的访问权限**.

**protected成员只在该类及其派生类中可见**。

在继承情况下，**派生类的作用域嵌套在基类作用域中**：如果不能在派生类作用域中确定名字，就在外围基类作用域中查找该名字的定义。

如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，那么就会**遮蔽从基类继承过来的成员**。所谓遮蔽，就是在派生类中使用该成员（包括在定义派生类时使用，也包括通过派生类对象访问该成员）时，实际上使用的是派生类新增的成员，而不是从基类继承来的。

基类成员函数和派生类成员函数**不会构成重载**，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数，**不管它们的参数是否一样**。

```cpp
  //使用的是派生类新增的成员函数，而不是从基类继承的
    stu.show();
    //使用的是从基类继承来的成员函数
    stu.People::show();
```

如果派生类想**通过自身类型使用基类所有的重载函数**,则派生类必须要么重定义所有重载函数（全是新的）,要么一个也不重定义（全是旧的）。

有时类需要仅仅重定义一个重载版本，并且想要继承其他版本的含义,在这种情况下，派生类不用重定义所继承的每一个基类版本,它可以为重载成员提供using声明。一个using声明只能指定一个名字,不能指定形参表,因此：**using声明会将该函数的所有重载实例加到派生类的作用域**。将所有名字加入作用域之后,派生类只需要重定义本类型确实必须定义的那些函数,对其他版本可以使用继承的定义。

```cpp
struct Base
{
    int memfuc();
    int memfuc(int);
    int memfuc(double);
};
 
struct Derived : Base
{
    using Base::memfuc;
    int memfuc();   //重定义,其余为基类的定义
};
```

### 基类和派生类构造和析构函数

构造函数和析构函数都不能被继承

```cpp
Student::Student(char *name, int age, float score): People(name, age), m_score(score){ }
```

不管它们的顺序如何，派生类构造函数总是**先调用基类构造函数再执行其他代码**（包括参数初始化表以及函数体中的代码)

因为基类构造函数不会被继承，不能当做普通的成员函数来调用。换句话说，只能将**基类构造函数的调用放在函数头部**，不能放在函数体中,**构造函数访问基类变量则只能放在函数体中，不能放在头部**。

构造函数的调用顺序是按照继承的层次自顶向下、从基类再到派生类的。

派生类构造函数中只能调用直接基类的构造函数，不能调用间接基类的。，因为我们在 C 中调用了 B 的构造函数，B 又调用了 A 的构造函数，相当于 C 间接地（或者说隐式地）调用了 A 的构造函数，如果再在 C 中显式地调用 A 的构造函数，那么 A 的构造函数就被调用了两次，相应地，初始化工作也做了两次，这不仅是多余的，还会浪费CPU时间以及内存，毫无益处，所以 C++ 禁止在 C 中显式地调用 A 的构造函数。 

通过派生类创建对象时**必须要调用基类的构造函数**，这是语法规定。换句话说，定义派生类构造函数时最好指明基类构造函数；如果不指明，就调用基类的默认构造函数（不带参数的构造函数）；如果没有默认构造函数，那么编译失败。

在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择

创建派生类对象时，构造函数的执行顺序和继承顺序相同，即先执行基类构造函数，再执行派生类构造函数。
而销毁派生类对象时，析构函数的执行顺序和继承顺序相反，即先执行派生类析构函数，再执行基类析构函数。

### 多继承

多继承（Multiple Inheritance），即一个派生类可以有两个或多个基类。

```cpp
class D: public A, private B, protected C{
    //类D新增加的成员
}
```

![lala](https://pic4.zhimg.com/80/v2-57f57ec3edbebf7e55374bb4954cd477_1440w.jpg)

多继承下的构造函数
多继承形式下的构造函数和单继承形式基本相同，只是要在派生类的构造函数中调用多个基类的构造函数。

```cpp
D(形参列表): A(实参列表), B(实参列表), C(实参列表){
    //其他操作
}
```

**调用顺序和声明派生类时基类出现的顺序相同，同样的，调用析构函数的顺序是相反的**。

### 借助指针访问非public变量

正常情况下，我们没有办法通过对象访问，protected 和 private 类变量，但是借助指针，我们依然可以实现访问所有变量，只要我们拿到 对象的收地址，再根据数据类型推导指针地址变化长度，就可以实现突破限制访问protected 和 private 类变量。

```cpp

 std::cout << *(int *)&entity << std::endl;//private在类最开始处定义
    std::cout << *(int *)((char*)&entity+sizeof(int)) << std::endl;
    std::cout << *(int *)((int*)&entity+1) << std::endl;//和上一个等价，char是一个byte，int是四个

```

### 虚继承

菱形继承中，类 A 派生出类 B 和类 C，类 D 继承自类 B 和类 C，这个时候类 A 中的成员变量和成员函数继承到类 D 中变成了两份，一份来自 A-->B-->D 这条路径，另一份来自 A-->C-->D 这条路径。

通过D使用A中的变量为了消除歧义需要指明变量是来自B还是C的

为了解决多继承时的命名冲突和冗余数据问题，C++ 提出了虚继承，使得在派生类中只保留一份间接基类的成员。

**在继承方式前面加上 virtual 关键字就是虚继承**.

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类（Virtual Base Class），本例中的 A 就是一个虚基类。在这种机制下，**不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员**。

必须在虚派生的真实需求出现前就已经完成虚派生的操作。在上图中，当定义 D 类时才出现了对虚派生的需求，但是如果 B 类和 C 类不是从 A 类虚派生得到的，那么 D 类还是会保留 A 类的两份成员。

换个角度讲，虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。

假设 A 定义了一个名为 x 的成员变量，当我们在 D 中直接访问 x 时，会有三种可能性：
如果 B 和 C 中都没有 x 的定义，那么 x 将被解析为 A 的成员，此时不存在二义性。
如果 B 或 C 其中的一个类定义了 x，也不会有二义性，派生类的 x 比虚基类的 x 优先级更高。
如果 B 和 C 中都定义了 x，那么直接访问 x 将产生二义性问题。

使用多继承经常会出现二义性问题，必须十分小心,只有在比较简单和不易出现二义性的情况或实在必要时才使用多继承，能用单一继承解决的问题就不要使用多继承。也正是由于这个原因，C++ 之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。

### 虚继承的构造函数

虚基类 A 在最终派生类 D 中只保留了一份成员变量 m_a，如果由 B 和 C 初始化 m_a，那么 B 和 C 在调用 A 的构造函数时很有可能给出不同的实参，这个时候编译器就会犯迷糊，不知道使用哪个实参初始化 m_a。

为了避免出现这种矛盾的情况，C++ 干脆规定**必须由最终的派生类 D 来初始化虚基类 A**，直接派生类 B 和 C 对 A 的构造函数的调用**是无效的**。在以往的普通继承中，派生类的构造函数只负责初始化它的直接基类，再由直接基类的构造函数初始化间接基类，用户尝试调用间接基类的构造函数将导致错误。

在最终派生类的构造函数调用列表中，不管各个构造函数出现的顺序如何，编译器总是先调用虚基类的构造函数，再按照出现的顺序调用其他的构造函数；而对于普通继承，就是按照构造函数出现的顺序依次调用的。

### 向上转型

类其实也是一种数据类型，也可以发生数据类型转换，不过这种转换只有在基类和派生类之间才有意义，并且只能将派生类赋值给基类，**包括将派生类对象赋值给基类对象、将派生类指针赋值给基类指针、将派生类引用赋值给基类引用**，这在 C++ 中称为向上转型（Upcasting）。相应地，将基类赋值给派生类称为向下转型（Downcasting）。

向上转型非常安全，可以由编译器自动完成；向下转型有风险，需要程序员手动干预。

对象赋值

赋值的本质是将现有的数据写入已分配好的内存中，对象的内存只包含了成员变量，所以**对象之间的赋值是成员变量的赋值，成员函数不存在赋值问题**。运行结果也有力地证明了这一点，虽然有a=b;这样的赋值过程，但是 a.display() 始终调用的都是 A 类的 display() 函数。换句话说，对象之间的赋值不会影响成员函数，也不会影响 this 指针。

指针赋值

pa 本来是基类 A 的指针，现在指向了派生类 D 的对象，这使得隐式指针 this 发生了变化，也指向了 D 类的对象，所以最终在 display()(A类的) 内部使用的是 D 类对象的成员变量，**通过基类指针只能使用派生类的成员变量，但不能使用派生类的成员函数**

编译器**通过指针来访问成员变量**，指针指向哪个对象就使用哪个对象的数据；编译器**通过指针的类型来访问成员函数**，指针属于哪个类的类型就使用哪个类的函数（注意函数里的参数也是指针所属类的，指向派生类后会使用其继承的变量，不会使用派生类的同名变量）

在进行指针赋值的时候。将子类指针赋值个父类指针，编译器会做如下处理：让指针指向子类中父类对象的起始位置。

![a](https://imgconvert.csdnimg.cn/aHR0cDovL2MuYmlhbmNoZW5nLm5ldC91cGxvYWRzL2FsbGltZy8xOTAyMTQvMUc1NDkxQTAtMC5qcGc?x-oss-process=image/format,png)

上面是D的内存模型，B类对象和C类对象在内存中的先后顺序是依据继承时的顺序决定的。这就是为什么pa pb和pd的地址相同，pc和pd不同的原因
 
引用赋值

基类的引用也可以指向派生类的对象，并且它的表现和指针是类似的。

## 多态和虚函数

### 基本

让基类指针能够访问派生类的成员函数，C++ 增加了虚函数（Virtual Function）

在同名函数前加 virtual 即可。

有了虚函数，基类指针指向基类对象时就使用基类的成员（包括成员函数和成员变量），指向派生类对象时就使用派生类的成员。换句话说，基类指针可以按照基类的方式来做事，也可以按照派生类的方式来做事，它有多种形态，或者说有多种表现方式，我们将这种现象称为多态（Polymorphism）。

C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量

虚函数是根据指针的指向来调用的，**指针指向哪个类的对象就调用哪个类的虚函数**。

引用与指针类似，也可以实现多态。

派生类比较多时，如果不使用多态，那么就需要定义多个指针变量，很容易造成混乱；而有了多态，只需要一个指针变量 p 就可以调用所有派生类的虚函数。

1) 只需要在虚函数的声明处加上 virtual 关键字，函数定义处可以加也可以不加。

2) *可以只将基类中的函数声明为虚函数*，这样所有派生类中具有遮蔽关系的同名函数都将自动成为虚函数。

3) 当在基类中定义了虚函数时，如果派生类没有定义新的函数来遮蔽此函数，那么将使用基类的虚函数。

4) 只有派生类的虚函数覆盖基类的虚函数（函数原型相同）才能构成多态（通过基类指针访问派生类函数）。例如基类虚函数的原型为virtual void func();，派生类虚函数的原型为virtual void func(int);，那么当基类指针 p 指向派生类对象时，语句p -> func(100);将会出错，而语句p -> func();将调用基类的函数。

5) 构造函数不能是虚函数。对于基类的构造函数，它仅仅是在派生类构造函数中被调用，这种机制不同于继承。也就是说，派生类不继承基类的构造函数，将构造函数声明为虚函数没有什么意义，并且对象未创建完成时还无法查询虚函数表。也就不知道调用哪一个构造函数。

6) 析构函数可以声明为虚函数，而且有时候必须要声明为虚函数。

构成多态的条件：

- 必须存在继承关系；
- 继承关系中*必须有同名的虚函数，并且它们是覆盖关系（函数原型相同）*。
- 存在基类的指针，通过该指针调用虚函数。

**首先看成员函数所在的类是否会作为基类。然后看成员函数在类的继承后有无可能被更改功能，如果希望更改其功能的，一般应该将它声明为虚函数。如果成员函数在类被继承后功能不需修改，或派生类用不到该函数，则不要把它声明为虚函数。**

### 虚析构函数的必要性

对于指向派生类的基类指针，在没有虚函数的情况下只能调用基类的析构函数，这会产生未定义的行为（例如导致delete调用基类析构函数在释放内存时，没有将派生类对象产生的堆内存释放掉），导致内存泄露

只要基类的析构函数是虚函数，那么派生类的析构函数不论是否用virtual关键字声明，都自动成为虚析构函数。

虚析构函数原理

由于基类的析构函数为虚函数，所以派生类会在所有属性的前面形成虚表，而虚表内部存储的就是基类的虚函数。
当delete基类的指针时，由于派生类的析构函数与基类的析构函数构成多态，所以得**先调动派生类的析构函数**；之所以再调动基类的析构函数，是因为delete的机制所引起的,delete 基类指针所指的空间，要调用基类的析构函数。

一般情况下一个类需要定义析构函数，那么它也需要自定义拷贝构造函数和重载赋值运算符，因为需要析构函数说明类成员有不能简单复制的指针变量。而虚析构函数只需要自定义一个空的虚构函数即可，目的不同。

```cpp
virtual ~className(){}
virtual ~className()=default//推荐,但作用一样
```

### 纯虚函数和抽象类

```cpp
virtual 返回值类型 函数名 (函数参数) = 0;
```

纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上=0，表明此函数为纯虚函数。

包含纯虚函数的类称为抽象类（*Abstract Class*）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。

抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。

在实际开发中，你可以定义一个抽象基类，只完成部分功能，未完成的功能交给派生类去实现（谁派生谁实现）。这部分未完成的功能，往往是基类不需要的，或者在基类中无法实现的。虽然抽象基类没有完成，但是却强制要求派生类完成，这就是抽象基类的“霸王条款”。

抽象基类除了约束派生类的功能，还可以实现多态。**抽象基类的指针指向派生类后向可以访问派生类中虚函数的实现**。

抽象类又被称为**接口**，C++中没有interface，只能用抽象类实现

1) **一个纯虚函数就可以使类成为抽象基类**，但是抽象基类中除了包含纯虚函数外，还可以包含其它的成员函数（虚函数或普通函数）和成员变量。

2) **只有类中的虚函数才能被声明为纯虚函数**，普通成员函数和顶层函数均不能声明为纯虚函数.

普通虚函数同时继承接口和缺省实现是危险的，最好是基类中实现缺省行为 (behavior)，但只有在派生类要求时才提供该缺省行为,派生类忘记重写继承的函数时就会调用基类的default实现。

解决：

1) 纯虚函数 + 缺省实现，因为是纯虚函数，所以只有接口被继承，其缺省的实现不会被继承。派生类要想使用该缺省的实现，必须显式的调用（这种方式也应该加上override）

2) 使用关键字 overrid

描述：override保留字表示当前函数重写了基类的虚函数。

目的：1.在函数比较多的情况下可以提示读者某个函数重写了基类虚函数（表示这个虚函数是从基类继承，不是派生类自己定义的）；2.强制编译器检查某个函数是否重写基类虚函数，如果没有则报错。

补充：在派生类中，重写 (override) 继承自基类成员函数的实现 (implementation) 时，要满足如下条件：

  一虚：基类中，成员函数声明为虚拟的 (virtual)

  二容：基类和派生类中，成员函数的返回类型和异常规格 (exception specification) 必须兼容

  四同：基类和派生类中，成员函数名、形参类型、常量属性 (constness) 和 引用限定符 (reference qualifier) 必须完全相同

  如此多的限制条件，导致了虚函数重写如上述代码，极容易因为一个不小心而出错

  C++11 中的 override 关键字，可以显式的在派生类中声明，哪些成员函数需要被重写，如果没被重写，则编译器会报错。 

```cpp
class testoverride
{
public:
    testoverride(void);
    ~testoverride(void);
    virtual void show() const = 0;
    virtual int infor() = 0;
    virtual void test() = 0;
    virtual int spell() = 0;
};

class B: public testoverride
{
public:
    virtual void show();     //1
    virtual void infor();    //2
    virtual void vmendd();   //3
virtual void test(int x);//4
virtual void splle();    //5 
};
//上面的1-5个重载函数编译过程中，除了返回值不同的infor会报错以外，其他函数都不会有问题，但是在类实例化的时候会提示是抽象类，因为他们都没有真正实现重载
```

注意：override只是C++保留字，不是关键字，这意味着只有在正确的使用位置，oerride才启“关键字”的作用，其他地方可以作为标志.

### 虚函数表

有了虚函数以后，对象所占用的存储空间比没有虚函数时多了 4 个字节。实际上，任何有虚函数的类及其派生类的对象都包含这多出来的 4 个字节，这 4 个字节就是实现多态的关键——它位于对象存储空间的最前端，其中存放的是虚函数表的地址。

每一个有虚函数的类（或有虚函数的类的派生类）都有一个虚函数表(vtable)，该类的任何对象中都放着该虚函数表的指针（可以认为这是由编译器自动添加到构造函数中的指令完成的）。

假设 pa 的类型是 A*，则 pa->func() 这条语句的执行过程如下：

1) 取出 pa 指针所指位置的前 4 个字节，即对象所属的类的虚函数表的地址（在 64 位编译模式下，由于指针占 8 个字节，所以要取出 8 个字节）。如果 pa 指向的是类 A 的对象，则这个地址就是类 A 的虚函数表的地址；如果 pa 指向的是类 B 的对象，则这个地址就是类 B 的虚函数表的地址。

2) 根据虚函数表的地址找到虚函数表，在其中查找要调用的虚函数的地址。不妨认为虚函数表是以函数名作为索引来查找的，虽然还有更高效的查找方法。
如果 pa 指向的是类 A 的对象，自然就会在类 A 的虚函数表中查出 A::func 的地址；如果 pa 指向的是类 B 的对象，就会在类 B 的虚函数表中查出 B::func 的地址。
类 B 没有自己的 func2 函数，因此在类 B 的虚函数表中保存的是 A::func2 的地址，这样，即便 pa 指向类 B 的对象，pa->func2();这条语句在执行过程中也能在类 B 的虚函数表中找到 A::func2 的地址。

3) 根据找到的虚函数的地址调用虚函数。

由以上过程可以看出，只要是通过基类指针或基类引用调用虚函数的语句，就一定是多态的，也一定会执行上面的查表过程，哪怕这个虚函数仅在基类中有，在派生类中没有。

多态机制能够提高程序的开发效率，但是也增加了程序运行时的开销。虚函数表、各个对象中包含的 4 个字节的虚函数表的地址都是空间上的额外开销；而查虚函数表的过程则是时间上的额外开销。

### typeid运算符：获取类型信息

因为type_info类的复制构造函数和赋值运算符都是私有的，所以不允许用户自已创建type_info的类。唯一要使用type_info类的方法就是使用typeid函数。

typeid 运算符用来获取一个表达式的类型信息。类型信息对于编程语言非常重要，它描述了数据的各种属性：
对于基本类型（int、float 等C++内置类型）的数据，类型信息所包含的内容比较简单，主要是指数据的类型。
对于类类型的数据（也就是对象），类型信息是指对象所属的类、所包含的成员、所在的继承关系等。

类型信息是创建数据的模板，数据占用多大内存、能进行什么样的操作、该如何操作等，这些都由它的类型信息决定。

typeid 会把获取到的类型信息保存到一个 type_info 类型的对象里面，并返回该对象的常引用；当需要具体的类型信息时，可以通过成员函数来提取

```cpp
/*std::type_info is not copyable, so you cannot store it by value. You can use a reference if it suits your needs:
const std::type_info &a(typeid(int));*/
//本编译器不支持赋值运算符，只能用复制构造函数,并且不支持raw_name()
    #include <typeinfo>
    const type_info &nInfo = typeid(n);
    cout<<nInfo.name()<<" | "<<nInfo.raw_name()<<" | "<<nInfo.hash_code()<<endl;
    //获取一个字面量的类型信息
    const type_info &dInfo = typeid(25.65);
    cout<<dInfo.name()<<" | "<<dInfo.raw_name()<<" | "<<dInfo.hash_code()<<endl;
    //获取一个对象的类型信息
    Base obj;
    const type_info &objInfo = typeid(obj);
    cout<<objInfo.name()<<" | "<<objInfo.raw_name()<<" | "<<objInfo.hash_code()<<endl;
    //获取一个类的类型信息
    const type_info &baseInfo = typeid(Base);
    cout<<baseInfo.name()<<" | "<<baseInfo.raw_name()<<" | "<<baseInfo.hash_code()<<endl;
    //获取一个结构体的类型信息
    const type_info &stuInfo = typeid(struct STU);
    cout<<stuInfo.name()<<" | "<<stuInfo.raw_name()<<" | "<<stuInfo.hash_code()<<endl;
    //获取一个普通类型的类型信息
    const type_info &charInfo = typeid(char);
    cout<<charInfo.name()<<" | "<<charInfo.raw_name()<<" | "<<charInfo.hash_code()<<endl;
    //获取一个表达式的类型信息
    const type_info &expInfo = typeid(20 * 45 / 4.5);
    cout<<expInfo.name()<<" | "<<expInfo.raw_name()<<" | "<<expInfo.hash_code()<<endl;
```

name() 用来返回类型的名称。

Gcc的name()返回的是简写,要全称则用如下方式

```cpp
#include <cxxabi.h>

int status;
  char *realname;
  const std::type_info &ti = typeid(p);

  realname = abi::__cxa_demangle(ti.name(), 0, 0, &status);
  std::cout << ti.name() << "\t=> " << realname << "\t: " << status << '\n';
  free(realname);
```

raw_name() 用来返回名字编码（Name Mangling）算法产生的新名称

函数倾轧（name mangling）： 同名不同参函数（重载函数），C++底层如何区分他们，那就是对函数改名，也就是中文翻译的“倾轧”

可用反汇编命令查看名字编码

 objdump -t class(可执行文件名)

 用c++filt查看原函数

 c++filt _ZN6Derive4funcEv

 输出：Derive::func()

hash_code() 用来返回当前类型对应的 hash 值。hash 值是一个可以用来标志当前类型的整数，有点类似学生的学号、公民的身份证号、银行卡号等。不过 hash 值有赖于编译器的实现，在不同的编译器下可能会有不同的整数，但它们都能唯一地标识某个类型。

C++ 标准只对 type_info 类做了很有限的规定，不仅成员函数少，功能弱，而且各个平台的实现不一致

为了减小编译后文件的体积，编译器不会为所有的类型创建 type_info 对象，只会为使用了 typeid 运算符的类型创建。不过有一种特殊情况，就是带虚函数的类（包括继承来的），不管有没有使用 typeid 运算符，编译器都会为带虚函数的类创建 type_info 对象

表达式typeid(\*p1) == typeid(Base)和typeid(p1) == typeid(Base\*)的结果为 true 可以说明：即使将派生类指针 p2 赋值给基类指针 p1，p1 的类型仍然为 Base\*。

### RTTI

RTTI(Run Time Type Identification)即通过运行时类型识别，程序能够使用基类的指针或引用来检查着这些指针或引用所指的对象的实际派生类型。

有时我们需要将一个多态指针转换为其实际指向对象的类型，就需要知道运行时的类型信息，这就产生了运行时类型识别的要求。和Java相比，C++要想获得运行时类型信息，只能通过RTTI机制，并且C++最终生成的代码是直接与机器相关的。

RTTI提供了两个非常有用的操作符：typeid和dynamic_cast。

typeid操作符，返回指针和引用所指的实际类型；

当typeid中的操作数是如下情况之一时，typeid运算符指出操作数的静态类型，即编译时的类型。

（1）类型名

（2）一个基本类型的变量

（3）一个具体的对象

（4）一个指向不含有virtual函数的类对象的指针的解引用

（5）一个指向不含有virtual函数的类对象的引用

当typeid中的操作数是如下情况之一时，typeid运算符需要在程序运行时计算类型，因为其操作数的类型在编译时期是不能被确定的。

（1）一个指向含有virtual函数的类对象的指针的解引用

（2）一个指向含有virtual函数的类对象的引用

dynamic_cast操作符，将基类类型的指针或引用安全地转换为其派生类类型的指针或引用。

对于多态性的对象，无法在程序编译阶段确定对象的类型。当类中含有虚函数时，其基类的指针就可以指向任何派生类的对象，这时就有可能不知道基类指针到底指向的是哪个对象的情况，类型的确定要在运行时利用运行时类型标识做出。为了获得一个对象的类型可以使用typeid函数，该函数反回一个对type_info类对象的引用

在多重继承和虚拟继承的情况下，一个类有n（n>1）个虚函数表，该类的对象也有n个vptr，分别指向这些虚函数表，但是一个类的所有的虚函数表的索引为-1的项的值（type_info对象的地址）都是相等的，即它们都指向同一个type_info对象，这样就实现了无论使用了哪一个基类的指针或引用指向其派生类的对象，都能通过相应的虚函数表获取到相同的type_info对象，从而得到相同的类型信息。

![a](https://img-blog.csdnimg.cn/20190811155549949.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2ODk2MjEz,size_16,color_FFFFFF,t_70)

RTTI的应用

如果有一个类层次，希望为它实现“==”操作符。

```cpp
class Base
{
    friend bool operator==(const Base&, const Base&);
public:
    // interface members for Base
protected:
    virtual bool equal(const Base&) const;
    // data and other implementation members of Base
};

bool Base::equal(const Base &rhs) const
{
    // do whatever is required to compare to Base objects
}

class Derived: public Base
{
    friend bool operator==(const Base&, const Base&);
public:
    // other interface members for Derived
private:
    bool equal(const Base&) const;
    // data and other implementation members of Derived
};

bool Derived::equal(const Base &rhs) const//Derived::equal()中的dynamic_cast强制转换是必要的。因为要比较派生类的成员，必须将操作数Base &转换为Derived类型。
{
    if (const Derived *dp = dynamic_cast<const Derived *>(&rhs))
    {
        // do work to compare two Derived objects and return result
    }
    else
        return false;
}

bool operator==(const Base &lhs, const Base &rhs)
{
    // returns false if typeids are different otherwise
    // returns lhs.equal(rhs)
    return typeid(lhs) == typeid(rhs) && lhs.equal(rhs);//如果操作数类型不同，操作符就返回假；如果操作数类型相同，就将实际比较操作数的工作委派给适当的虚函数equal。
}
```

## 运算符重载

