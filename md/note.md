# cpp

## from c to cpp

### 类（Class）和对象（Object）

类（Class）可以看做C语言中结构体（Struct）的升级版。C++ 中的类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象”。可以将类比喻成图纸，对象比喻成零件，图纸说明了零件的参数（成员变量）及其承担的任务（成员函数）；一张图纸可以生产出多个具有相同性质的零件，不同图纸可以生产不同类型的零件。在 C++ 中，通过类名就可以创建对象，即将图纸生产成零件，这个过程叫做类的**实例化**，因此也称**对象是类的一个实例（Instance）**。有些资料也将**类的成员变量称为属性（Property）**，将**类的成员函数称为方法（Method）**。

因为 C++、Java、C#、PHP 等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言。

在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，将拥有相关功能的多个函数放在一个源文件，再提供一个对应的头文件，这就是一个模块。使用模块时，引入对应的头文件就可以。

而在 C++ 中，多了一层封装，就是类（Class）。**类由一组相关联的函数、变量组成**，可以将一个类或多个类放在一个源文件，使用时引入对应的类就可以。下面是C和C++项目组织方式的对比：

![a](http://c.biancheng.net/uploads/allimg/190212/100PJ491-0.png)

![](http://c.biancheng.net/uploads/allimg/190212/100PK0J-1.png)

---

面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。

### 命名空间（Namespace）

namespace 是C++中的关键字，用来定义一个命名空间，语法格式为：

~~~cpp
namespace name{
//variables, functions, classes
}
~~~

name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。

使用变量、函数时要指明它们所在的命名空间。以上面的 fp 变量为例，可以这样来使用：
Li::fp = fopen("one.txt", "r");  //使用小李定义的变量 fp
Han::fp = fopen("two.txt", "rb+");  //使用小韩定义的变量 fp
**::是一个新符号，称为域解析操作符，在C++中用来指明要使用的命名空间。**

~~~cpp
using Li::fp;//using 声明以后的程序中如果出现了未指明命名空间的 fp，就使用 Li::fp；
using namespace Li;//声明整个命名空间,在 using 声明后，如果有未具体指定命名空间的变量产生了命名冲突，那么默认采用命名空间 Li 中的变量。
~~~

站在编译和链接的角度，代码中出现的变量名、函数名、类名等都是一种符号（Symbol）。有的符号可以指代一个**内存位置**，例如变量名、函数名；有的符号仅仅是一个**新的名称**，例如 typedef 定义的类型别名。

using namespace std;，它声明了命名空间 std，后续如果有未指定命名空间的符号，那么默认使用 std，代码中的 string、cin、cout 都位于命名空间 std。

将 std 直接声明在所有函数外部，这样虽然使用方便，但在中大型项目开发中是不被推荐的，这样做增加了命名冲突的风险，推荐在函数内部声明 std,**但一般为了方便放在函数外部。**

### 输入输出cin，cout

使用 cout 进行输出时需要紧跟<<运算符，使用 cin 进行输入时需要紧跟>>运算符，这两个运算符可以自行分析所处理的数据类型，因此无需像使用 scanf 和 printf 那样给出格式控制字符串。

```cpp
cin>>a>>b;
    cout<<a<<b<<endl;//count<<x<<'\n';//count<<"a is :\n"<<a;

### bool and const

C++ 新增了 bool 类型（布尔类型），它一般占用 1个字节长度。bool 类型只有两个取值，true 和 false：true 表示“真”，false 表示“假”

**bool flag;  //定义布尔变量**   flag = a > b;


C和C++中全局 const 变量的作用域相同，都是当前文件，不同的是它们的可见范围：C语言中 const 全局变量的可见范围是整个程序，在其他文件中使用 extern 声明后就可以使用；而C++中 const 全局变量的可见范围仅限于当前文件，在其他文件中不可见，所以它可以定义在头文件中，多次引入后也不会出错。

如果使用的是 GCC，那么可以通过添加 extern 关键字来增大 C++ 全局 const 变量的可见范围，如下所示：

extern const int n = 10;

这样 n 的可见范围就变成了整个程序，在其他文件中使用 extern 声明后就可以使用了。不过这种方式只适用于 GCC，不适用于 VS/VC。

#define 定义的常量仅仅是字符串的替换，不会进行类型检查，而 const 定义的常量是有类型的，编译器会进行类型检查，相对来说比 #define 更安全，所以鼓励使用 const 代#define。

const int n = 10;

在C++中，printf("%d\n", n);语句在编译时就将 n 的值替换成了 10，效果和printf("%d\n", 10);一样，**不管 n 所在的内存如何变化，都不会影响输出结果**。

### new和delete简介

在C++中，这两个函数仍然可以使用，但是C++又新增了两个关键字，new 和 delete：new 用来动态分配内存，delete 用来释放内存。

用 new 和 delete 分配内存更加简单：

~~~cpp
int *p = new int;  //分配1个int型的内存空间
delete p;  //释放内存
~~~

**new 操作符会根据后面的数据类型来推断所需空间的大小**。

如果希望分配一组连续的数据，可以使用 new[]：

~~~cpp
int *p = new int[10];  //分配10个int型的内存空间
delete[] p;
~~~

用 new[] 分配的内存需要用 delete[] 释放，它们是一一对应的。

和 malloc() 一样，new 也是在堆区分配内存，必须手动释放，否则只能等到程序运行结束由操作系统回收。为了避免内存泄露，通常 new 和 delete、new[] 和 delete[] 操作符应该成对出现，并且不要和C语言中 malloc()、free() 一起混用。

### inline内连函数
