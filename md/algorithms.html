<!DOCTYPE html>
<html>
<head>
<title>algorithms.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95">数据结构与算法</h1>
<h2 id="%E7%BB%AA%E8%AE%BA">绪论</h2>
<h3 id="%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD">基本术语</h3>
<p><strong>数据</strong>分为<strong>数值性数据</strong>和<strong>非数值数据</strong>，其基本单位是<strong>数据元素</strong>，是计算机处理或访问的基本单位；</p>
<p>一个数据元素可以由若干数据项组成，<strong>数据项</strong>又称<strong>属性，字段，域，<strong>分为</strong>初等项</strong>（不可分割）和<strong>组合项</strong>；</p>
<p><strong>结构</strong>：<strong>数据元素之间的关系</strong>；</p>
<p><strong>数据结构是由与特定问题相关的某一数据元素的集合(<em>对象</em>)(Data)和该集合中数据元素之间的关系(Relationship)组成的</strong>；分为<strong>静态数据结构</strong>和<strong>动态数据结构</strong>，舍弃了实际的物理背景，是通用型的定义；</p>
<p>数据结构={D,R}</p>
<p><strong>数据对象</strong>：<strong>狭义：具有一定关系的<em>相同性质</em>的数据元素的集合</strong>；<strong>广义：由数据抽象和处理数据构成的封装体</strong></p>
<p><strong>数据类型</strong>：<strong>一个值的集合和定义在这个值集合上的一组操作的总称</strong>，分为<strong>内置数据类型（亦称基本数据类型或原子类型，可直接使用）<strong>和</strong>构造数据类型（由不同成分的内置数据类型子结构按照一定的规则组成，是用编程语言描述的数据结构的存储映像）</strong>，是<strong>数据结构的实例化</strong>；数据类型<strong>再实例化</strong>得到具体变量，如<strong>类与对象</strong>；</p>
<p>抽象数据类型ADT（Abstract Data Type)：</p>
<p><strong>抽象的本质就是抽取反映问题本质的东西，忽略非本质的细节</strong>；</p>
<p>特性：<strong>使用与实现相分离</strong>，<strong>数据<em>封装</em>与<em>信息</em>隐蔽</strong>；</p>
<p>在C++，java中用类描述。C中一般不使用ADT，数据和结构是分开的。</p>
<p>数据结构：</p>
<p>一，<strong>分解和抽象</strong>：1，<strong>数据分解划分出数据的层次，再抽象得到数据的<em>逻辑结构</em></strong>；2，<strong>处理分解划分成各种功能，再通过抽象得到算法的定义</strong>。这是一个从具体（具体问题）到抽象（数据结构与算法）的过程；进一步<strong>通过对实现细节的进一步考虑得到存储结构和实现运算，从而完成程序设计的任务</strong>，实现从数据结构到具体实现。</p>
<p>二，逻辑结构和存储结构</p>
<p><strong>数据的逻辑结构根据问题所要实现的功能建立（不考虑具体实现），存储结构根据问题所要的需求（响应速度，处理时间，等）来实现数据的逻辑结构。（数据结构一般指的就是逻辑结构，逻辑结构相同，即使存储结构不同也是相同的逻辑结构）；</strong></p>
<p>逻辑结构的分类：</p>
<p><strong>线性结构 ，树形结构 ，图结构， 集合结构。</strong></p>
<p><strong>线性结构</strong>：元素之间的关系是<strong>一对一</strong>的，如线性表，向量，栈，队列，优先队列，字典等；</p>
<p><strong>非线性结构</strong>：每个数据结构可能<strong>与零个或多个其他数据元素发生联系</strong>，分为树结构（一对多）和图结构（多对多）。
如多维数组和广义表等；</p>
<p><strong>集合结构的实现往往采用其他逻辑结构的存储表示。</strong></p>
<p>数据结构的存储结构：</p>
<p>存取结构根据存取方法的不同分为三类：</p>
<p>1，<strong>直接存取结构</strong>（向量，多维数组，散列表）；</p>
<p>2，<strong>顺序存取结构</strong>（各种链表，图的邻接表）；</p>
<p>3，<strong>索引存取结构</strong>（线性索引，多叉查找树）；</p>
<p>常用的四种存储结构</p>
<p>1，<strong>顺序存储</strong>：元素之间的逻辑关系由<strong>存储单元的邻接位置关系体现</strong>，由此得到顺序存储结构，借助<strong>一维数组</strong>描述；</p>
<p>2，<strong>链接存储</strong>：元素之间的逻辑关系由<strong>附加的链接指针指示</strong>，由此得到链表存储结构，借助<strong>指针类型</strong>描述；</p>
<p>3，<strong>索引存储</strong>：在存储元素信息的同时还建立<strong>索引表</strong>，其中每一项称为<strong>索引项（包括关键码和地址）</strong>，按针对一个元素还是一组元素分为<strong>稠密索引和稀疏索引</strong>；按是一层还是多层分为线<strong>性索引和多级索引</strong>；</p>
<p>4，<strong>散列存储</strong>：根据元素的关键码<strong>通过一个函数计算得到</strong>元素的存储地址。</p>
<p>前两种在<strong>内存</strong>中，也是基本的<strong>两种物理存储结构</strong>。后两个在<strong>外存</strong>中。/</p>
<p>选择存储结构的要素有&lt;1&gt;<em>访问频率</em>，&lt;2&gt;<em>修改频率</em>，&lt;3&gt;<em>安全保密</em>；</p>
<p>定义在数据结构上的操作：</p>
<p><strong>1，创建；2，销毁；3，查找；4，插入；5，删除；6，排序</strong>。</p>
<p>好的数据结构：<strong>可以通过某种“线性化”规则被转化为线性结构，通常对应好的算法</strong>；</p>
<p>计算机本质上<strong>只能按照逻辑顺序处理指令和内存单元</strong>，例如图，树的遍历查找需要线性化。</p>
<h3 id="c%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85">C语言知识点补充</h3>
<h4 id="%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BB%93%E5%90%88%E6%96%B9%E5%90%91%E5%92%8C%E7%BB%93%E5%90%88%E6%80%A7%E5%92%8C%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8Fauto-incrementauto-decrement">运算符结合方向和结合性和自增自减(auto-increment,auto-decrement)</h4>
<p>大多数运算符结合方向是“自左至右”，即：先左后右，也叫“左结合性”，例如 a－b + c，表达式中有－和+两种运算符，且优先级相同，按先左后右结合方向，先围绕减号结合，执行a－b的运算，再围绕加号结合，完成运算(a－b) + c。除了左结合性外，C 语言有三类运算符的结合方向是从右至左，也叫“右结合性”，即：<strong>单目运算符、条件运算符、以及赋值运算符</strong>。着重强调一点，无论是左结合性，还是右结合性，是针对两个相邻的优先级相同的运行符而言(不是表达中的运算对象)，<strong>运算符是决定左右的基准点，先以前面的运算符(即位置上处于左边的运算符)构造运算，就是左结合，反之，就是右结合。</strong></p>
<p><img src="https://www.pianshen.com/images/476/c2da92eaab6cd2b87d017e12c7d7ca3c.png" alt="a"></p>
<p>i++ 与 ++i 的主要区别有两个：
1、 i++ 返回原来的值，++i 返回加1后的值。
2、 i++ 不能作为左值，而++i 可以。</p>
<p>i=1;  j=i+++i++;先执行两个i++,返回值分别为1和2；i自增两次，所以j=i=3；</p>
<p>只能用于左值，例如(num+1)--是错误的</p>
<h4 id="%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">数字转换为字符串</h4>
<pre><code>sprintf(s, &quot;%d&quot;, x);将%D形式的x以字符串形式放在s里，并自动添加结尾
</code></pre>
<h4 id="%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BC%A0%E5%8F%82">二维数组传参</h4>
<p><strong>不常用</strong></p>
<pre class="hljs"><code><div>
不用区分行列遍历
 <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p,<span class="hljs-keyword">int</span> n)</span><span class="hljs-comment">//或int p[];</span>
 </span>{
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<span class="hljs-comment">//存储在一块连续的区域</span>
     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>,p[i]);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
 }

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> s[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]={<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>};
Print((<span class="hljs-keyword">int</span>*)s,<span class="hljs-number">6</span>);<span class="hljs-comment">//(int*)s==s[0];</span>
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **p)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, *(( <span class="hljs-keyword">int</span>* )p+ <span class="hljs-number">2</span>*i + j));<span class="hljs-comment">//编译器寻址方式，根据二级指针不能自动寻址</span>
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> s[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>};
    Print((<span class="hljs-keyword">int</span> **)s);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
二维数组名的类型是type (*)[n];是一个数组指针，可强制转换成type**和type*，地址是一样的
 
</div></code></pre>
<p>常用</p>
<p><strong>int s[][n];n不能为空。一维数组也建议用int s[];较直观，便于与其他的指针区分。</strong></p>
<h4 id="%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D">动态内存分配</h4>
<pre class="hljs"><code><div> <span class="hljs-keyword">int</span> **s = (<span class="hljs-keyword">int</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span> *));
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
        s[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)
            s[j][k]=<span class="hljs-number">1</span>;
        }
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)<span class="hljs-comment">//逐层由内向外释放</span>
        <span class="hljs-built_in">free</span>(s[j]);
        <span class="hljs-built_in">free</span>(s);

 <span class="hljs-keyword">int</span> *s[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)
        s[i] = (<span class="hljs-keyword">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>));
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k&lt;<span class="hljs-number">3</span>;k++)
            s[j][k]=<span class="hljs-number">1</span>;
        }
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;<span class="hljs-number">2</span>;j++)<span class="hljs-comment">//不用也不能释放s，它不是动态分配的</span>
        <span class="hljs-built_in">free</span>(s[j]);
</div></code></pre>
<pre class="hljs"><code><div>  <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ptr, <span class="hljs-keyword">unsigned</span> newsize)</span></span>;  
  <span class="hljs-comment">//对malloc申请的内存进行大小的调整.</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">calloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> numElements, <span class="hljs-keyword">size_t</span> sizeOfElement)</span></span>; 
        <span class="hljs-comment">//初始化分配的内存,设置为0</span>
        <span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">memset</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *s, <span class="hljs-keyword">int</span> ch, <span class="hljs-keyword">size_t</span> n)</span></span>;
        <span class="hljs-comment">//将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。</span>
</div></code></pre>
<p>calloc相当于malloc加memset;</p>
<p><strong>函数需要返回字符串时不能返回局部变量，只能返回形参中的字符串或用动态分配的空间，一般用<em>calloc</em>(不用担心结尾是否为0)</strong></p>
<h4 id="ab%E5%92%8Cab%E7%9A%84%E7%9F%AD%E8%B7%AF%E8%A7%84%E5%88%99short-circuited">A&amp;&amp;B和A||B的短路规则(short-circuited)</h4>
<p>如果A为假，则A&amp;&amp;B短路，如果A为真，则A||B短路，不再判断B。</p>
<p>应用：对于A||B如果A真时B可能溢出则A必须在前；</p>
<h4 id="%E6%9F%A5%E7%9C%8B%E5%87%BD%E6%95%B0%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC">查看函数中数组的值</h4>
<p>1，*(type(*)[len])arrname;强制转换为数组指针（它的最本质类型），再取值。</p>
<p>2,*(arrname)@len;用这个简单。</p>
<h4 id="%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%92%8C%E6%B1%82%E7%89%B9%E5%AE%9A%E5%85%83%E7%B4%A0">删除元素和求特定元素</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">delchar</span><span class="hljs-params">( <span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span> c )</span><span class="hljs-comment">//删除单个位置的元素时用顺移较为简单</span>
</span>{
   <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<span class="hljs-comment">//</span>
    <span class="hljs-keyword">while</span>(str[i])<span class="hljs-comment">//用j的话需要在结尾加\0</span>
    {
        <span class="hljs-keyword">if</span>(str[j]!=c)
        str[i++]=str[j];
        j++;
    }
}
<span class="hljs-keyword">while</span> (i&lt;L.num)<span class="hljs-comment">//线性表删除特定元素</span>
    {
        <span class="hljs-keyword">if</span> (L.data[i] != x)
        {
            L.data[j++] = L.data[i];
        }
        i++;
    }
    L.num =j;
}
 <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L.num; i++)<span class="hljs-comment">//无序线性表删除重复元素，有序的与有序区的结尾元素进行比较即可</span>
    {
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= k; j++)<span class="hljs-comment">//k:border of non-repreting region</span>
        {
            <span class="hljs-keyword">if</span> (L.data[i] == L.data[j])
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (j &gt; k)
            L.data[++k] = L.data[i];
    }
    L.num = k + <span class="hljs-number">1</span>; 

<span class="hljs-keyword">while</span>(i&lt;A.num&amp;&amp;j&lt;B.num)<span class="hljs-comment">//求有序表共有元素</span>
{
    <span class="hljs-keyword">if</span>(A.data[i]&lt;B.data[j])
    i++;<span class="hljs-comment">//跳过小的元素</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(A.data[i]&gt;B.data[j])
    j++;
    <span class="hljs-keyword">else</span> same=A.data[i];
}
</div></code></pre>
<h4 id="%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2">进制转换</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ten2two</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
<span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">0</span>)
{
ten2two(n/<span class="hljs-number">2</span>);
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>,n%<span class="hljs-number">2</span>);	<span class="hljs-comment">//递归为逆序输出，故先写调用函数，后写printf</span>
}
<span class="hljs-keyword">else</span>
<span class="hljs-keyword">return</span>;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">convert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>||n==<span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> n;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> n%<span class="hljs-number">10</span>+<span class="hljs-number">2</span>*convert(n/<span class="hljs-number">10</span>);
}
</div></code></pre>
<h4 id="%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B3%95%E5%B0%8F%E7%AE%80%E5%8C%96">选择排序法小简化</h4>
<pre class="hljs"><code><div>
 <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>,index;j&lt;i<span class="hljs-number">-1</span>;j++)
    {
        index=j;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=j+<span class="hljs-number">1</span>;k&lt;i<span class="hljs-number">-1</span>;k++)
        {
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(s[k])&lt;<span class="hljs-built_in">strlen</span>(s[index]))
                index=k;
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s "</span>,s[index]);<span class="hljs-comment">//如果只是要输出将最小的依次输出然后把最小值替换即可，不用交换</span>
        <span class="hljs-built_in">strcpy</span>(s[index],s[j]);
    }
</div></code></pre>
<h4 id="%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D">浅拷贝和深拷贝</h4>
<p>结构体是一种类，拷贝概念上可近似看待</p>
<p>浅拷贝：<strong>拷贝过程中是按字节复制的</strong>，对于指针型成员变量只复制指针本身，而<strong>不复制指针所指向的目标</strong>。
<strong>值传递能保证值不变，但不能保证值上的值不变</strong>。函数传参时<strong>默认拷贝函数就是浅拷贝。</strong>
手动实现可以<strong>直接等</strong>或者用memcpy</p>
<p><strong>memcpy(&amp;CpA,&amp;A,sizeof(struct SeqList));</strong></p>
<p>另一个mem函数：void *memset(void *str, char c, size_t n) 复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。
memset(str,'$',7);</p>
<p>深拷贝：自定义拷贝函数，以实现完全复制</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DeepCopy</span><span class="hljs-params">(SeqList &amp;CpTemp, SeqList A)</span>
</span>{
    CpTemp.num = A.num;
    CpTemp.data = <span class="hljs-keyword">new</span> DataType[Length];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; A.num; i++)
    {
        CpTemp.data[i] = A.data[i];
    }
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>
{</span>
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">char</span> c;
    <span class="hljs-keyword">char</span>* p;
    stu <span class="hljs-keyword">operator</span>=( <span class="hljs-keyword">const</span> stu&amp; stuTmp)<span class="hljs-comment">//显式定义拷贝构造函数</span>
    {
        i = stuTmp.i;<span class="hljs-comment">//i==this-&gt;i;两侧能区分时可以省略</span>
        c = stuTmp.c;
        p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>(<span class="hljs-built_in">strlen</span>(stuTmp.p) + <span class="hljs-number">1</span>);
        <span class="hljs-built_in">strcpy</span>(p, stuTmp.p);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;返回拷贝的结构体
    };
};

 s2 = s1;当以拷贝的方式初始化一个对象时，会调用拷贝构造函数；当给一个对象赋值时，会调用重载过的赋值运算符
 相当于s2.<span class="hljs-keyword">operator</span>(s1);
</div></code></pre>
<p>operator=() 的返回值类型为引用，这样不但能够<strong>避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的</strong></p>
<h4 id="%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E6%95%B0">获取随机数</h4>
<p>从X到Y，有Y－X＋1个数，所以要产生从X到Y的数，只需要这样写：
<em>k=rand()%(Y-X+1)+X;</em></p>
<p>每次获取前运行<em>srand(time(NULL))</em>；改变随机数计算函数初值，在time.h下。</p>
<p>一字节（byte）等于八位（bit）；</p>
<p>整数取值范围：$\overbrace{100000....000}^{31}=-2^{31}$ 补码是源码<strong>除符号位</strong>外取反加一，逆推原码也是这样或者减一取反。$\overbrace{01111111111111111}^{32} =2^31-1$，具体值用<strong>pow表达式或者用确切值</strong>。</p>
<h4 id="%E5%BF%AB%E6%8E%92%E5%87%BD%E6%95%B0quick-sort">快排函数（quick sort）</h4>
<p>C:stdlib.h</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(
   <span class="hljs-keyword">void</span> *base,
   <span class="hljs-keyword">size_t</span> number,
   <span class="hljs-keyword">size_t</span> width,<span class="hljs-comment">//Element size in bytes.</span>
   <span class="hljs-keyword">int</span> (__cdecl *compare )(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *)<span class="hljs-comment">//qsort calls the compare routine one or more times during the sort, and passes pointers to two array elements on each call. If compare indicates two elements are the same, their order in the resulting sorted array is unspecified.</span>
)</span></span>;
</div></code></pre>
<p><strong>切记比较函数的参数类型是<em>const void *</em></strong></p>
<table>
<thead>
<tr>
<th>Compare function return value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; 0</td>
<td>elem1 less than elem2</td>
</tr>
<tr>
<td>0</td>
<td>elem1 equivalent to elem2</td>
</tr>
<tr>
<td>&gt; 0</td>
<td>elem1 greater than elem2</td>
</tr>
</tbody>
</table>
<p><strong>小于时返回0也行,即要升序时用return elem1&gt;elem2;</strong>
The array is sorted in increasing order, as defined by the comparison function. To sort an array in decreasing order, reverse the sense of &quot;greater than&quot; and &quot;less than&quot; in the comparison function.</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;limits.h&gt;//极限：里面有INT_MIN,INT_MAX;</span></span>
<span class="hljs-comment">/*#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1),是一个符号而不是实际存在的数
INT_MAX + 1 = INT_MIN
INT_MIN - 1 = INT_MAX
abs(INT_MIN) = INT_MIN&lt;0
*/</span>
<span class="hljs-comment">//快排整形</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare_ints</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* a, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* b)</span>
</span>{
    <span class="hljs-keyword">int</span> arg1 = *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*)a;
    <span class="hljs-keyword">int</span> arg2 = *(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span>*)b;
 
    <span class="hljs-keyword">if</span> (arg1 &lt; arg2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">if</span> (arg1 &gt; arg2) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
 
    <span class="hljs-comment">// return (arg1 &gt; arg2) - (arg1 &lt; arg2); // possible shortcut,注意这种写法</span>
    <span class="hljs-comment">// return arg1 - arg2; // erroneous shortcut (fails if INT_MIN is present)必须在整形范围内</span>
}
 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-keyword">int</span> ints[] = { <span class="hljs-number">-2</span>, <span class="hljs-number">99</span>, <span class="hljs-number">0</span> ,<span class="hljs-number">-743</span>, <span class="hljs-number">2</span>, INT_MIN, <span class="hljs-number">4</span> };
    <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">sizeof</span> ints / <span class="hljs-keyword">sizeof</span> *ints;<span class="hljs-comment">//*ints=ints[0];注意学习</span>
    qsort(ints, size, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">int</span>), compare_ints);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ints[i]);
    }
 
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n"</span>);
}

<span class="hljs-comment">//快排字符串</span>
<span class="hljs-comment">// crt_qsort.c</span>
<span class="hljs-comment">// arguments: every good boy deserves favor</span>

<span class="hljs-comment">/* This program reads the command-line
* parameters and uses qsort to sort them. It
* then displays the sorted arguments.
*/</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg2 )</span></span>;\\把程序本身的名字赋值给argv[<span class="hljs-number">0</span>]，接着，把后面的第一个字符串赋给argv[<span class="hljs-number">1</span>]
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv )</span>
</span>{
   <span class="hljs-keyword">int</span> i;
   <span class="hljs-comment">/* Eliminate argv[0] from sort: */</span>
   argv++;<span class="hljs-comment">//注意学习</span>
   argc--;

   <span class="hljs-comment">/* Sort remaining args using Quicksort algorithm: */</span>
   qsort( (<span class="hljs-keyword">void</span> *)argv, (<span class="hljs-keyword">size_t</span>)argc, <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">char</span> * ), compare );<span class="hljs-comment">//被排元素是字符串指针</span>
<span class="hljs-comment">//前两个类型转换可以省略</span>
   <span class="hljs-comment">/* Output sorted list: */</span>
   <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; argc; ++i )
      <span class="hljs-built_in">printf</span>( <span class="hljs-string">" %s"</span>, argv[i] );
   <span class="hljs-built_in">printf</span>( <span class="hljs-string">"\n"</span> );
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">( <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg1, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *arg2 )</span>
</span>{
   <span class="hljs-comment">/* Compare all of both strings: */</span>
   <span class="hljs-keyword">return</span> _stricmp( * ( <span class="hljs-keyword">char</span>** ) arg1, * ( <span class="hljs-keyword">char</span>** ) arg2 );<span class="hljs-comment">//*（**）将一般指针转化为字符串指针</span>
   <span class="hljs-comment">//stricmp相当于_stricmp的alias，是不区分大小写的strcmp，windows独有，linux下用strcasecmp替代</span>
}
</div></code></pre>
<p>cpp:algorithm</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last )</span></span>;

sort(a,a+<span class="hljs-number">10</span>);<span class="hljs-comment">//</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last, Compare comp )</span></span>;

sort(a,a+<span class="hljs-number">10</span>,compare);
sort(a,a+<span class="hljs-number">10</span>,less&lt;<span class="hljs-keyword">int</span>&gt;());
sort(a,a+<span class="hljs-number">10</span>,greater&lt;<span class="hljs-keyword">int</span>&gt;());
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span>

</span>{
 <span class="hljs-keyword">return</span> a&gt;b;<span class="hljs-comment">//降序</span>
}
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">array</span>&lt;<span class="hljs-keyword">int</span>, 10&gt; ints = {<span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>};
sort(ints.begin(), ints.end(), compare_ints);
 <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ints.size(); i++)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, ints[i]);
    }



comp:For all a, comp(a,a)==<span class="hljs-literal">false</span>
If comp(a,b)==<span class="hljs-literal">true</span> then comp(b,a)==<span class="hljs-literal">false</span>
<span class="hljs-keyword">if</span> comp(a,b)==<span class="hljs-literal">true</span> <span class="hljs-keyword">and</span> comp(b,c)==<span class="hljs-literal">true</span> then comp(a,c)==<span class="hljs-literal">true</span>

</div></code></pre>
<p>c的comp参数为（常无类型）指针，返回值为int（不支持bool），c++的comp参数为元素本身，返回值为bool。
c return a&gt;b是升序，c++的是降序；</p>
<p>**快排的时间复杂度为O(nlogn);</p>
<h3 id="%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1">算法和算法设计</h3>
<p><strong>算法：一个有穷的指令集。</strong></p>
<h4 id="%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7">算法的特性：</h4>
<p>1，有输入：可以通过输入语句<strong>由外部显式提供</strong>，也可以<strong>由赋值或定值语句隐式提供</strong>，即 <strong>“0个输入“</strong> 情况；
2，有输出；
3，确定性：每一步都确切，无歧义的定义，<strong>对于一组确定的输入对应一条确定的路径运算</strong>，如果会因系统状态而导致结果不一致，则只要对于每个系统状态有确定的处理手段就不影响确定性，没赋初值导致的结果不同没有对应不同状态的处理，违反确定性。
4，有穷性：<strong>初值导致算法不收敛的与算法本身无关，不违反有穷性</strong>；
5，可行性：每一条运算都足够基本（<strong>可以用基本操作或调用已实现的基本算法</strong>），都能精确执行，但<strong>并不一定都与机器指令有直接关系</strong>，并<strong>能在常数时间内完成</strong>。</p>
<p>基本设计步骤：<strong>理解需求-&gt;设计思路-&gt;算法框架-&gt;程序实现</strong>；</p>
<p>算法与程序的关系：
(1)算法在描述上一般使用半形式化的语言，而程序是用形式化的计算机语言描述的。
(2) 程序是计算机指令的有序集合。
(3)程序并不都满足算法所要求的特征，例如操作系统，是一个在无限循环中执行的程序，因而不是一个算法。
(4)一个算法可以用不同的编程语言编写出不同的程序。
(5)算法是解决问题的步骤；程序是算法的代码实现。
(6)算法要依靠程序来完成功能；程序需要算法作为灵魂。
(7)程序=算法+数据结构。</p>
<p>算法设计基本方法：</p>
<p>1，穷举法（枚举法）：&lt;1&gt;按规则列举，&lt;2&gt;盲目列举，并检查之前的列举是否重复；</p>
<p>2，迭代法（反复法）:iteration：不断用原值得到的新值代替原值，直到得到满意的解 ，新值与原值之间的关系用迭代公式表示，主要用于很难用或无法用解析法求解的计算问题，例如区间折半法求方程的根，也用来遍历表树图等数据结构。</p>
<p>3，递推法：递归的递推求解使用递归法，自顶向下，非递归的递推求解使用迭代法，自底向上；</p>
<p>4，递归法：包括自身的数据对象和调用本身的过程是递归的；递归从问题规模为n的场合开始，通过递归降低问题规模，直到递归出口，再倒推回来得到最初的值；递推是从已知条件出发；一般一个递推算法总可以转化为递归算法；例如二分法求根和求Fibonacci数两种方式的转换。但递归法不仅仅用于递推的实现（还有数据结构如链表，树图等的建立等等）。</p>
<p>递归是算法设计的基本技术，是降低分析设计难度提高程序设计效率的重要手段和工具；迭代具有更高的时空效率。</p>
<p>穷举过程中被穷举对象可能需要其他方法求解，各种方法是配合使用的。</p>
<p>算法度量</p>
<p>算法的评价标准：
1，正确性；
2，健壮性：在不正确输入条件下能自我保护，包括自动检错，报错，与用户对话来纠错；
3，可读性；变量名，函数名要有实际意义，必须加入注释；
4，高效性：主要指算法的时间代价和空间代价；
5，简单性：主要用环路复杂度度量，等于程序中判断语句和子程序调用总数加一，软件工程要求不能超过10；</p>
<p>算法分析的主要方法：<strong>事后<em>估算</em>法</strong>（插入<em>测量时间语句</em>来估算）和<strong>事前<em>统计</em>法</strong>（通过对<em>问题规模，执行频度，时间，空间复杂度</em>的进行估算。<strong>主要目的是分析算法的效率以求改进</strong>。<strong>主要方面是时间性能和空间性能</strong>。</p>
<h4 id="%E6%B5%8B%E9%87%8F%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4">测量程序运行时间</h4>
<p>clock_t start_time, end_time;给两个变量赋给当时时间，它们的差就是它们之间程序的运行时间</p>
<p>clock_t是长整形。</p>
<p>用clock()(精确到豪秒）或者time(NULL/0)（精确到秒）</p>
<p>用time直接作差即可，用clock的需要使用表达式(double)(end_time-start_time)/CLOCK_PER_SEC(每秒钟clock的增量，linux下为1000000，window下为1000)；</p>
<p>特别的sleep(x)（unisted.h)下会使linux下的clock暂停(它返回的是CPU耗费在本程序上的时间。也就是说，途中sleep的话，由于CPU资源被释放，那段时间将不被计算在内。)等待输入时clock也会暂停，带有sleep的程序运行时间精度要求不高时只能用time；windows不会；</p>
<p>window下sleep(n)单位是ms，linux下单位是s；linux下还有usleep(n),单位是um。里面乘以1000就等同于window下的sleep。</p>
<p>精确计算运行时间</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/time.h&gt; </span></span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span>  <span class="hljs-title">start_time</span>,<span class="hljs-title">end_time</span>;</span>
{
 gettimeofday(&amp;start_time,<span class="hljs-literal">NULL</span>);
 <span class="hljs-comment">/*
 代码块
      */</span> 
gettimeofday(&amp;end_time,<span class="hljs-literal">NULL</span>); 
<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lf"</span>,(end_time.tv_sec-start_time.tv_sec)+(<span class="hljs-keyword">double</span>)(end_time.tv_usec-start_time.tv_usec)/CLOCKS_PER_SEC);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

}
<span class="hljs-comment">/*
gettimeofday()会把目前的时间用tv 结构体返回，当地时区的信息则放到tz所指的结构中。
一般情况下 ，我们并不需要时区信息，所以第二个参数通常为空。
timeStart.tv_sec 这个就是秒为单位的时间戳。(double)
timeStart.tv_usec 这是当前秒中的毫秒数。(int,需要除以CLOCK_PER_SEC并转为double)；
*/</span>
</div></code></pre>
<p>算法的计算量的大小称为算法的<em>复杂性</em>。</p>
<h4 id="%E7%AE%97%E6%B3%95%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6complexitywhes%E5%BA%A6%E9%87%8F%E5%92%8C%E9%97%AE%E9%A2%98%E8%A7%84%E6%A8%A1">算法的复杂度(complexity)whe.,,S度量和问题规模</h4>
<p>问题规模从问题的描述中找到：例如在n个学生中查找和求解n阶线性方程组的问题规模都是n；</p>
<p>时间复杂度T(n)：当问题的规模从1增加到n时，解决问题的算法所耗费的时间也由1增加到T(n);</p>
<p>空间复杂度S(n):空间由1到S(n)；</p>
<p>两种度量都是问题规模n的函数，单位都是1，即单位时间(ont time unit)和单位空间都是1(ont space unit)；</p>
<p>时间复杂度度量的计算</p>
<p>算法的执行频度=每条语句的执行次数（频度）x该语句执行时间（每一条基本语句执行时间视为单位时间1，语句执行时间等于语句中基本运算语句数）=算法中所有<strong>运算语句</strong>执行频度的总和；</p>
<p>for循环控制语句的执行次数为n+1,；单位执行时间（一次执行所需语句数）为2（不包括内部），执行频度（总次数）为2(n+1)(共执行n+1次表达式2，1次表达式1，n次表达式3），循环体执行次数是n；</p>
<p>运算赋值语句是<strong>一个</strong>基本运算语句（<strong>加减乘除，转移，存取以及他们的复合</strong>），如a=b+c，return b+c，执行频度都是1；定义语句不是运算语句；</p>
<p>递归算法的执行频度可通过写出T(n)的递推形式来计算；例如T(n)=2,n&lt;=0（if判断和return）;T(n)=2+T(n-1);n&gt;0;（比上次多两次执行（if和return加和，<strong>调用函数以及return的执行次数和加和合并了，还是1</strong>）；</p>
<p>空间复杂度度量指算法所需附加存储空间，包括固定部分和可变部分（与问题规模有关）；</p>
<p>阶乘的非递归实现中，只用了一个整数存放连乘结果，附加空间数为1，空间复杂度也为1；</p>
<p>递归的空间复杂度=每次递归所要的辅助空间x递归深度；</p>
<p>阶乘的递归i实现中每一层递归都需要三个栈空间来存放形式参数，返回值以及返回地址（一旦函数调用完成，程序应该知道返回的位置，即函数调用之前的点）</p>
<p>递归深度是n，所以所需的栈空间是3n，空间复杂度为3n；</p>
<p>动态分配所涉及的空间复杂度 等于malloc的空间减去free的空间；</p>
<h4 id="%E6%B8%90%E8%BF%9B%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">渐进的时间复杂度</h4>
<p>执行频度不能确切地反映运行时间，所以用其来比较两个程序结果不一定有价值，所以只需给出算法执行频度的数量级即可达到分析的目的。</p>
<p>大<em>O</em>表示：当且仅当存在正整数c和n_0,使得T(n)&lt;=cxf(n)对所有的n&gt;=n_0成立，则称该算法的时间增长率在<em>O</em>(f(n))中，记为T(n)=<em>O</em>(f(n)).</p>
<p>算法时间复杂度T(n)增长的上限为f(n);<em>Never to underestimate the runing time of the program.</em></p>
<p>O  函数的渐近上界 upper bound
Ω 函数的渐近下界 lower dound
Θ  函数的准确界</p>
<p>Θ(f(n))=T(n):存在正常数c1,c2和n0，使对所有的n⩾n0，有0⩽c1f(n)⩽T(n)⩽c2f(n) f(n)=2n^2+n,T(n)=n^2;(同阶)同速</p>
<p>O(f(n))=T(n): 存在正常数c和n0，使对所有n⩾n0，有0⩽T(n)⩽cf(n) f(n)=n^2;T(n)=2n^2+n; f(n)_rate&gt;=T(n)_rate</p>
<p>Ω(f(n))=T(n): 存在正常数c和n0，使对所有n ⩾ n0，有0⩽cf(n)⩽T(n) f(n)=n^2,T(n)=2n^2+n;f(n)_rate&lt;=T(n)_rate</p>
<p>o(f(n))=T(n): 对任意正常数c，存在常数n0&gt;0，使对所有的n⩾n0，有0⩽T(n)⩽cf(n) T(n)=O(f(n))&amp;&amp;T(n)!=Ω(f(n));f(n)=2n^2+n;T(n)=2n;</p>
<p>f(n)_rate&gt;T(n)_rate</p>
<p>lim(T(n)/f(n))=<em>lim(T'(n)/f'(n))</em>(n-&gt;inf):1,==c:Θ(f(n))=T(n);2,-&gt;inf:o(T(n))=f(n);3,==0;o(f(n))=T(n);</p>
<p>Thus T(n)=n^2=O(n^2)=O(n^3),the first option is the best answer.</p>
<p>一般情况下O就是指Θ，前者范围更广所以一般用前者表示。</p>
<p>If T(N)is a polynomial(/ˌpɑːliˈnoʊmiəl/ 多项式) of degree k(equal to k-order),then T(N)= Θ(N^k);</p>
<p><strong>Lower-order terms</strong> can generally be ignored,and the <strong>constants</strong> can be throw away.</p>
<p>If T1(n) = O(F(N)) and T2(N) = O(g(N)),then
(a),T1(N)+T2(N) = max{O(f(N)),O(g(N))}
(b),T1(N)*T2(N) = O(f(N)*g(N)).</p>
<p>When n is sufficiently large, the growth of various functions has the following relationship:</p>
<p>c &lt;      log2n &lt; (log2n)^k&lt;n &lt; nlog n &lt; n^2 &lt;    n^3 &lt; 2^n &lt; 3^n &lt;   n!  &lt;n^n</p>
<p>Constant logarithmic      Linear     Quadratic   Cubic  Exponential  factorial
/ˌekspəˈnenʃl/
The logarithms grow very slowly.</p>
<p>$$
\log_{k_1} n&lt;n^{k_2}&lt;{k_3}^n(k_1,k_2&gt;0,k_3&gt;1)
$$</p>
<p>the rate of <strong>logarithm slower than power slower than exponient,there is no power function between n and nlogn.</strong></p>
<p>such as :</p>
<p>$$
N^{1+\frac{\varepsilon}{\sqrt{\log n}}}&lt;N\log N
$$</p>
<p><strong>O(log2n)可以简记为O(logn);由换底公式知不同底数的对数阶只差了常数倍，n(log2n)也满足</strong></p>
<p><strong>for loop statement</strong>:The total running time of a statement（语句） inside a group of nested loops(嵌套循环) is the running time of statement multiplied by the product（乘积） of the size of all the for loops;</p>
<p><strong>if/else statement</strong>:time of <em>test</em> plus the <em>lager</em> of the running time of S1 and S2.</p>
<p>函数或语句嵌套的相乘，并列的取最大。</p>
<p>计算递归的时间复杂度时，简单的可以直接当作for循环来看，复杂的通过递推式计算，结束递归那一步的执行频度如果是c可以简化为1，递推式中的常数必须严格按其执行频度来，例如裴波那契数列递归式是T(n)=T(n-1)+T(n-2)+2(if和return那一句)，n=1,2时看作1还是2无所谓。</p>
<h4 id="markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F"><a href="https://www.cnblogs.com/wuxero/p/14171220.html">markdown数学公式</a></h4>
<p><a href="https://latex.codecogs.com/eqneditor/editor.php">在线生成</a></p>
<p>图片:超链接的格式前加!
一个行内，两个行外；<em>下标，^上标 逻辑上的括号:{}
分数：\frac{}{}
方程组：\start{cases} \ \ \ \end{cases}
求和:\sum</em>{i=0}^k;
换行\,空格;
箭头\rightarrow
自适应括号\left( \right)
\sqrt{}</p>
<p>有两种省略号，\ldots 表示语文本底线对其的省略号，\cdots表示与文本中线对其的省略号。</p>
<p>$$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$$
注意竖线与内容间的空格和标题与内容的分割线,不需要用$包围</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>缩写</th>
</tr>
</thead>
<tbody>
<tr>
<td>JavaScript</td>
<td>js</td>
</tr>
<tr>
<td>Python</td>
<td>py</td>
</tr>
<tr>
<td>C++</td>
<td>cpp</td>
</tr>
<tr>
<td>“：”：决定对齐方式</td>
<td></td>
</tr>
<tr>
<td>题号</td>
<td>标题</td>
</tr>
<tr>
<td>:---</td>
<td>---:</td>
</tr>
<tr>
<td>1</td>
<td>两数之和</td>
</tr>
<tr>
<td>15</td>
<td>三数之和</td>
</tr>
<tr>
<td>262</td>
<td>行程和用户</td>
</tr>
</tbody>
</table>
<h4 id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BE%8B%E9%A2%98">时间复杂度例题：</h4>
<h5 id="%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97">循环嵌套</h5>
<pre class="hljs"><code><div>{
<span class="hljs-keyword">int</span>  i,j,k,x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)
<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">1</span>;k&lt;=j;k++)
x=x+y;
}
</div></code></pre>
<p>$$
T(n) = \sum_{i=1}^n \sum_{j=1}^i  \sum_{k=1}^j = \sum_{i=1}^n \sum_{j=1}^i j = \sum_{i=1}^n \frac{i(i+1)}{2} =\ \frac{1}{2}\times\frac{n(n+1)(2n+1)}{6}+\frac{1}{2}\times\frac{n(n+1)}{2} = \frac{n(n+1)(n+2)}{6}\
\sum_{i=1}^n i^2=\frac{n(n+1)(2n+1)}{6}\ \sum_{i=1}^n i^3=\left(\sum_{i=1}^n i\right)^2;\
\sum_{i=0}^n f(n-i)=\sum_{i=0}^n f(i)
$$</p>
<pre class="hljs"><code><div>{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
    </span>{
    <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,s=<span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(s&lt;n)
    s+=++i;
    <span class="hljs-keyword">return</span> i
    }
}
第一轮 ：s=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>;第二轮：s=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>；第n轮：s=<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">3</span>+...+i;
</div></code></pre>
<p>跳出循环时，函数执行次数i满足$\frac{n(n- 1)}{2}\geq n$;即 $i^2-i-2n\geq0$,解得$i\geq\frac{1\pm\sqrt{1+8n}}{2}$.故时间复杂度为$O(\sqrt{n}$);</p>
<p>Find the maximum of subsequence(substring) sum in A[n]:{A0,A1,...An};</p>
<p>$$
\sum_{k=i}^jA_k
$$</p>
<pre class="hljs"><code><div>Algorithm <span class="hljs-number">1</span> 
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> ThisSum,Maxsum,i,j,k;
    Maxsum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)
    <span class="hljs-keyword">for</span>(j=i;j&lt;N;j++)
    {
        ThisSum=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(k=i;k&lt;=j;k++)
        ThisSum+=A[k];
        <span class="hljs-keyword">if</span>(ThisSum&gt;Maxsum)
        Maxsum=ThisSum;
    }
    <span class="hljs-keyword">return</span> Maxsum;
}
</div></code></pre>
<p>$$
\sum_{i=0}^N \sum_{j=i}^N \sum_{k=i}^j = \frac{N^3+3N^2+2N}{6}
$$</p>
<p>evaluated inside out（由内到外计算）</p>
<p>求内层变量和时外层的变量当常量对待。</p>
<p><strong>时间复杂度为O(n^3);不需要精确计算时可以通过三层循环的次数都小于等于n得到结果；</strong></p>
<pre class="hljs"><code><div>Algorithm2:
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> ThisSum,Maxsum,i,j,k;
    Maxsum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;N;i++)
    {
        ThisSum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(j=i;j&lt;N;j++)
    {
       ThisSum+=A[j]；
        <span class="hljs-keyword">if</span>(ThisSum&gt;Maxsum)
        Maxsum=ThisSum;
    }
    }
    <span class="hljs-keyword">return</span> Maxsum;
}
<span class="hljs-function">clearly is <span class="hljs-title">O</span><span class="hljs-params">(n^<span class="hljs-number">2</span>)</span>；
</span></div></code></pre>
<h5 id="%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB">递归，分治</h5>
<pre class="hljs"><code><div>Algorithm3:

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Right)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> a[<span class="hljs-number">5</span>] = {<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-8</span>};
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, MaxSubSum(a, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>));
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span>
</span>{
    <span class="hljs-keyword">if</span> (a &gt; b)
        <span class="hljs-keyword">return</span> a;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c &gt; b)
        <span class="hljs-keyword">return</span> c;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> b;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[], <span class="hljs-keyword">int</span> Left, <span class="hljs-keyword">int</span> Ri ght)</span>
</span>{
    <span class="hljs-keyword">int</span> MaxLeftSum, MaxRightSum;
    <span class="hljs-keyword">int</span> MaxLeftBorderSum, MaxRightBorderSum;
    <span class="hljs-keyword">int</span> LeftBorderSum, RightBorderSum;
    <span class="hljs-keyword">int</span> Center, i;
    <span class="hljs-keyword">if</span> (Left == Right)<span class="hljs-comment">//递归返回终点</span>
        <span class="hljs-keyword">if</span> (A[Left] &gt; <span class="hljs-number">0</span>)
            <span class="hljs-keyword">return</span> A[Left];
        <span class="hljs-keyword">else</span>
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    Center = (Left + Right) / <span class="hljs-number">2</span>;
    MaxLeftSum = MaxSubSum(A, Left, Center);<span class="hljs-comment">//递归计算两边的最大子列和，分治思想体现。</span>
    MaxRightSum = MaxSubSum(A, Center + <span class="hljs-number">1</span>, Right);
    MaxLeftBorderSum = <span class="hljs-number">0</span>;
    LeftBorderSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i = Center; i &gt;= Left; i--)
    {
        LeftBorderSum += A[i];
        <span class="hljs-keyword">if</span> (LeftBorderSum &gt; MaxLeftBorderSum)
            MaxLeftBorderSum = LeftBorderSum;
    }
    MaxRightBorderSum = <span class="hljs-number">0</span>;
    RightBorderSum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (i = Center + <span class="hljs-number">1</span>; i &lt;= Right; i++)
    {
        RightBorderSum += A[i];
        <span class="hljs-keyword">if</span> (RightBorderSum &gt; MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum;
    }
    <span class="hljs-keyword">return</span> Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);
               <span class="hljs-comment">// 最大值在这三个值里产生</span>
}
</div></code></pre>
<p>The algorithm uses a &quot;divide-and-conqure&quot;(分治) strategy.The idea is spit the problem into two roughly equal subproblems,which are the solved recursively.</p>
<p>An Algorithm is<strong>O(log(N))<strong>if it takes constant(O(1))time to <strong>cut the problem size by a <em>fraction</em></strong>(which is usually 1/2).On the other hand,if constant time is required to merely <strong>reduce the problem by a <em>constant amount</em></strong>(such as make the problem smaller by 1),then the algorithm is</strong>O(N)</strong>.</p>
<p>$$
\begin{cases} T(n)=T(n/2)+O(1)\rightarrow T(n)=kO(1)=O(1)\log n=O(\log n)\ T(n)=2T(n/2)+O(1)\rightarrow T(n)=2^k+kO(1)=n+O(1)\log n=O(n)\ T(n)=2T(n/2)+O(n)\rightarrow T(n)=2^k+n+\frac{n}{2}\times2+\cdots=2^k+n\times k\=n+n\log n=O(n\log n)\ \end{cases}
$$</p>
<p>Simple intuition obviates the need for a brute-force approach.</p>
<p><em>接收n个数据至少需要O(N)的复杂度，故O(logN)是针对对应函数而不是程序整体说的。</em></p>
<p><strong>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</strong></p>
<p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解这种算法设计策略叫做分治法。</p>
<p>如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p>
<pre class="hljs"><code><div><span class="hljs-function">Algorithm4
<span class="hljs-keyword">int</span> <span class="hljs-title">MaxSubsequenceSum</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> A[],<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> ThisSum,Maxsum,j;
    ThisSum=MaxSum=<span class="hljs-number">0</span>;Maxsum=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;N;j++){
        ThisSum+=A[j];
        <span class="hljs-keyword">if</span>(ThisSum&gt;MaxSum)
        MaxSum= ThisSum;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ThisSum&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//越过分界点时ThisSum归零，计算下一段的最长字列和</span>
        ThisSum=<span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> Maxsum;
}

</div></code></pre>
<p>首先假设我们已经找到了最大连续和子串在数组中的起始位置（i）和结束位置（j），其中i &lt;= j，即最大和maxSum = a[i] + a[i + 1] + ... + a[j]，我们来看看这个子串有什么性质：
a[i] &gt; 0，否则我们完全可以去掉a[i]这个元素 而得到一个更大的和；
i &gt; 0且a[i - 1] &lt; 0 或 i == 0，下面假设i &gt; 0，这一条性质也是因为如果a[i - 1] &gt; 0的话我们求和时可以加上a[i - 1]这个元素得到一个更大的和；
元素a[i - 1]与它之前的任一元素之间的子串之和sum &lt; 0 ，即对于任何一个m(0 &lt;= m &lt; i -  1)，则有a[m] + a[m+ 1] + ... + a[i - 1] &lt; 0，（<strong>最大序列和不可能越过分界点，并且前面的最大字列的终点一定是m-1（如果存在非零子列和的话）一定会被记在MaxNum里</strong>），这条性质同样可以用反证法证明。</p>
<p>只要找到分界点 a[i - 1]，最大和的子串要么就在a[i - 1]元素之后，要么就在a[i - 1]之前，最大和的子串不可能跨过a[i - 1]这个点；一个数组中可能有多个这种分界点，但每个分界点都可以把前后完全分开，可以单独算分界点之间的最大和，然后在这些最大和之间取最大值。  假设对于数组a，我们找到了两个分界点a[i]和a[j],那么整个数组的最大字串和就是max(sum(a[0]...a[i-1]), sum(a[i+1]...a[j-1]), sum(a[j+1]...a[len-1]))。</p>
<h5 id="binary-search%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE">Binary Search(二分查找)</h5>
<pre class="hljs"><code><div><span class="hljs-comment">//A[N] has presorted（一次排序，永远方便，需要多次查找的都可以这样搞）</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">BinarySearch</span><span class="hljs-params">(Const ElementType A[],ElementType X,<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">int</span> Low,Mid,High;
    Low=<span class="hljs-number">0</span>;High=N<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">while</span>(Low&lt;=High)
    {
        Mid=(Low+High)/ <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(X&gt;A[Mid])
        Low=Mid+<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">if</span>(X&lt;A[Mid])
        High=Mid<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> Mid;<span class="hljs-comment">//Found</span>
    }
    <span class="hljs-keyword">return</span> NotFound<span class="hljs-comment">//is defined as -1;</span>
}
每次循环使问题的规模减小一倍，故时间复杂度是O(logn);
</div></code></pre>
<h5 id="%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0%E4%BB%A5%E5%8F%8A-%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E6%A0%B9">最大公约数和最小公倍数以及 二分法求根</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GCD</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a , <span class="hljs-keyword">int</span> b )</span><span class="hljs-comment">//辗转相除法(Greatest Common Divisor)</span>
</span>{
    <span class="hljs-keyword">int</span> temp;
    <span class="hljs-keyword">if</span>(!(a%b))
    { <span class="hljs-keyword">return</span> b;<span class="hljs-keyword">break</span>;}
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> GCD(b,a%b);<span class="hljs-comment">//除数除余数</span>
}
<span class="hljs-comment">//都不用判断a，b大小，如果a&lt;b,第一次递归或迭代会交换他们。</span>
迭代写法（推荐）：
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GCD</span><span class="hljs-params">(<span class="hljs-keyword">int</span> M, <span class="hljs-keyword">int</span> N)</span> <span class="hljs-comment">//(Euclid's algorithm)</span>
</span>{
    <span class="hljs-keyword">int</span> Rem;
    <span class="hljs-keyword">while</span>(N&gt;<span class="hljs-number">0</span>)
    {
        Rem=M%N;
        M=N;
        N=Rem;
    }
    <span class="hljs-keyword">return</span> M;
}

</div></code></pre>
<p><strong>if M&gt;N,then M mod N &lt; M/2;(If N&lt;=M/2,then remainder is smaller than N;if N&gt;M/2,then remainder is M-Nalso smaller than M/2);</strong></p>
<p>考虑(a,b)$\rightarrow$(b,a mod b)这个迭代，有两种情况：
1，如果a&gt;b,那么迭代两次后得到(a mod b,b mod (a mod b)),
有a mod b &lt; $\frac{a}{2}$, b mod (a mod b) &lt; $\frac{b}{2}$,
即迭代两次后问题的规模减小一倍；
2，如果a&gt;b,迭代一次后归入情况a，至多出现一次，可以忽略。
故其时间复杂度为 $2\log n=O(\log n)$;</p>
<pre class="hljs"><code><div>
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span>更相减损术
</span>{
    <span class="hljs-keyword">if</span>(m&gt;n)
    <span class="hljs-keyword">return</span> gcd(m-n,n);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n&gt;m)
    <span class="hljs-keyword">return</span> gcd(m,n-m);<span class="hljs-comment">//大数减小数</span>
    <span class="hljs-keyword">else</span> 
    <span class="hljs-keyword">return</span> m;
}
</div></code></pre>
<p>设gcd(a,b)=c,lcm(a,b)=d，即ab的最大公因数为c，最小公倍数为d，则一定有a=k1<em>c ， b=k2</em>c （1）      a=d/t1       b=d/t2   （2）,其中k1,k2必然互质（反证法：假设k1，k2不互质，则必定有一个大于1的最大公因数，设其为x，则有a=k1/x * xc, b=k2/x * xc,此时k1/x和k2/x已经互质，但是明显a和b有一个公因数xc,又因为x&gt;1，则xc&gt;c，和前提ab的最大公因数c矛盾，则k1,k2必然互质，同理可证t1,t2互质）</p>
<p>对于（1）式，可有b/a=k2/k1.对于（2）式，可有b/a=t1/t2,即k2/k1=t1/t2,定有常数y,使得k2=y<em>t1,k1=y</em>t2,即k2/k1=y<em>t1/y</em>t2=t1/t2,</p>
<p>而k2和k1是互质的，y只能为1，所以k2=t1,k1=t2,而k1=a/c,t2=d/b,所以a/c=d/b,即ab=cd，证毕</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span>
</span>{
    <span class="hljs-keyword">return</span> a3*(x)*(x)*(x)+a2*(x)*(x)+a1*(x)+a0;
}
<span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">isroot</span><span class="hljs-params">(<span class="hljs-keyword">double</span> a,<span class="hljs-keyword">double</span>  b)</span>
</span>{
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(f((a+b)/<span class="hljs-number">2</span>))&lt;<span class="hljs-number">1e-6</span>)<span class="hljs-comment">//也可用区间长度作为控制精度结束条件</span>
        <span class="hljs-keyword">return</span> (a+b)/<span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span>(f((a+b)/<span class="hljs-number">2</span>)*f(a)&lt;<span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> isroot(a,(a+b)/<span class="hljs-number">2</span>);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> isroot((a+b)/<span class="hljs-number">2</span>,b);
  
}

</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//Exponentiation:</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> N)</span>
</span>{
    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">0</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span>)<span class="hljs-comment">//unneceaaary</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(IsEven(N))
    <span class="hljs-function">retuen <span class="hljs-title">Pow</span><span class="hljs-params">(x*x,N/<span class="hljs-number">2</span>)</span></span>;
    <span class="hljs-keyword">else</span>
    retuen Pow(x*x,N/<span class="hljs-number">2</span>)*x;
}
O(<span class="hljs-built_in">log</span> N)


</div></code></pre>
<h5 id="%E6%B1%89%E8%AF%BA%E5%A1%94">汉诺塔</h5>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hanoi</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">char</span> A, <span class="hljs-keyword">char</span> B, <span class="hljs-keyword">char</span> C)</span><span class="hljs-comment">//盘子数量，初始轴，中间轴，目标轴；</span>
</span>{
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<span class="hljs-comment">//!最频繁的操作，是两个递归调用的终止条件</span>
    {
        move(<span class="hljs-number">1</span>,A, C);
        <span class="hljs-keyword">return</span>;<span class="hljs-comment">//或else</span>
    }
    hanoi(n - <span class="hljs-number">1</span>, A, C, B);<span class="hljs-comment">//将A上面n-1个移动到B</span>
    move(n,A, C);<span class="hljs-comment">//将A上最后一个最大的移动到C，也是移动每个子递归上最大的；</span>
    hanoi(n - <span class="hljs-number">1</span>, B, A, C);<span class="hljs-comment">//将中间轴B上的移动到C</span>
}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">move</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span> A, <span class="hljs-keyword">char</span> C)</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; m++&lt;&lt;<span class="hljs-string">':'</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">"from"</span> &lt;&lt; A &lt;&lt; <span class="hljs-string">" to"</span> &lt;&lt; C &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p><img src="https://pic2.zhimg.com/80/v2-0f0904276be548357ae841fe137230d1_1440w.jpg" alt="a">
先从左边三号节点进入，到最左边的一号节点开始逐层退出递归，全部退出后执行节点4，然后从右边三号节点进入到其左下角的一号节点开始逐层退出递归。</p>
<p>$$
T(n)=2T(n-1)+k\rightarrow T(n)=2^n
$$</p>
<h5 id="%E9%9A%8F%E6%9C%BA%E7%BD%AE%E6%8D%A2%E6%95%B0%E7%BB%84">随机置换数组</h5>
<pre class="hljs"><code><div>Algorithm1:
<span class="hljs-keyword">int</span> A[MAXN] = {<span class="hljs-number">0</span>},i,j,temp;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; )
    {
        srand(time(<span class="hljs-literal">NULL</span>));
        temp = rand() % <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; i; j++)
        {
            <span class="hljs-keyword">if</span> (temp == A[j])
                <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span>(j==i)
        A[i++]=temp;
    }

</div></code></pre>
<p>The expected number of random numbers that need to be tried is N/(N-i), This is obtained as follows: i of the N numbers would be duplicates.Thus the probability of success is N-i/N(if成功的概率); Thus the expected number of independent trials  is N/N-i（if 成功一次所需的次数）;在x次独立重复事件中，该事件发生xp次；所以该事件发生一次的概率是1/p（两边同除以xp)
The time bound is thus:</p>
<p>$$
\sum_{i=0}^{i-1} \frac{Ni}{N-i} &lt; \sum_{i=0}^{N-1} \frac{N^2}{N-i}=N^2\sum_{i=0}^{N-1} \frac{1}{N-i}=\sum_{j=1}^N \frac{1}{j}=N^2\log N
$$</p>
<p>The time bound is thus</p>
<pre class="hljs"><code><div>Algorithm2:

<span class="hljs-keyword">int</span> A[MAXN] = {<span class="hljs-number">0</span>},Used[MAXN]={<span class="hljs-number">0</span>},i,j,temp;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; )
    {
        srand(time(<span class="hljs-literal">NULL</span>));
       temp=rand()%MAXN+<span class="hljs-number">1</span>;
       <span class="hljs-keyword">if</span>(!Used[temp<span class="hljs-number">-1</span>])
       {
           A[i++]=temp;Used[temp<span class="hljs-number">-1</span>]=<span class="hljs-number">1</span>;
       }
  
    }
</div></code></pre>
<p>Obviously time complexity is O(nlogn);</p>
<pre class="hljs"><code><div>Algorithm3:
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)
    {
        A[i] = i + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAXN; i++)
    {
        srand(time(<span class="hljs-literal">NULL</span>));
        swap(A[i], A[rand() % (i+<span class="hljs-number">1</span>)]);
    }

</div></code></pre>
<p>The worst-case running time of algorithms I and II <strong>cannot be bounded</strong>because there is always a <strong>finite probability</strong> that the program <strong>will not terminate by some given time TO</strong>. The algorithm does, however, terminate with probability 1. <strong>The worst-case running time of the third algorithm is linear</strong> - its running time does not depend on the sequence of random numbers.</p>
<h2 id="%E7%BA%BF%E6%80%A7%E8%A1%A8list">线性表(List)</h2>
<h3 id="%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9">定义和特点</h3>
<p>L       =     (a1, a2, a3,...,an).
表名           首元(head)      尾元(tail)  ai：结点（数据元素） 没有元素时是空表。</p>
<p>要点：</p>
<p>1，表中元素具有逻辑上的顺序性；</p>
<p>2，表中元素个数有限；</p>
<p>3，表中元素都是数据元素（<strong>不可分</strong>）；</p>
<p>4，元素的数据类型都相同（<strong>等价类型变量（union）也可以</strong>）；</p>
<p>5，表中元素具有抽象性。</p>
<h3 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8">顺序表</h3>
<p><strong>线性表的顺序存储</strong></p>
<p><a href="/home/fengsc/Desktop/cpp/DataStructure/SeqList">源代码位置</a></p>
<h4 id="%E5%AD%98%E5%82%A8">存储</h4>
<p><strong>动态存储结构就是在程序运行期间动态的分配内存。一维数组既可以动态存储也可以静态存储</strong></p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxSize 30<span class="hljs-comment">//静态存储</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> DataType;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
    DataType data[maxSize];
    <span class="hljs-keyword">int</span> n;
}  Seqlist;

```cpp
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxSize 30<span class="hljs-comment">//动态存储</span></span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> DataType;
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>
{</span>
    DataType *data;
    <span class="hljs-keyword">int</span> n;
}  Seqlist;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">initList</span><span class="hljs-params">(Seqlist &amp;L)</span>
</span>{
L.Data=(DataType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DataType));
<span class="hljs-keyword">if</span>(!L.Data)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DataType));
<span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
L.Maxsize=InitSize;
L.n=<span class="hljs-number">0</span>;
}
</div></code></pre>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E6%AF%94%E8%BE%83%E6%AC%A1%E6%95%B0">顺序表查找时的平均比较次数</h4>
<p>$$
ACN=\sum_{i=1}^n p_i\times c_i=\sum_{i=1}^n \left( \frac{1}{n} \right) \times i=\frac{1}{n}\sum_{i=1}^n i=\frac{1}{n}\times\frac{(1+n)n}{2}=\frac{1+n}{2}
$$</p>
<p>$p_i:\frac{1}{n}$：查找对象为某个元素的平均概率;$c_i: i$：顺序查找某个元素所要比较的次数</p>
<p>最小是1，最多是n；</p>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8F%92%E5%85%A5%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0">顺序表插入时的平均移动次数</h4>
<p>$$
AMN=\frac{1}{n+1}\sum_{i=1}^{n+1} \left( n-i+1 \right) =\frac{1}{n+1}\times \frac{n(n+1)}{2}= \frac{n}{2}
$$</p>
<p>移动第ℹ-1到第n-1位置间共n-i+1个元素，最少移动0次，在第n+1个位置插入；最多移动n次，在第一个位置插入。</p>
<p>不要求顺序时可以直接插在后面。</p>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4%E6%97%B6%E7%9A%84%E5%B9%B3%E5%9D%87%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0">顺序表删除时的平均移动次数</h4>
<p>$$
AMN=\frac{1}{n}\sum_{i=1}^{n}(n-i)=\frac{1}{n}\times \frac{n(n-1)}{2}= \frac{n-1}{2}
$$</p>
<p>把第i到第n-1共n-i个元素顺序前移，最少移动0个，最多移动n-1个。</p>
<p>不要求顺序时可以直接讲最后一个元素覆盖要删除的元素。</p>
<p><strong>各种操作的时间复杂度都是O（N），大小都是二分之最小加最大</strong></p>
<p>顺序表的缺陷：在插入和删除时需要频繁的执行成块的数据移动，所以主要用于不经常插入或删除的应用程序，它具有<strong>直接存取</strong>的特性。</p>
<hr>
<h3 id="%E9%93%BE%E8%A1%A8linked-list">链表（Linked List）</h3>
<p><a href="/home/fengsc/Desktop/cpp/DataStructure/LinkedList">相关程序源文件位置</a></p>
<h4 id="%E5%8D%95%E9%93%BE%E8%A1%A8singly-linked-list">单链表（Singly Linked List）</h4>
<p><strong>也叫线性链表或单链表，是线性表的链接存储表示</strong></p>
<p>结构：为元素附加指针形成一个个结点（<em>node</em>），通过指针将各个数据元素按其逻辑顺序勾连起来，结点包括数据域（<em>data</em>）和指针域（链域）（<em>link</em>）；第一个结点称为首元结点(表头指针指向），没有前置结点(predeceor).可以通过头指针(<em>Header/Dummyhead</em>)（有利于插入删除首元节点）找到，最后一个结点称为尾元结点（表尾指针指向），没有后继结点(<em>successor</em>);</p>
<p><strong>一般用带头结点的，递归函数一般用不带头结点的，不带头结点更为简洁和通用</strong></p>
<p>添加头结点：*header = new ListNode(head);注意利用结构体里的构造函数。</p>
<p><strong>链表非引用传入的指针只能改变它们之后的结点，如果不用返回值，而其本身结点需要改变，可以解引用赋值浅拷贝，也可以用成员运算符深拷贝，一般用前者即可。</strong></p>
<pre class="hljs"><code><div>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RemoveByValWithoutReferAndHeader</span><span class="hljs-params">(LinkList Head, DataType x)</span> <span class="hljs-comment">//形参和实参唯一的区别是地址不同，它们连接着同一条链表，都可以改变首元结点</span>
</span>{
    LinkList *pcur = &amp;Head, p, phead = Head;<span class="hljs-comment">//保留原首元节点指针</span>
    <span class="hljs-keyword">while</span> (p = *pcur)
    {
        <span class="hljs-keyword">if</span> (p-&gt;data == x)
        {
            *pcur = p-&gt;next;
            <span class="hljs-built_in">free</span>(p);
        }
        <span class="hljs-keyword">else</span>
            pcur = &amp;p-&gt;next;
    }
    *phead = *Head;<span class="hljs-comment">//更新首元结点</span>
    <span class="hljs-comment">/*phead-&gt;next=head-&gt;next;
    phead-&gt;data=head-&gt;data;*/</span>
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>{</span>
    DataType data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">Next</span>;</span>
     Node(<span class="hljs-keyword">int</span> val) :data(val),next(<span class="hljs-literal">nullptr</span>) {}
     Node(Node *ptr):next(ptr){}
    Node():data(<span class="hljs-number">0</span>),next(<span class="hljs-literal">nullptr</span>) {}
    Node(<span class="hljs-keyword">int</span> val,node* ptr):data(val),next(<span class="hljs-literal">nullptr</span>){}
}LinkNode,*LinkList;
p=(LinkList)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LinkNode))=<span class="hljs-keyword">new</span> LinkNode=<span class="hljs-keyword">new</span> LinkNode()=<span class="hljs-keyword">new</span> LinkNode(<span class="hljs-number">0</span>)=<span class="hljs-keyword">new</span> LinkNode(<span class="hljs-number">0</span>,<span class="hljs-literal">nullptr</span>)=<span class="hljs-keyword">new</span> Node(**);<span class="hljs-comment">//可以用别名也可以用结构体名,类也一样</span>

</div></code></pre>
<h4 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E6%93%8D%E4%BD%9C%E9%93%BE%E8%A1%A8">二级指针操作链表</h4>
<pre class="hljs"><code><div> LinkList *cur = &amp;Head, p;<span class="hljs-comment">//注意取地址符和引用的区别</span>
    <span class="hljs-keyword">while</span> (p = *cur)
    {
        <span class="hljs-keyword">if</span> (p-&gt;data == x)
        {
            *cur = p-&gt;next;<span class="hljs-comment">/*通过当前结点的指针（pred-&gt;next）的地址直接改变当前结点指针，直接赋值会使结点脱离（操作对象只是个中间变量P），所有需要维护或通过前置结点进行的操作例如插入，删除等都可以这样，也可以同时使操作不再依赖头结点（当然一般情况还是优先加头结点），频繁的插入删除优先采用此方法，注意指针起始地址，从首元结点开始：&amp;head,从头结点开始:&amp;header-&gt;next(!=&amp;head)*/</span>
            <span class="hljs-built_in">free</span>(p);
        }
        <span class="hljs-keyword">else</span>
            cur = &amp;p-&gt;next;<span class="hljs-comment">/*cur=&amp;(*cur)-&gt;next;'-&gt;','.'优先级最高，'&amp;'，'*'其次，取得链表结点指针的地址而不是中间指针变量的地址*/</span>
    }
  {
 LinkList *pcur = &amp;Head;
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Please enter "</span> &lt;&lt; num &lt;&lt; <span class="hljs-string">"datas"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">while</span> (num--)
    {
        LinkList cur = <span class="hljs-keyword">new</span> LinkNode;
        <span class="hljs-keyword">if</span> (!cur)
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Memory allocation failed"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
        }
        <span class="hljs-built_in">cin</span> &gt;&gt; cur-&gt;data;
        *pcur = cur;
        pcur = &amp;cur-&gt;next;
    }
    *pcur = <span class="hljs-literal">nullptr</span>;
  }
  <span class="hljs-comment">/*注意辨析*pcur=(*pcur)-&gt;next(删除结点),pcur=&amp;(*pcur)-&gt;next(移动结点，底层，借助指针地址)与cur=cur-&gt;next（移动结点，表面，借助中间变量）*/</span>
</div></code></pre>
<h4 id="%E5%88%A4%E6%96%AD%E7%8E%AF%E5%92%8C%E7%9B%B8%E4%BA%A4"><img src="https://blog.csdn.net/fengxinlinux/article/details/78885764" alt="判断环和相交"></h4>
<p>$$ 2(a+b)=a+b+kr,a+b=kr;a=kr-b=(k-1)r+r-b \a：环入口到表头的距离，b:环入口到两指针第一次相遇结点的距离 $$</p>
<p>当慢指针从表头移动a次后快指针也将到达环的起点。</p>
<pre class="hljs"><code><div><span class="hljs-function">LinkNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(LinkNode *head)</span> </span>{
         LinkNode *slow = head, *fast = head;
        <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">if</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; (fast = fast-&gt;next-&gt;next))
            {
                slow = slow-&gt;next;
                <span class="hljs-keyword">if</span> (fast == slow)
                    <span class="hljs-keyword">break</span>;
            }
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;
        }
        slow=head;
        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
        {
            <span class="hljs-keyword">if</span>(fast == slow)
            <span class="hljs-keyword">return</span> fast;
            slow= slow-&gt;next;
            fast= fast-&gt;next;
        }
        
    }
</div></code></pre>
<pre class="hljs"><code><div>      ListNode *p = headA, *q = headB;
        <span class="hljs-keyword">int</span> gap = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span> (p || q)
        {
            <span class="hljs-keyword">if</span> (!(p &amp;&amp; q))
            {
                flag = p ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<span class="hljs-comment">//标记较长串</span>
                gap++;<span class="hljs-comment">//长度差值</span>
            }
            <span class="hljs-keyword">if</span> (p)
                p = p-&gt;next;
            <span class="hljs-keyword">if</span> (q)
                q = q-&gt;next;
        }
        flag ? (p = headA, q = headB) : (p = headB, q = headA);
        <span class="hljs-keyword">while</span> (gap--)
            p = p-&gt;next;
        <span class="hljs-keyword">while</span> (p != q)
        {
            p = p-&gt;next;
            q = q-&gt;next;
        }
        <span class="hljs-keyword">return</span> p;

</div></code></pre>
<pre class="hljs"><code><div>    fast=slow=head;
    <span class="hljs-keyword">while</span> (fast&amp;&amp; fast-&gt;next){<span class="hljs-comment">//find mid node</span>
        slow = slow-&gt;next;
        fast = fast-&gt;next-&gt;next;
    }
</div></code></pre>
<h4 id="%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E7%BA%BF%E6%80%A7%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83">顺序表和线性链表的比较</h4>
<h5 id="%E5%AD%98%E5%82%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E6%AF%94%E8%BE%83">存储方面的比较</h5>
<p>（1）存储利用率：</p>
<p>$$存储密度=\frac{数据结构占用的存储字节数}{为结构分配的最大字节数}$$
顺序表的存储密度为1，利用率很高；单链表小于1，数据元素需要附加指针指示元素之间的逻辑关系，利用率较差；</p>
<p>（2）空间限制：</p>
<p>顺序表只有在动态分配内存时可以扩充，但存储开销和时间开销大，效率低；单链表随用随申，一般没有存储溢出的问题，空间限制小；</p>
<p>（3）存储的占用方式：</p>
<p>顺序表的存储空间不随表的操作改变，事先估计不足或过大都会造成问题；链表占用空间随用随变，很灵活。</p>
<h5 id="%E5%AD%98%E5%8F%96%E6%96%B9%E9%9D%A2%E7%9A%84%E6%AF%94%E8%BE%83">存取方面的比较</h5>
<p>（1）存储结构特点：</p>
<p>顺序表用物理关系上的邻接关系来表示结点间的逻辑关系，结构简单；链表元素的物理存储位置和逻辑链接关系不一定一致；链表<strong>结点间的存储一般是不连续的</strong>，但<strong>链表结点内部的存储空间是连续的</strong>。</p>
<p>（2）访问方式：</p>
<p>顺序表可以从前往后或从后往前或按下标存取，链表只能沿着指针逐个节点存取，顺序表查找比链表快；</p>
<p>（3）插入删除速度：</p>
<p>顺序表平均要移动一半元素，链表只需要修改链接指针，无需移动元素；</p>
<p><strong>如果表头指针被保护，单链表的安全保密性比顺序表好</strong></p>
<p><strong>顺序表适合频繁查找，不适合频繁插入删除，链表反之。</strong></p>
<p><strong>其他链表的逻辑结构也是线性表</strong></p>
<h2 id="%E6%A0%88stack%E5%92%8C%E9%98%9F%E5%88%97quene">栈(Stack)和队列(Quene)</h2>
<p><strong>栈，队列和双端队列的逻辑结构与线性表相同，但有更多限制(restrictions)，称为运算受限的线性表或限制了存取点的线性表</strong></p>
<h3 id="%E6%A0%88">栈</h3>
<p><a href="../DataStructure/Stack/Stack.cpp">相关文件位置</a></p>
<p><strong>可定义为只允许在表的末端进行插入和删除操作的线性表(LIFO,Last In First Out)，允许操作的一端叫栈顶(top),另一端叫栈底(bottom),没有元素时叫空栈，主要操作是Pop(出栈)和Push(进栈)</strong></p>
<h4 id="%E9%A1%BA%E5%BA%8F%E6%A0%88array-implementation-of-stacks">顺序栈(Array Implementation of Stacks)</h4>
<h4 id="%E9%93%BE%E6%A0%88">链栈</h4>
<h4 id="%E6%A0%88%E7%9A%84%E6%B7%B7%E6%B4%97">栈的混洗</h4>
<p><strong>通过控制入栈和退栈时机得到不同的退栈序列</strong></p>
<p>不可能的退栈序列：例如进栈时按$\cdots p_i\cdots p_j\cdots p_k\cdots$次序，则$\cdots p_k\cdots p_i\cdots p_j\cdots$就是不可能的出栈序列，因为当$p_k$出栈时，$p_i$和$p_j$在其之前入栈，故还按原顺序在栈内，$p_i$先进于$p_j$，不可能先出于它。即在某个出栈元素之前进栈且之后出栈的几个元素，出栈后<strong>在该元素之后的顺序遵循先进后出</strong>。</p>
<p>判断是否为可能的退栈序列更直观的分析方式是根据最后一个出栈的元素将原序列分段，比它(序号)小的元素（如果存在）比他先入栈也先出栈，比它大的元素（如果存在）随后出栈，且这两部分本身也满足这个规律，具体就是将原序列递归拆解为许多n&lt;=3的序列，拆解时大区域和小区域混合或拆解成的序列存在不可能退栈序列则该序列为不可能退栈序列。<strong>n=0,1,2,3,时只有n=3时的312是不可能序列</strong>，例如dbca，没有小区域，只有大区域，但大区域是312型，故为不可能序列，dabc,大小区域混合。</p>
<p>卡特兰数(catalan)推导:对于任意的出栈序列，设最后一个元素序号是k,则比最后一个元素小的有k-1个，比它大的有n-k个，根据前面说明这两部分也是可能出栈序列并相互独立，满足乘法原则，设可能出栈序列数为f(k),则f(k)=f(k-1)*f(n-k)，k属于1到n,不同k的情况满足加法原则，故总的可能序列数是f(n) = f(0)f(n-1) + f(1)f(n-2) + …… + f(n-1)f(0)。$C_{n+1}=\sum_{i=0}^n C_i\times C_{n-i} = \frac{1}{n+1}C_{2n}^n = \frac{2n(2n-1)\cdots(n+2)}{n!}$<a href="https://en.wikipedia.org/wiki/Catalan_number">详细证明</a></p>
<h2 id="kmp">KMP</h2>
<p>P 的 next 数组定义为：next[i] 表示 P[0] ~ P[i-1] 这一个子串，使得 前k个字符恰等于后k个字符 的最大的k. 特别地，k不能取i+1（因为这个子串一共才 i+1 个字符，自己肯定与自己相等，就没有意义了）。</p>
<p>性质：P[0] 到 P[i] 这一段子串中，前next[i]个字符与后next[i]个字符一模一样。既然如此，如果失配在 P[r], 那么P[0]~P[r-1]这一段里面，前next[r]个字符恰好和后next[r]个字符相等——也就是说，我们可以拿长度为 next[r] 的那一段前缀，来顶替当前后缀的位置，让匹配继续下去.</p>
<p>主串影响失配的位置和多少，模式串影响回溯的步数（普通算法就是回溯到串首）</p>
<p>求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。最大步增为1，最小值为0；</p>
<p><img src="https://pic2.zhimg.com/80/18a9ee17b0eebabab0672687b721aee1_1440w.png" alt="a" title="配合"></p>
<p><img src="https://pic3.zhimg.com/80/f37911dc3ace184a393f359f04944e06_1440w.png" alt="a" title="失配"></p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getNext</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * p, <span class="hljs-keyword">int</span> * next)</span>
</span>{
	next[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;
	<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">-1</span>;

	<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">strlen</span>(p))
	{
		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || p[i] == p[j])
		{
			++i;
			++j;
			next[i] = j;
		}
		<span class="hljs-keyword">else</span>
			j = next[j];
	}
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">KMP</span><span class="hljs-params">(<span class="hljs-keyword">char</span> * t, <span class="hljs-keyword">char</span> * p)</span> 
</span>{
	<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; 
	<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">while</span> (i &lt; <span class="hljs-built_in">strlen</span>(t) &amp;&amp; j &lt; <span class="hljs-built_in">strlen</span>(p))
	{
		<span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span> || t[i] == p[j]) <span class="hljs-comment">//除了初始状态，当p[0]与失配的t[i]匹配不上时j会等于-1，然后p[0]将于失配处的下一个字符进行匹配，特别的i从来不会回退，也不需要回退，next数组的本质就是利用已经配对过的部分控制模式串的偏移量</span>
		{
			i++;
           		j++;
		}
	 	<span class="hljs-keyword">else</span> 
           		j = next[j];
    	}

    <span class="hljs-keyword">if</span> (j == <span class="hljs-built_in">strlen</span>(p))
       <span class="hljs-keyword">return</span> i - j;模式串的位置
    <span class="hljs-keyword">else</span> 
       <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}



</div></code></pre>
<h2 id="%E5%B9%BF%E4%B9%89%E8%A1%A8">广义表</h2>
<p>广义表，又称列表，也是一种线性存储结构。同数组类似，广义表中既可以存储不可再分的元素，也可以存储广义表，记作：</p>
<p>LS = (a1,a2,…,an)</p>
<p>其中，LS 代表广义表的名称，an 表示广义表存储的数据。广义表中每个 ai 既可以代表单个元素，也可以代表另一个广义表。</p>
<p>通常，广义表中存储的单个元素称为 &quot;原子&quot;，而存储的广义表称为 &quot;子表&quot;。</p>
<p>例如创建一个广义表 LS = {1,{1,2,3}}，我们可以这样解释此广义表的构成：广义表 LS 存储了一个原子 1 和子表 {1,2,3}。</p>
<p>以下是广义表存储数据的一些常用形式：
A = ()：A 表示一个广义表，只不过表是空的。
B = (e)：广义表 B 中只有一个原子 e。
C = (a,(b,c,d)) ：广义表 C 中有两个元素，原子 a 和子表 (b,c,d)。
D = (A,B,C)：广义表 D 中存有 3 个子表，分别是A、B和C。这种表示方式等同于 D = ((),(e),(b,c,d)) 。
E = (a,E)：广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。</p>
<p>注意，A = () 和 A = (()) 是不一样的。前者是空表，而后者是包含一个子表的广义表，只不过这个子表是空表。</p>
<p>当广义表不是空表时，称<strong>第一个数据（原子或子表）为&quot;表头&quot;，剩下的数据构成的新广义表为&quot;表尾&quot;</strong>。</p>
<p>强调一下，除非广义表为空表，否则广义表一定具有表头和表尾，且广义表的表尾一定是一个广义表。</p>
<p>例如在广义表中 LS={1,{1,2,3},5} 中，表头为原子 1，表尾为子表 {1,2,3} 和原子 5 构成的广义表，即 {{1,2,3},5}。</p>
<p>再比如，在广义表 LS = {1} 中，表头为原子 1 ，但由于广义表中无表尾元素，因此该表的表尾是一个空表，用 {} 表示。</p>
<p>tag 标记位用于区分此节点是原子还是子表，通常<strong>原子的 tag 值为 0，子表的 tag 值为 1</strong>。子表节点中的 <strong>hp 指针用于连接本子表中存储的原子或子表，tp 指针用于连接广义表中下一个原子或子表</strong>。</p>
<p><img src="http://c.biancheng.net/uploads/allimg/190427/2-1Z42F93F23F.gif" alt="a"></p>
<pre class="hljs"><code><div><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span>{</span>
    <span class="hljs-keyword">int</span> tag;<span class="hljs-comment">//标志域</span>
    <span class="hljs-keyword">union</span>{
        <span class="hljs-keyword">int</span> atom;<span class="hljs-comment">//原子结点的值域</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> *<span class="hljs-title">hp</span>;</span><span class="hljs-comment">//子表结点的指针域，hp指向表头</span>
    };<span class="hljs-comment">//共用体不用命名，直接引用其中成员即可</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GLNode</span> * <span class="hljs-title">tp</span>;</span><span class="hljs-comment">//这里的tp相当于链表的next指针，用于指向下一个数据元素</span>
}*Glist;
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-function">Glist <span class="hljs-title">creatGlist</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>{
   Glist C = <span class="hljs-keyword">new</span> GLNode;
    C-&gt;tag=<span class="hljs-number">1</span>;
    C-&gt;hp=<span class="hljs-keyword">new</span> GLNode;
    C-&gt;tp=<span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">//表头原子a</span>
    C-&gt;hp-&gt;tag=<span class="hljs-number">0</span>;
    C-&gt;hp-&gt;atom=<span class="hljs-string">'a'</span>;
    C-&gt;hp-&gt;tp=<span class="hljs-keyword">new</span> GLNode;
    C-&gt;hp-&gt;tp-&gt;tag=<span class="hljs-number">1</span>;
    C-&gt;hp-&gt;tp-&gt;hp=<span class="hljs-keyword">new</span> GLNode;
    C-&gt;hp-&gt;tp-&gt;tp=<span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">//原子b</span>
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tag=<span class="hljs-number">0</span>;
    C-&gt;hp-&gt;tp-&gt;hp-&gt;atom=<span class="hljs-string">'b'</span>;
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tp=<span class="hljs-keyword">new</span> GLNode;
    <span class="hljs-comment">//原子c</span>
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tp-&gt;tag=<span class="hljs-number">0</span>;
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tp-&gt;atom=<span class="hljs-string">'c'</span>;
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tp-&gt;tp=<span class="hljs-keyword">new</span> GLNode;
    <span class="hljs-comment">//原子d</span>
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tp-&gt;tp-&gt;tag=<span class="hljs-number">0</span>;
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tp-&gt;tp-&gt;atom=<span class="hljs-string">'d'</span>;
    C-&gt;hp-&gt;tp-&gt;hp-&gt;tp-&gt;tp-&gt;tp=<span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> C;
}
</div></code></pre>
<p>由于广义表中可以同时存储原子和子表两种类型的数据，因此在计算广义表的长度时规定，<strong>广义表中存储的每个原子算作一个数据，同样每个子表也只算作是一个数据。</strong></p>
<p>例如，在广义表 {a,{b,c,d}} 中，它包含一个原子和一个子表，因此该广义表的长度为 2。</p>
<p>再比如，广义表 {{a,b,c}} 中只有一个子表 {a,b,c}，因此它的长度为 1。</p>
<p>前面我们用 LS={a1,a2,...,an} 来表示一个广义表，其中每个 ai 都可用来表示一个原子或子表，其实它还可以表示广义表 LS 的长度为 n。
广义表规定，空表 {} 的长度为 0。</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181225/2-1Q22520131H15.gif" alt="a"></p>
<p><strong>第一种将原子也看作字表，通过字表互相连接；第二种将两者区分开，同级的互相连接</strong></p>
<p>对于图 1a) 来说，只需计算最顶层（红色标注）含有的节点数量，即可求的广义表的长度。<strong>C指向表头</strong></p>
<p>同理，对于图 1b) 来说，由于其最顶层（蓝色标注）表示的此广义表，而第二层（红色标注）表示的才是该广义表中包含的数据元素，因此可以通过计算第二层中包含的节点数量，即可求得广义表的长度。<strong>C指向整体这个表</strong>；</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">GlistLength</span><span class="hljs-params">(Glist C)</span></span>{
    <span class="hljs-keyword">int</span> Number=<span class="hljs-number">0</span>;
    Glist P=C-&gt;hp;<span class="hljs-comment">//第一种这里是C</span>
    <span class="hljs-keyword">while</span>(P){
        Number++;
        P=P-&gt;tp;
    }
    <span class="hljs-keyword">return</span> Number;
}
</div></code></pre>

</body>
</html>
